<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.index\blindsearchindex.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.Linq;

using Deveel.Data.Sql;

namespace Deveel.Data.Index {
	public class BlindSearchIndex : ColumnIndex {
		public BlindSearchIndex(ITable table, int columnOffset)
			: base(table, columnOffset) {
		}

		public override string IndexType {
			get { return DefaultIndexTypes.BlindSearch; }
		}

		private void AssertNotReadOnly() {
			if (IsReadOnly)
				throw new ArgumentException(&quot;Cannot mutate a read-only index.&quot;);
		}

		private int HighestSearch(DataObject ob, IList&lt;int&gt; list, int lower, int higher) {
			if ((higher - lower) &lt;= 5) {
				// Start from the bottom up until we find the highest val
				for (var i = higher; i &gt;= lower; --i) {
					int res = ob.CompareTo(GetValue(list[i]));
					if (res &gt;= 0)
						return i + 1;
				}
				// Didn&#39;t find return lowest
				return lower;
			}

			var mid = (lower + higher)/2;
			int compResult = ob.CompareTo(GetValue(list[mid]));

			if (compResult == 0)
				// We know the bottom is between &#39;mid&#39; and &#39;higher&#39;
				return HighestSearch(ob, list, mid, higher);

			if (compResult &lt; 0)
				return HighestSearch(ob, list, lower, mid - 1);

			return HighestSearch(ob, list, mid + 1, higher);
		}

		private void DoInsertSort(IList&lt;int&gt; list, int row) {
			int listSize = list.Count;
			if (listSize == 0) {
				list.Add(row);
			} else {
				var point = HighestSearch(GetValue(row), list, 0, listSize - 1);
				if (point == listSize) {
					list.Add(row);
				} else {
					list.Insert(point, row);
				}
			}
		}

		public override ColumnIndex Copy(ITable table, bool readOnly) {
			return new BlindSearchIndex(table, ColumnOffset);
		}

		public override void Insert(int rowNumber) {
			AssertNotReadOnly();
		}

		public override void Remove(int rowNumber) {
			AssertNotReadOnly();
		}

		public override IEnumerable&lt;int&gt; SelectRange(IndexRange[] ranges) {
			int setSize = Table.RowCount;
			// If no items in the set return an empty set
			if (setSize == 0)
				return new List&lt;int&gt;(0);

			var checker = new RangeChecker(this, ranges);
			return checker.Resolve();
		}

		public override IEnumerable&lt;int&gt; SelectAll() {
			var rowList = new List&lt;int&gt;(Table.RowCount);
			var e = Table.GetEnumerator();
			while (e.MoveNext()) {
				DoInsertSort(rowList, e.Current.RowId.RowNumber);
			}
			return rowList;
		}

		#region RangeChecker

		class RangeChecker {
			private readonly BlindSearchIndex scheme;

			/// &lt;summary&gt;
			/// The sorted list of all items in the set created as a cache for finding
			/// the first and last values.
			/// &lt;/summary&gt;
			private IEnumerable&lt;int&gt; sortedSet;

			// The list of flags for each check in the range.
			// Either 0 for no check, 1 for &lt; or &gt;, 2 for &lt;= or &gt;=.
			private readonly byte[] lowerFlags;
			private readonly byte[] upperFlags;

			// The TObject objects to check against.
			private readonly DataObject[] lowerCells;
			private readonly DataObject[] upperCells;

			private const byte NoCheck = 0;
			private const byte CheckLesserOrGreater = 1;
			private const byte CheckLesserEqualOrGreaterEqual = 2; 

			public RangeChecker(BlindSearchIndex scheme, IndexRange[] ranges) {
				this.scheme = scheme;

				int size = ranges.Length;
				lowerFlags = new byte[size];
				upperFlags = new byte[size];
				lowerCells = new DataObject[size];
				upperCells = new DataObject[size];
				for (int i = 0; i &lt; ranges.Length; ++i) {
					SetupRange(i, ranges[i]);
				}
			}

			private void ResolveSortedSet() {
				if (sortedSet == null) {
					sortedSet = scheme.SelectAll();
				}
			}

			/// &lt;summary&gt;
			/// Resolves a cell.
			/// &lt;/summary&gt;
			/// &lt;param name=&quot;ob&quot;&gt;&lt;/param&gt;
			/// &lt;returns&gt;&lt;/returns&gt;
			private DataObject ResolveCell(DataObject ob) {
				if (ob.Equals(IndexRange.FirstInSet)) {
					ResolveSortedSet();
					return scheme.GetValue(sortedSet.First());

				}
				if (ob.Equals(IndexRange.LastInSet)) {
					ResolveSortedSet();
					return scheme.GetValue(sortedSet.Last());
				}

				return ob;
			}

			/// &lt;summary&gt;
			/// Set up a range.
			/// &lt;/summary&gt;
			/// &lt;param name=&quot;i&quot;&gt;&lt;/param&gt;
			/// &lt;param name=&quot;range&quot;&gt;&lt;/param&gt;
			private void SetupRange(int i, IndexRange range) {
				var l = range.StartValue;
				var lf = range.StartOffset;
				var u = range.EndValue;
				var uf = range.EndOffset;

				// Handle lower first
				if (l.Equals(IndexRange.FirstInSet) &amp;&amp;
					lf.Equals(RangeFieldOffset.FirstValue)) {
					// Special case no lower check
					lowerFlags[i] = NoCheck;
				} else {
					if (lf.Equals(RangeFieldOffset.FirstValue)) {
						lowerFlags[i] = CheckLesserEqualOrGreaterEqual;  // &gt;=
					} else if (lf.Equals(RangeFieldOffset.AfterLastValue)) {
						lowerFlags[i] = CheckLesserOrGreater;  // &gt;
					} else {
						throw new ApplicationException(&quot;Incorrect lower flag.&quot;);
					}
					lowerCells[i] = ResolveCell(l);
				}

				// Now handle upper
				if (u.Equals(IndexRange.LastInSet) &amp;&amp;
					uf.Equals(RangeFieldOffset.LastValue)) {
					// Special case no upper check
					upperFlags[i] = NoCheck;
				} else {
					if (uf.Equals(RangeFieldOffset.LastValue)) {
						upperFlags[i] = CheckLesserEqualOrGreaterEqual;  // &lt;=
					} else if (uf.Equals( RangeFieldOffset.BeforeFirstValue)) {
						upperFlags[i] = CheckLesserOrGreater;  // &lt;
					} else {
						throw new ApplicationException(&quot;Incorrect upper flag.&quot;);
					}
					upperCells[i] = ResolveCell(u);
				}

			}

			/// &lt;summary&gt;
			/// Resolves the ranges.
			/// &lt;/summary&gt;
			/// &lt;returns&gt;&lt;/returns&gt;
			public IEnumerable&lt;int&gt; Resolve() {
				// The idea here is to only need to scan the column once to find all
				// the cells that meet our criteria.
				var list = new List&lt;int&gt;();
				var e = scheme.Table.GetEnumerator();

				int compareTally = 0;

				int size = lowerFlags.Length;
				while (e.MoveNext()) {
					int row = e.Current.RowId.RowNumber;
					// For each range
					for (int i = 0; i &lt; size; ++i) {
						bool result = true;
						byte lf = lowerFlags[i];
						if (lf != NoCheck) {
							++compareTally;
							var v = scheme.GetValue(row);
							int compare = lowerCells[i].CompareTo(v);
							if (lf == CheckLesserOrGreater) {  // &gt;
								result = (compare &lt; 0);
							} else if (lf == CheckLesserEqualOrGreaterEqual) {  // &gt;=
								result = (compare &lt;= 0);
							} else {
								throw new ApplicationException(&quot;Incorrect flag.&quot;);
							}
						}
						if (result) {
							byte uf = upperFlags[i];
							if (uf != NoCheck) {
								++compareTally;
								var v = scheme.GetValue(row);
								int compare = upperCells[i].CompareTo(v);
								if (uf == CheckLesserOrGreater) {  // &lt;
									result = (compare &gt; 0);
								} else if (uf == CheckLesserEqualOrGreaterEqual) {  // &gt;=
									result = (compare &gt;= 0);
								} else {
									throw new ApplicationException(&quot;Incorrect flag.&quot;);
								}
							}
							// Pick this row
							if (result) {
								scheme.DoInsertSort(list, row);
								break;
							}
						}
					}
				}

				return list.AsEnumerable();
			}
		}

		#endregion
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[30,10,30,47,0],[35,5,35,69,0],[41,38,41,41,0],[47,5,47,18,0],[50,4,50,33,0],[51,4,51,55,0],[53,4,53,24,0],[55,5,55,49,0],[57,4,57,23,0],[58,5,58,52,0],[60,4,60,52,0],[72,6,72,30,0],[75,3,75,4,0],[78,4,78,53,0],[86,4,86,24,0],[87,3,87,4,0],[100,4,100,48,0],[101,4,101,34,0],[103,5,103,54,0],[102,4,102,24,0],[105,4,105,19,0],[146,5,146,27,0],[147,6,147,37,0],[149,4,149,5,0],[158,6,158,25,0],[159,6,159,48,0],[163,6,163,25,0],[164,6,164,47,0],[185,6,185,30,0],[192,7,192,63,0],[205,13,205,63,0],[206,7,206,44,0],[208,7,208,63,0],[243,9,243,59,0],[253,10,253,33,0],[257,10,257,60,0],[25,3,26,31,1],[27,3,27,4,1],[34,4,34,19,1],[36,3,36,4,1],[39,4,39,30,1],[41,10,41,25,1],[42,6,42,48,1],[43,6,43,19,1],[44,7,44,20,1],[41,26,41,36,1],[64,4,64,30,1],[65,4,65,22,1],[66,5,66,19,1],[68,5,68,69,1],[69,5,69,27,1],[70,6,70,20,1],[82,4,82,24,1],[83,3,83,4,1],[90,4,90,33,1],[92,4,92,21,1],[93,5,93,29,1],[95,4,95,49,1],[96,4,96,29,1],[132,4,132,69,1],[133,5,133,26,1],[135,5,135,30,1],[136,5,136,33,1],[137,5,137,33,1],[138,5,138,39,1],[139,5,139,39,1],[140,10,140,20,1],[141,6,141,31,1],[140,40,140,43,1],[140,21,140,38,1],[143,4,143,5,1],[157,5,157,42,1],[162,5,162,41,1],[167,5,167,15,1],[176,5,176,30,1],[177,5,177,32,1],[178,5,178,28,1],[179,5,179,30,1],[182,5,183,45,1],[187,6,187,49,1],[188,7,188,54,1],[189,13,189,60,1],[190,7,190,44,1],[194,6,194,37,1],[198,5,199,44,1],[201,6,201,30,1],[203,6,203,48,1],[204,7,204,54,1],[210,6,210,37,1],[213,4,213,5,1],[222,5,222,32,1],[223,5,223,42,1],[225,5,225,26,1],[227,5,227,34,1],[229,6,229,42,1],[231,11,231,21,1],[232,7,232,26,1],[233,7,233,31,1],[234,7,234,25,1],[235,8,235,23,1],[236,8,236,37,1],[237,8,237,49,1],[238,8,238,39,1],[239,9,239,32,1],[240,15,240,56,1],[241,9,241,33,1],[246,7,246,18,1],[247,8,247,32,1],[248,8,248,26,1],[249,9,249,24,1],[250,9,250,38,1],[251,9,251,50,1],[252,9,252,40,1],[254,16,254,57,1],[255,10,255,34,1],[261,8,261,19,1],[262,9,262,40,1],[263,9,263,15,1],[231,32,231,35,1],[231,22,231,30,1],[228,5,228,25,1],[269,5,269,32,1]]);
    </script>
  </body>
</html>