<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.compile\sqlnodevisitor.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.Diagnostics.Eventing.Reader;
using System.Linq;

namespace Deveel.Data.Sql.Compile {
	/// &lt;summary&gt;
	/// The default implementation of a &lt;see cref=&quot;ISqlNodeVisitor&quot;/&gt;
	/// that implements the visitor as a protected accessor.
	/// &lt;/summary&gt;
	public class SqlNodeVisitor : ISqlNodeVisitor {
		/// &lt;summary&gt;
		/// Visits the given SQL node.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;node&quot;&gt;The &lt;see cref=&quot;ISqlNode&quot;/&gt; to visit.&lt;/param&gt;
		/// &lt;seealso cref=&quot;ISqlNodeVisitor.Visit&quot;/&gt;
		public virtual void Visit(ISqlNode node) {
			if (node is IntegerLiteralNode) {
				VisitIntegerLiteral((IntegerLiteralNode) node);
			} else if (node is NumberLiteralNode) {
				VisitNumberLiteral((NumberLiteralNode) node);
			} else if (node is StringLiteralNode) {
				VisitStringLiteral((StringLiteralNode) node);
			} else if (node is DataTypeNode) {
				VisitDataType((DataTypeNode) node);
			} else if (node is IExpressionNode) {
				VisitExpression((IExpressionNode) node);
			} else if (node is IStatementNode) {
				VisitStatement((IStatementNode) node);
			} else if (node is ISqlVisitableNode) {
				((ISqlVisitableNode) node).Accept(this);
			}
		}

		public virtual void VisitStringLiteral(StringLiteralNode node) {
		}

		public virtual void VisitNumberLiteral(NumberLiteralNode node) {
		}

		public virtual void VisitIntegerLiteral(IntegerLiteralNode node) {
		}

		public virtual void VisitDataType(DataTypeNode node) {
		}

		public virtual void VisitExpression(IExpressionNode node) {
			if (node == null)
				return;
			
			if (node is SqlConstantExpressionNode) {
				VisitConstantExpression((SqlConstantExpressionNode) node);
			} else if (node is SqlReferenceExpressionNode) {
				VisitReferenceExpression((SqlReferenceExpressionNode) node);
			} else if (node is SqlVariableRefExpressionNode) {
				VisitVariableRefExpression((SqlVariableRefExpressionNode) node);
			} else if (node is SqlBetweenExpressionNode) {
				VisitBetweenExpression((SqlBetweenExpressionNode) node);
			} else if (node is SqlCaseExpressionNode) {
				VisitCaseExpression((SqlCaseExpressionNode) node);
			} else if (node is SqlFunctionCallExpressionNode) {
				VisitFunctionCall((SqlFunctionCallExpressionNode) node);
			} else if (node is SqlExpressionTupleNode) {
				VisitTupleExpression((SqlExpressionTupleNode) node);
			} else if (node is SqlBinaryExpressionNode) {
				VisitBinaryExpression((SqlBinaryExpressionNode) node);
			} else if (node is SqlUnaryExpressionNode) {
				VisitUnaryExpression((SqlUnaryExpressionNode) node);
			} else if (node is SqlQueryExpressionNode) {
				VisitQueryExpression((SqlQueryExpressionNode) node);
			} else {
				throw new InvalidOperationException(String.Format(&quot;The expression node of type &#39;{0}&#39; is invalid.&quot;, node.GetType()));
			}
		}

		public virtual void VisitNodeList(IEnumerable&lt;ISqlNode&gt; nodes) {
			foreach (var node in nodes) {
				Visit(node);
			}
		}

		#region Expressions

		public virtual void VisitQueryExpression(SqlQueryExpressionNode node) {
		}

		public virtual void VisitTupleExpression(SqlExpressionTupleNode node) {
			var exps = node.Expressions;
			if (exps != null)
				VisitNodeList(exps.Cast&lt;ISqlNode&gt;());
		}

		public virtual void VisitUnaryExpression(SqlUnaryExpressionNode node) {
		}

		public virtual void VisitBinaryExpression(SqlBinaryExpressionNode node) {
		}

		public virtual void VisitFunctionCall(SqlFunctionCallExpressionNode node) {
		}

		public virtual void VisitCaseExpression(SqlCaseExpressionNode node) {
		}

		public virtual void VisitBetweenExpression(SqlBetweenExpressionNode node) {
		}

		public virtual void VisitVariableRefExpression(SqlVariableRefExpressionNode node) {
		}

		public virtual void VisitConstantExpression(SqlConstantExpressionNode node) {
		}

		public virtual void VisitReferenceExpression(SqlReferenceExpressionNode node) {
		}

		#endregion

		#region Statements

		public virtual void VisitStatement(IStatementNode node) {
			if (node is CreateTableNode)
				VisitCreateTable((CreateTableNode) node);
			if (node is CreateViewNode)
				VisitCreateView((CreateViewNode) node);
			if (node is CreateTriggerNode) {
				VisitCreateTrigger((CreateTriggerNode) node);
			} else if (node is SelectStatementNode) {
				VisitSelect((SelectStatementNode) node);
			}
		}

		public virtual void VisitSelect(SelectStatementNode node) {
			var exp = node.QueryExpression;
			if (exp != null)
				VisitExpression(exp);
		}

		public virtual  void VisitCreateTrigger(CreateTriggerNode node) {
			if (node.ProcedureArguments != null)
				VisitNodeList(node.ProcedureArguments);

			// TODO: handle the body
		}

		public virtual void VisitCreateView(CreateViewNode node) {
		}

		public virtual void VisitCreateTable(CreateTableNode node) {
			if (node.Columns != null)
				VisitTableColumns(node.Columns);
			if (node.Constraints != null)
				VisitTableConstraints(node.Constraints);
		}

		public virtual void VisitTableConstraints(IEnumerable&lt;TableConstraintNode&gt; constraints) {
			foreach (var constraint in constraints) {
				VisitTableConstraint(constraint);
			}
		}

		public virtual void VisitTableConstraint(TableConstraintNode arg) {
			
		}

		public virtual void VisitTableColumns(IEnumerable&lt;TableColumnNode&gt; columnNodes) {
		}

		#endregion
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[35,5,35,52,0],[37,5,37,50,0],[39,5,39,50,0],[41,5,41,40,0],[44,11,44,38,0],[45,5,45,43,0],[46,11,46,41,0],[47,5,47,45,0],[49,3,49,4,0],[52,3,52,4,0],[55,3,55,4,0],[58,3,58,4,0],[61,3,61,4,0],[65,5,65,12,0],[72,5,72,69,0],[74,5,74,61,0],[76,5,76,55,0],[84,5,84,57,0],[88,5,88,121,0],[93,25,93,30,0],[93,13,93,21,0],[94,5,94,17,0],[93,22,93,24,0],[96,3,96,4,0],[101,3,101,4,0],[104,4,104,32,0],[105,4,105,21,0],[106,5,106,42,0],[107,3,107,4,0],[110,3,110,4,0],[113,3,113,4,0],[116,3,116,4,0],[119,3,119,4,0],[122,3,122,4,0],[125,3,125,4,0],[128,3,128,4,0],[131,3,131,4,0],[138,4,138,32,0],[139,5,139,46,0],[140,4,140,31,0],[141,5,141,44,0],[142,4,142,34,0],[143,5,143,50,0],[144,11,144,43,0],[145,5,145,45,0],[147,3,147,4,0],[150,4,150,35,0],[151,4,151,20,0],[152,5,152,26,0],[153,3,153,4,0],[156,4,156,40,0],[157,5,157,44,0],[160,3,160,4,0],[163,3,163,4,0],[166,4,166,29,0],[167,5,167,37,0],[168,4,168,33,0],[169,5,169,45,0],[170,3,170,4,0],[173,31,173,42,0],[173,13,173,27,0],[174,5,174,38,0],[173,28,173,30,0],[176,3,176,4,0],[180,3,180,4,0],[183,3,183,4,0],[34,4,34,35,1],[36,11,36,41,1],[38,11,38,41,1],[40,11,40,36,1],[42,11,42,39,1],[43,5,43,45,1],[64,4,64,21,1],[67,4,67,42,1],[68,5,68,63,1],[69,11,69,50,1],[70,5,70,65,1],[71,11,71,52,1],[73,11,73,48,1],[75,11,75,45,1],[77,11,77,53,1],[78,5,78,61,1],[79,11,79,46,1],[80,5,80,57,1],[81,11,81,47,1],[82,5,82,59,1],[83,11,83,46,1],[85,11,85,46,1],[86,5,86,57,1]]);
    </script>
  </body>
</html>