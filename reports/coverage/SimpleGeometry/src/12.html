<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb-nunit\deveel.data.sql.objects\sqllongstringtests.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2014 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

using System;

using Deveel.Data.Store;

using NUnit.Framework;

namespace Deveel.Data.Sql.Objects {
	[TestFixture]
	public class SqlLongStringTests {
		private InMemoryStorageSystem storageSystem;
		private InMemoryStore testStore;
		private ObjectStore objStore;

		private ILargeObject CreateLargeObject(long size, bool compressed) {
			return objStore.CreateNewObject(size, compressed);
		}

		private ILargeObject GetLargeObject(ObjectId id) {
			return objStore.GetObject(id);
		}

		[SetUp]
		public void TestSetUp() {
			storageSystem = new InMemoryStorageSystem();
			testStore = storageSystem.CreateStore(&quot;TestStore&quot;);
			objStore = new ObjectStore(1, testStore);
			objStore.Create();
		}

		[TearDown]
		public void TestTearDown() {
			storageSystem.DeleteStore(testStore);
			storageSystem.Dispose();
			storageSystem = null;
		}

		[Test]
		public void Create_Unicode_Uncompressed() {
			var obj = CreateLargeObject(2048, false);
			var stringObj = SqlLongString.Unicode(obj);
			Assert.IsNotNull(stringObj);
			Assert.IsFalse(stringObj.IsNull);
		}

		[Test]
		public void WriteOnly_Unicode() {
			var obj = CreateLargeObject(2048, false);
			var stringObj = SqlLongString.Unicode(obj);
			Assert.IsNotNull(stringObj);
			Assert.IsFalse(stringObj.IsNull);

			var writer = stringObj.GetOutput();
			Assert.IsNotNull(writer);
			Assert.DoesNotThrow(() =&gt; writer.WriteLine(&quot;Test string&quot;));
		}

		[Test]
		public void WriteAndRead_Unicode() {
			const string testLine = &quot;A simple test string that can span several characters, &quot; +
			                        &quot;that is trying to be the longest possible, just to prove&quot; +
			                        &quot;the capacity of a LONG VARCHAR to handle very long strings. &quot;+
									&quot;Anyway it is virtually impossible to reach the maximum size &quot;+
									&quot;of a long object, that is organized in 64k byte pages and &quot;+
									&quot;spans within the local system without any constraint of size. &quot;+
									&quot;For sake of memory anyway, the maximum size of the test object &quot;+
									&quot;is set to just 2048 bytes.&quot;;

			var obj = CreateLargeObject(2048, false);
			var objId = obj.Id;

			var stringObj = SqlLongString.Unicode(obj);
			Assert.IsNotNull(stringObj);
			Assert.IsFalse(stringObj.IsNull);

			var writer = stringObj.GetOutput();
			Assert.IsNotNull(writer);
			Assert.DoesNotThrow(() =&gt; writer.WriteLine(testLine));
			writer.Flush();
			obj.Complete();
			obj.Dispose();

			obj = GetLargeObject(objId);
			Assert.IsTrue(obj.IsComplete);
			Assert.IsFalse(obj.IsCompressed);

			stringObj = SqlLongString.Unicode(obj);
			var reader = stringObj.GetInput();
			Assert.IsNotNull(reader);

			string line = null;
			Assert.DoesNotThrow(() =&gt; line = reader.ReadLine());
			Assert.IsNotNullOrEmpty(line);

			Assert.AreEqual(testLine, line);
		}

		[Test]
		public void Compare_ToLongString_Equal() {
			const string testLine = &quot;A simple test string that can span several characters, &quot; +
			                        &quot;that is trying to be the longest possible, just to prove&quot; +
			                        &quot;the capacity of a LONG VARCHAR to handle very long strings. &quot;+
									&quot;Anyway it is virtually impossible to reach the maximum size &quot;+
									&quot;of a long object, that is organized in 64k byte pages and &quot;+
									&quot;spans within the local system without any constraint of size. &quot;+
									&quot;For sake of memory anyway, the maximum size of the test object &quot;+
									&quot;is set to just 2048 bytes.&quot;;

			var obj1 = CreateLargeObject(2048, false);
			var stringObj1 = SqlLongString.Unicode(obj1);
			Assert.IsNotNull(stringObj1);
			Assert.IsFalse(stringObj1.IsNull);

			var writer1 = stringObj1.GetOutput();
			Assert.IsNotNull(writer1);
			Assert.DoesNotThrow(() =&gt; writer1.WriteLine(testLine));
			writer1.Flush();
			obj1.Complete();
			obj1.Dispose();
			
			var obj2 = CreateLargeObject(2048, false);
			var stringObj2 = SqlLongString.Unicode(obj2);
			Assert.IsNotNull(stringObj2);
			Assert.IsFalse(stringObj2.IsNull);

			var writer2 = stringObj2.GetOutput();
			Assert.IsNotNull(writer2);
			Assert.DoesNotThrow(() =&gt; writer2.WriteLine(testLine));
			writer2.Flush();
			obj2.Complete();
			obj2.Dispose();

			obj1 = GetLargeObject(obj1.Id);
			obj2 = GetLargeObject(obj2.Id);

			stringObj1 = new SqlLongString(obj1, stringObj1.CodePage);
			stringObj2 = new SqlLongString(obj2, stringObj2.CodePage);

			Assert.AreEqual(0, stringObj1.CompareTo(stringObj2));
		}

		[Test]
		public void Compare_ToString_Equal() {
			const string testLine = &quot;A simple test string that can span several characters, &quot; +
			                        &quot;that is trying to be the longest possible, just to prove&quot; +
			                        &quot;the capacity of a LONG VARCHAR to handle very long strings.&quot;;

			var obj = CreateLargeObject(2048, false);
			var objId = obj.Id;

			var stringObj = SqlLongString.Unicode(obj);
			Assert.IsNotNull(stringObj);
			Assert.IsFalse(stringObj.IsNull);

			var writer = stringObj.GetOutput();
			Assert.IsNotNull(writer);
			Assert.DoesNotThrow(() =&gt; writer.Write(testLine));
			writer.Flush();
			obj.Complete();
			obj.Dispose();

			obj = GetLargeObject(objId);
			Assert.IsTrue(obj.IsComplete);
			Assert.IsFalse(obj.IsCompressed);

			stringObj = SqlLongString.Unicode(obj);

			var s = SqlString.Unicode(testLine);
			Assert.Inconclusive(&quot;The result is known to be wrong&quot;);
			Assert.AreEqual(0, stringObj.CompareTo(s));
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[184,4,184,47,0],[185,3,185,4,0],[30,4,30,54,1],[34,4,34,34,1],[39,4,39,48,1],[40,4,40,55,1],[41,4,41,45,1],[42,4,42,22,1],[43,3,43,4,1],[47,4,47,41,1],[48,4,48,28,1],[49,4,49,25,1],[50,3,50,4,1],[54,4,54,45,1],[55,4,55,47,1],[56,4,56,32,1],[57,4,57,37,1],[58,3,58,4,1],[62,4,62,45,1],[63,4,63,47,1],[64,4,64,32,1],[65,4,65,37,1],[67,4,67,39,1],[68,4,68,29,1],[69,4,69,30,1],[69,61,69,63,1],[70,3,70,4,1],[83,4,83,45,1],[84,4,84,23,1],[86,4,86,47,1],[87,4,87,32,1],[88,4,88,37,1],[90,4,90,39,1],[91,4,91,29,1],[92,4,92,30,1],[92,56,92,58,1],[93,4,93,19,1],[94,4,94,19,1],[95,4,95,18,1],[97,4,97,32,1],[98,4,98,34,1],[99,4,99,37,1],[101,4,101,43,1],[102,4,102,38,1],[103,4,103,29,1],[105,4,105,23,1],[106,4,106,30,1],[106,54,106,56,1],[107,4,107,34,1],[109,4,109,36,1],[110,3,110,4,1],[123,4,123,46,1],[124,4,124,49,1],[125,4,125,33,1],[126,4,126,38,1],[128,4,128,41,1],[129,4,129,30,1],[130,4,130,30,1],[130,57,130,59,1],[131,4,131,20,1],[132,4,132,20,1],[133,4,133,19,1],[135,4,135,46,1],[136,4,136,49,1],[137,4,137,33,1],[138,4,138,38,1],[140,4,140,41,1],[141,4,141,30,1],[142,4,142,30,1],[142,57,142,59,1],[143,4,143,20,1],[144,4,144,20,1],[145,4,145,19,1],[147,4,147,35,1],[148,4,148,35,1],[150,4,150,62,1],[151,4,151,62,1],[153,4,153,57,1],[154,3,154,4,1],[162,4,162,45,1],[163,4,163,23,1],[165,4,165,47,1],[166,4,166,32,1],[167,4,167,37,1],[169,4,169,39,1],[170,4,170,29,1],[171,4,171,30,1],[171,52,171,54,1],[172,4,172,19,1],[173,4,173,19,1],[174,4,174,18,1],[176,4,176,32,1],[177,4,177,34,1],[178,4,178,37,1],[180,4,180,43,1],[182,4,182,40,1],[183,4,183,59,1],[69,30,69,61,1],[92,30,92,56,1],[106,30,106,54,1],[130,30,130,57,1],[142,30,142,57,1],[171,30,171,52,1]]);
    </script>
  </body>
</html>