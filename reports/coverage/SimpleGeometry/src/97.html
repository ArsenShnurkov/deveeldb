<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.index\insertsearchindex.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;

using Deveel.Data.Sql;

namespace Deveel.Data.Index {
	public sealed class InsertSearchIndex : CollatedSearchIndex {
		private IIndex&lt;int&gt; list;
		private IIndexComparer&lt;int&gt; comparer;

		private bool recordUid;

		private readonly bool readOnly;
		private readonly int readOnlyCount;

		public InsertSearchIndex(ITable table, int columnOffset) 
			: base(table, columnOffset) {
			comparer = new IndexComparerImpl(this);
			list = new BlockIndex&lt;int&gt;();
		}

		public InsertSearchIndex(ITable table, int columnOffset, IEnumerable&lt;int&gt; list)
			: this(table, columnOffset) {
			if (list != null) {
				foreach (var item in list) {
					this.list.Add(item);
				}
			}
		}

		private InsertSearchIndex(ITable table, InsertSearchIndex source, bool readOnly)
			: this(table, source.ColumnOffset, source.list) {
			this.readOnly = readOnly;

			if (readOnly)
				readOnlyCount = list.Count;

			// Do we generate lookup caches?
			recordUid = source.recordUid;

		}

		public override bool IsReadOnly {
			get { return readOnly; }
		}

		protected override int Count {
			get { return list.Count; }
		}

		public override string IndexType {
			get { return DefaultIndexTypes.InsertSearch; }
		}

		protected override DataObject First {
			get { return GetValue(list[0]); }
		}

		protected override DataObject Last {
			get { return GetValue(list[list.Count - 1]); }
		}

		internal bool RecordUid { get; set; }

		public override void Insert(int rowNumber) {
			if (IsReadOnly)
				throw new ApplicationException(&quot;Tried to change an read-only index.&quot;);

			var value = GetValue(rowNumber);
			list.InsertSort(value, rowNumber, comparer);
		}

		public override void Remove(int rowNumber) {
			if (IsReadOnly)
				throw new ApplicationException(&quot;Tried to change an read-only index.&quot;);

			var value = GetValue(rowNumber);
			var removed = list.RemoveSort(value, rowNumber, comparer);

			if (removed != rowNumber)
				throw new InvalidOperationException(String.Format(&quot;Could not remove the requested row ({0})&quot;, rowNumber));
		}

		protected override IEnumerable&lt;int&gt; AddRange(int start, int end, IEnumerable&lt;int&gt; input) {
			var result = new List&lt;int&gt;();
			if (input != null)
				result.AddRange(input);

			var en = list.GetEnumerator(start, end);
			while (en.MoveNext()) {
				result.Add(en.Current);
			}

			return result.AsReadOnly();
		}

		public override ColumnIndex Copy(ITable table, bool readOnly) {
			// ASSERTION: If readOnly, check the size of the current set is equal to
			//   when the index was created.
			if (IsReadOnly &amp;&amp; readOnlyCount != list.Count)
				throw new ApplicationException(&quot;Assert failed: read-only size is different from when created.&quot;);

			// We must create a new InsertSearch object and copy all the state
			// information from this object to the new one.
			return new InsertSearchIndex(table, this, readOnly);
		}

		protected override int SearchFirst(DataObject value) {
			return list.SearchFirst(value, comparer);
		}

		protected override int SearchLast(DataObject value) {
			return list.SearchLast(value, comparer);
		}

		protected override void Dispose(bool disposing) {
			list = null;
			comparer = null;
		}

		#region IndexComparerImpl

		private class IndexComparerImpl : IIndexComparer&lt;int&gt; {
			private readonly InsertSearchIndex columnIndex;

			public IndexComparerImpl(InsertSearchIndex columnIndex) {
				this.columnIndex = columnIndex;
			}

			private int InternalCompare(int index, DataObject value) {
				var cell = columnIndex.GetValue(index);
				var cmp =  cell.CompareTo(value);
				return cmp;
			}

			public int CompareValue(int index, DataObject val) {
				return InternalCompare(index, val);
			}

			public int Compare(int index1, int index2) {
				var cell = columnIndex.GetValue(index2);
				return InternalCompare(index1, cell);
			}
		}

		#endregion
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[47,3,48,51,0],[49,4,49,29,0],[51,4,51,17,0],[52,5,52,32,0],[55,4,55,33,0],[57,3,57,4,0],[68,10,68,48,0],[72,10,72,35,0],[76,10,76,48,0],[83,5,83,75,0],[90,4,90,19,0],[91,5,91,75,0],[93,4,93,36,0],[94,4,94,62,0],[96,4,96,29,0],[97,5,97,111,0],[98,3,98,4,0],[103,5,103,28,0],[116,4,116,50,0],[117,5,117,101,0],[121,4,121,56,0],[157,5,157,45,0],[158,5,158,42,0],[32,3,33,31,1],[34,4,34,43,1],[35,4,35,33,1],[36,3,36,4,1],[38,3,39,31,1],[40,4,40,21,1],[41,26,41,30,1],[41,14,41,22,1],[42,6,42,26,1],[41,23,41,25,1],[45,3,45,4,1],[60,10,60,26,1],[64,10,64,28,1],[82,4,82,19,1],[85,4,85,36,1],[86,4,86,48,1],[87,3,87,4,1],[101,4,101,33,1],[102,4,102,22,1],[105,4,105,44,1],[107,5,107,28,1],[106,4,106,25,1],[110,4,110,31,1],[125,4,125,45,1],[129,4,129,44,1],[133,4,133,16,1],[134,4,134,20,1],[135,3,135,4,1],[142,4,142,59,1],[143,5,143,36,1],[144,4,144,5,1],[147,5,147,44,1],[148,5,148,38,1],[149,5,149,16,1],[153,5,153,40,1]]);
    </script>
  </body>
</html>