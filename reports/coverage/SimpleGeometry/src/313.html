<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.transactions\transactiontable.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;

using Deveel.Data.DbSystem;
using Deveel.Data.Index;
using Deveel.Data.Sql;

namespace Deveel.Data.Transactions {
	internal class TransactionTable : IMutableTable {
		private int rowListRebuild;
		private IIndex rowIndex;

		private int[] indexRebuilds;
		private IIndexSet indexSet;
		private ColumnIndex[] columnIndexes;

		private int lastEntryRICheck;

		public TransactionTable(ITransaction transaction, TableSource tableSource, TableEventRegistry eventRegistry) {
			Transaction = transaction;
			TableSource = tableSource;
			EventRegistry = eventRegistry;
			DatabaseContext = tableSource.DatabaseContext;
			indexSet = transaction.GetTableManager().GetIndexSetForTable(tableSource);
			rowListRebuild = 0;

			var colCount = ColumnCount;
			indexRebuilds = new int[colCount];
			columnIndexes = new ColumnIndex[colCount];
			lastEntryRICheck = eventRegistry.EventCount;
		}

		~TransactionTable() {
			Dispose(false);
		}

		public int ColumnCount {
			get { return TableInfo.ColumnCount; }
		}

		public IDatabaseContext DatabaseContext { get; private set; }

		public TableInfo TableInfo {
			get { return TableSource.TableInfo; }
		}

		public int RowCount {
			get {
				// Ensure the row list is up to date.
				EnsureRowIndexListCurrent();
				return RowIndex.Count;
			}
		}

		private void EnsureRowIndexListCurrent() {
			int rebuildIndex = rowListRebuild;
			int journalCount = EventRegistry.EventCount;
			while (rebuildIndex &lt; journalCount) {
				var command = EventRegistry.GetEvent(rebuildIndex);
				if (command is TableRowEvent) {
					var rowEvent = (TableRowEvent) command;
					var index = rowEvent.RowNumber;

					if (rowEvent.EventType == TableRowEventType.Add ||
					    rowEvent.EventType == TableRowEventType.UpdateAdd) {
						// Add to &#39;row_list&#39;.
						if (!RowIndex.UniqueInsertSort(index))
							throw new ApplicationException(String.Format(&quot;Row index already used in this table ({0})&quot;, index));
					} else if (rowEvent.EventType == TableRowEventType.Remove ||
					           rowEvent.EventType == TableRowEventType.UpdateRemove) {
						// Remove from &#39;row_list&#39;
						if (!RowIndex.RemoveSort(index))
							throw new ApplicationException(&quot;Row index removed that wasn&#39;t in this table!&quot;);
					} else {
						throw new InvalidOperationException(String.Format(&quot;Table row event type {0} is invalid.&quot;, rowEvent.EventType));
					}
				}

				++rebuildIndex;
			}

			// It&#39;s now current (row_list_rebuild == journal_count);
			rowListRebuild = rebuildIndex;
		}

		private void EnsureColumnIndexCurrent(int column) {
			var index = columnIndexes[column];

			// NOTE: We should be assured that no Write operations can occur over
			//   this section of code because writes are exclusive operations
			//   within a transaction.
			// Are there journal entries pending on this scheme since?
			int rebuildIndex = indexRebuilds[column];
			int journalCount = EventRegistry.EventCount;
			while (rebuildIndex &lt; journalCount) {
				var tableEvent = EventRegistry.GetEvent(rebuildIndex);
				if (tableEvent is TableRowEvent) {
					var rowEvent = (TableRowEvent) tableEvent;
					if (rowEvent.EventType == TableRowEventType.Add ||
					    rowEvent.EventType == TableRowEventType.UpdateAdd) {
						index.Insert(rowEvent.RowNumber);
					} else if (rowEvent.EventType == TableRowEventType.Remove ||
					           rowEvent.EventType == TableRowEventType.UpdateRemove) {
						index.Remove(rowEvent.RowNumber);
					} else {
						throw new InvalidOperationException(String.Format(&quot;Table row event type {0} is invalid.&quot;, rowEvent.EventType));
					}
				}

				++rebuildIndex;
			}

			indexRebuilds[column] = rebuildIndex;
		}

		public DataObject GetValue(long rowNumber, int columnOffset) {
			return TableSource.GetValue((int)rowNumber, columnOffset);
		}

		public ColumnIndex GetIndex(int columnOffset) {
			if (columnOffset &lt; 0 || columnOffset &gt;= ColumnCount)
				throw new ArgumentOutOfRangeException(&quot;columnOffset&quot;);

			var index = columnIndexes[columnOffset];

			// Cache the scheme in this object.
			if (index == null) {
				index = TableSource.CreateColumnIndex(indexSet, this, columnOffset);
				columnIndexes[columnOffset] = index;
			}

			// Update the underlying scheme to the most current version.
			EnsureColumnIndexCurrent(columnOffset);

			return index;
		}

		private IIndex RowIndex {
			get {
				if (rowIndex == null)
					rowIndex = indexSet.GetIndex(0);

				return rowIndex;
			}
		}

		public ITransaction Transaction { get; private set; }

		public TableSource TableSource { get; private set; }

		public TableEventRegistry EventRegistry { get; private set; }

		private int TableId {
			get { return TableSource.TableId; }
		}

		public ObjectName FullName {
			get { return TableInfo.TableName; }
		}

		public DbObjectType ObjectType {
			get { return DbObjectType.Table; }
		}

		public IEnumerator&lt;Row&gt; GetEnumerator() {
			// Ensure the row list is up to date.
			EnsureRowIndexListCurrent();
			var enumerator = RowIndex.GetEnumerator();
			return new RowEnumerator(this, enumerator);
		}

		IEnumerator IEnumerable.GetEnumerator() {
			return GetEnumerator();
		}

		private void Dispose(bool disposing) {
			if (disposing) {
				// Dispose and invalidate the indexes
				// This is really a safety measure to ensure the index can&#39;t be
				// used outside the scope of the lifetime of this object.
				if (columnIndexes != null) {
					foreach (var columnIndex in columnIndexes) {
						if (columnIndex != null)
							columnIndex.Dispose();
					}
				}
			}

			columnIndexes = null;
			rowIndex = null;
			EventRegistry = null;
			indexRebuilds = null;
			indexSet = null;
			Transaction = null;
		}

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		public Row NewRow() {
			return new Row(this, new RowId(TableId, -1));
		}

		public void AddRow(Row row) {
			if (Transaction.ReadOnly())
				throw new Exception(&quot;Transaction is Read only.&quot;);

			if (TableSource.IsReadOnly)
				throw new ApplicationException(&quot;Can not add row - table is read-only.&quot;);

			int rowNum;
			try {
				rowNum = TableSource.AddRow(row);
			} catch (Exception ex) {
				throw new ApplicationException(
					String.Format(&quot;Unknown error when adding a row to the table &#39;{0}&#39;.&quot;, TableInfo.TableName), ex);
			}

			row.SetRowNumber(rowNum);

			// Note this doesn&#39;t need to be synchronized because we are exclusive on
			// this table.
			
			EventRegistry.Register(new TableRowEvent(TableId, rowNum, TableRowEventType.Add));
		}

		public void UpdateRow(Row row) {
			if (Transaction.ReadOnly())
				throw new Exception(&quot;Transaction is Read only.&quot;);

			// Check this isn&#39;t a Read only source
			if (TableSource.IsReadOnly)
				throw new ApplicationException(&quot;Can not update row - table is read-only.&quot;);

			if (row.RowId.IsNull)
				throw new ArgumentException(&quot;The ROWID cannot be null in an update.&quot;);

			if (row.RowId.TableId != TableId)
				throw new ArgumentException(&quot;The row was not created from this table.&quot;);

			var rowNum = row.RowId.RowNumber;

			if (rowNum &lt; 0)
				throw new ArgumentException(&quot;The number part of the ROWID is invalid.&quot;);

			// Note this doesn&#39;t need to be synchronized because we are exclusive on
			// this table.
			EventRegistry.Register(new TableRowEvent(TableId, rowNum, TableRowEventType.UpdateRemove));

			int newRowIndex;

			try {
				newRowIndex = TableSource.AddRow(row);
			} catch (IOException e) {
				throw new ApplicationException(&quot;IO Error: &quot; + e.Message, e);
			}

			row.SetRowNumber(newRowIndex);

			// Note this doesn&#39;t need to be synchronized because we are exclusive on
			// this table.
			EventRegistry.Register(new TableRowEvent(TableId, newRowIndex, TableRowEventType.UpdateAdd));
		}

		public bool RemoveRow(RowId rowId) {
			if (rowId.IsNull)
				throw new ArgumentNullException(&quot;rowId&quot;);

			if (rowId.TableId != TableId)
				throw new ArgumentException(&quot;The table part of the ROWID is not this table.&quot;);
			if (rowId.RowNumber &lt; 0)
				throw new ArgumentException(&quot;The number part of the ROWID is not valid for remove.&quot;);

			if (Transaction.ReadOnly())
				throw new Exception(&quot;Transaction is Read only.&quot;);

			// Check this isn&#39;t a Read only source
			if (TableSource.IsReadOnly)
				throw new ApplicationException(&quot;Can not remove row - table is Read only.&quot;);

			// NOTE: This must &lt;b&gt;NOT&lt;/b&gt; call &#39;RemoveRow&#39; in TableSource.
			//   We do not want to delete a row permanently from the underlying
			//   file because the transaction using this data source may yet decide
			//   to roll back the change and not delete the row.

			// Note this doesn&#39;t need to be synchronized because we are exclusive on
			// this table.
			EventRegistry.Register(new TableRowEvent(rowId.TableId, rowId.RowNumber, TableRowEventType.Remove));

			return true;
		}

		public void FlushIndexes() {
			EnsureRowIndexListCurrent();

			// This will flush all of the column indexes
			for (int i = 0; i &lt; columnIndexes.Length; ++i) {
				GetIndex(i);
			}
		}

		private void ExecuteUpdateReferentialAction(ConstraintInfo constraint, DataObject[] originalKey, DataObject[] newKey, IQueryContext context) {
			var updateRule = constraint.OnUpdate;
			if (updateRule == ForeignKeyAction.NoAction &amp;&amp;
				constraint.Deferred != ConstraintDeferrability.InitiallyImmediate) {
				// Constraint check is deferred
				return;
			}

			// So either update rule is not NO ACTION, or if it is we are initially
			// immediate.
			var keyTable = Transaction.GetMutableTable(constraint.TableName);
			var tableInfo = keyTable.TableInfo;
			var keyCols = tableInfo.IndexOfColumns(constraint.ColumnNames).ToArray();
			var keyEntries = keyTable.FindKeys(keyCols, originalKey);

			// Are there keys effected?
			if (keyEntries.Any()) {
				if (updateRule == ForeignKeyAction.NoAction)
					// Throw an exception;
					throw new ConstraintViolationException(
						SqlModelErrorCodes.ForeignKeyViolation,
						constraint.Deferred.AsDebugString() +
						&quot; foreign key constraint violation on update (&quot; +
						constraint.ConstraintName + &quot;) Columns = &quot; +
						constraint.TableName + &quot;( &quot; +
						String.Join(&quot;, &quot;, constraint.ColumnNames) +
						&quot; ) -&gt; &quot; + constraint.ForeignTable.FullName + &quot;( &quot; +
						String.Join(&quot;, &quot;, constraint.ForeignColumnNames) +
						&quot; )&quot;);

				// Perform a referential action on each updated key
				foreach (int rowNum in keyEntries) {
					var dataRow = new Row(keyTable, new RowId(keyTable.TableInfo.Id, rowNum));
					dataRow.SetFromTable();

					if (updateRule == ForeignKeyAction.Cascade) {
						// Update the keys
						for (int n = 0; n &lt; keyCols.Length; ++n) {
							dataRow.SetValue(keyCols[n], newKey[n]);
						}
						keyTable.UpdateRow(dataRow);
					} else if (updateRule == ForeignKeyAction.SetNull) {
						for (int n = 0; n &lt; keyCols.Length; ++n) {
							dataRow.SetNull(keyCols[n]);
						}
						keyTable.UpdateRow(dataRow);
					} else if (updateRule == ForeignKeyAction.SetDefault) {
						for (int n = 0; n &lt; keyCols.Length; ++n) {
							dataRow.SetDefault(keyCols[n], context);
						}
						keyTable.UpdateRow(dataRow);
					} else {
						throw new Exception(&quot;Do not understand referential action: &quot; + updateRule);
					}
				}

				// Check referential integrity of modified table,
				keyTable.AssertConstraints();
			}
		}

		public void AssertConstraints() {
			try {
				// Early exit condition
				if (lastEntryRICheck == EventRegistry.EventCount)
					return;

				// This table name
				var tableInfo = TableInfo;
				var tName = tableInfo.TableName;
				IQueryContext context = new SystemQueryContext(Transaction, tName.Parent.Name);

				// Are there any added, deleted or updated entries in the journal since
				// we last checked?
				List&lt;int&gt; rowsUpdated = new List&lt;int&gt;();
				List&lt;int&gt; rowsDeleted = new List&lt;int&gt;();
				List&lt;int&gt; rowsAdded = new List&lt;int&gt;();

				var events = EventRegistry.Skip(lastEntryRICheck);
				foreach (var tableEvent in events.OfType&lt;TableRowEvent&gt;()) {
					var rowNum = tableEvent.RowNumber;
					if (tableEvent.EventType == TableRowEventType.Remove ||
					    tableEvent.EventType == TableRowEventType.UpdateRemove) {
						rowsDeleted.Add(rowNum);

						var index = rowsAdded.IndexOf(rowNum);
						if (index != -1)
							rowsAdded.RemoveAt(index);
					} else if (tableEvent.EventType == TableRowEventType.Add ||
					           tableEvent.EventType == TableRowEventType.UpdateAdd) {
						rowsAdded.Add(rowNum);
					}

					if (tableEvent.EventType == TableRowEventType.UpdateAdd ||
						tableEvent.EventType == TableRowEventType.UpdateRemove)
						rowsUpdated.Add(rowNum);
				}

				// Were there any updates or deletes?
				if (rowsDeleted.Count &gt; 0) {
					// Get all references on this table
					var foreignConstraints = Transaction.QueryTableImportedForeignKeys(tName);

					// For each foreign constraint
					foreach (var constraint in foreignConstraints) {
						// For each deleted/updated record in the table,
						foreach (var rowNum in rowsDeleted) {
							// What was the key before it was updated/deleted
							var cols = tableInfo.IndexOfColumns(constraint.ForeignColumnNames).ToArray();

							var originalKey = new DataObject[cols.Length];
							int nullCount = 0;
							for (int p = 0; p &lt; cols.Length; ++p) {
								originalKey[p] = GetValue(rowNum, cols[p]);
								if (originalKey[p].IsNull) {
									++nullCount;
								}
							}

							// Check the original key isn&#39;t null
							if (nullCount != cols.Length) {
								// Is is an update?
								int updateIndex = rowsUpdated.IndexOf(rowNum);
								if (updateIndex != -1) {
									// Yes, this is an update
									int rowIndexAdd = rowsUpdated[updateIndex + 1];
									// It must be an update, so first see if the change caused any
									// of the keys to change.
									bool keyChanged = false;
									var keyUpdatedTo = new DataObject[cols.Length];
									for (int p = 0; p &lt; cols.Length; ++p) {
										keyUpdatedTo[p] = GetValue(rowIndexAdd, cols[p]);
										if (originalKey[p].CompareTo(keyUpdatedTo[p]) != 0) {
											keyChanged = true;
										}
									}
									if (keyChanged) {
										// Allow the delete, and execute the action,
										// What did the key update to?
										ExecuteUpdateReferentialAction(constraint, originalKey, keyUpdatedTo, context);
									}
									// If the key didn&#39;t change, we don&#39;t need to do anything.
								} else {
									// No, so it must be a delete,
									// This will look at the referencee table and if it contains
									// the key, work out what to do with it.
									ExecuteDeleteReferentialAction(constraint, originalKey, context);
								}

							}  // If the key isn&#39;t null

						}  // for each deleted rows

					}  // for each foreign key reference to this table

				}

				// Were there any rows added (that weren&#39;t deleted)?
				if (rowsAdded.Count &gt; 0) {
					int[] rowIndices = rowsAdded.ToArray();

					// Check for any field constraint violations in the added rows
					Transaction.CheckFieldConstraintViolations(this, rowIndices);

					// Check this table, adding the given row_index, immediate
					Transaction.CheckAddConstraintViolations(this, rowIndices, ConstraintDeferrability.InitiallyImmediate);
				}
			} catch (ConstraintViolationException) {
				// If a constraint violation, roll back the changes since the last
				// check.
				int rollbackPoint = EventRegistry.EventCount - lastEntryRICheck;
				if (rowListRebuild &lt;= rollbackPoint) {
					EventRegistry.Rollback(rollbackPoint);
				} else {
					// TODO: emit a warning
				}

				throw;
			} finally {
				// Make sure we update the &#39;last_entry_ri_check&#39; variable
				lastEntryRICheck = EventRegistry.EventCount;
			}
		}

		private void ExecuteDeleteReferentialAction(ConstraintInfo constraint, DataObject[] originalKey, IQueryContext context) {
			var deleteRule = constraint.OnDelete;
			if (deleteRule == ForeignKeyAction.NoAction &amp;&amp;
				constraint.Deferred != ConstraintDeferrability.InitiallyImmediate) {
				// Constraint check is deferred
				return;
			}

			// So either delete rule is not NO ACTION, or if it is we are initially
			// immediate.
			var keyTable = Transaction.GetMutableTable(constraint.TableName);
			var tableInfo = keyTable.TableInfo;
			var keyCols = tableInfo.IndexOfColumns(constraint.ColumnNames).ToArray();
			var keyEntries = keyTable.FindKeys(keyCols, originalKey).ToList();

			// Are there keys effected?
			if (keyEntries.Count &gt; 0) {
				if (deleteRule == ForeignKeyAction.NoAction) {
					// Throw an exception;
					throw new ConstraintViolationException(
						SqlModelErrorCodes.ForeignKeyViolation,
						constraint.Deferred.AsDebugString() +
						&quot; foreign key constraint violation on delete (&quot; +
						constraint.ConstraintName + &quot;) Columns = &quot; +
						constraint.TableName + &quot;( &quot; +
						String.Join(&quot;, &quot;, constraint.ColumnNames) +
						&quot; ) -&gt; &quot; + constraint.ForeignTable.FullName + &quot;( &quot; +
						String.Join(&quot;, &quot;, constraint.ForeignColumnNames) +
						&quot; )&quot;);
				}

				// Perform a referential action on each updated key
				foreach (int rowNum in keyEntries) {
					var dataRow = new Row(keyTable, new RowId(tableInfo.Id, rowNum));
					dataRow.SetFromTable();

					if (deleteRule == ForeignKeyAction.Cascade) {
						// Cascade the removal of the referenced rows
						keyTable.RemoveRow(dataRow.RowId);
					} else if (deleteRule == ForeignKeyAction.SetNull) {
						for (int n = 0; n &lt; keyCols.Length; ++n) {
							dataRow.SetNull(keyCols[n]);
						}
						keyTable.UpdateRow(dataRow);
					} else if (deleteRule == ForeignKeyAction.SetDefault) {
						for (int n = 0; n &lt; keyCols.Length; ++n) {
							dataRow.SetDefault(keyCols[n], context);
						}
						keyTable.UpdateRow(dataRow);
					} else {
						throw new Exception(&quot;Do not understand referential action: &quot; + deleteRule);
					}
				}

				// Check referential integrity of modified table,
				keyTable.AssertConstraints();
			}

		}

		public void AddLock() {
			TableSource.AddLock();
		}

		public void RemoveLock() {
			TableSource.RemoveLock();
		}

		#region RowEnumerator

		class RowEnumerator : IEnumerator&lt;Row&gt; {
			private readonly TransactionTable table;
			private readonly IIndexEnumerator&lt;int&gt; enumerator;

			public RowEnumerator(TransactionTable table, IIndexEnumerator&lt;int&gt; enumerator) {
				this.table = table;
				this.enumerator = enumerator;
			}

			public void Dispose() {
				enumerator.Dispose();
			}

			public bool MoveNext() {
				return enumerator.MoveNext();
			}

			public void Reset() {
				enumerator.Reset();
			}

			public Row Current {
				get { return new Row(table, enumerator.Current); }
			}

			object IEnumerator.Current {
				get { return Current; }
			}
		}

		#endregion
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[87,8,87,107,0],[88,13,89,70,0],[91,7,91,39,0],[92,8,92,87,0],[94,7,94,118,0],[121,13,122,70,0],[123,7,123,40,0],[125,7,125,118,0],[141,5,141,59,0],[177,10,177,37,0],[181,10,181,36,0],[192,4,192,27,0],[222,4,222,49,0],[227,5,227,54,0],[230,5,230,77,0],[235,6,235,26,0],[236,5,237,101,0],[250,5,250,54,0],[254,5,254,80,0],[257,5,257,75,0],[260,5,260,77,0],[265,5,265,77,0],[275,6,275,27,0],[276,5,276,65,0],[287,4,287,21,0],[288,5,288,46,0],[290,4,290,33,0],[291,5,291,83,0],[292,4,292,28,0],[293,5,293,90,0],[295,4,295,31,0],[296,5,296,54,0],[299,4,299,31,0],[300,5,300,80,0],[309,4,309,104,0],[311,4,311,16,0],[324,4,324,41,0],[325,4,326,71,0],[328,5,328,12,0],[333,4,333,69,0],[334,4,334,39,0],[335,4,335,77,0],[336,4,336,61,0],[339,4,339,25,0],[340,5,340,49,0],[342,6,351,13,0],[354,28,354,38,0],[354,14,354,24,0],[355,6,355,80,0],[356,6,356,29,0],[358,6,358,49,0],[360,12,360,22,0],[361,8,361,48,0],[360,43,360,46,0],[360,23,360,41,0],[363,7,363,35,0],[364,13,364,56,0],[365,12,365,22,0],[366,8,366,36,0],[365,43,365,46,0],[365,23,365,41,0],[368,7,368,35,0],[369,13,369,59,0],[370,12,370,22,0],[371,8,371,48,0],[370,43,370,46,0],[370,23,370,41,0],[373,7,373,35,0],[375,7,375,82,0],[354,25,354,27,0],[380,5,380,34,0],[382,3,382,4,0],[387,5,387,54,0],[388,6,388,13,0],[391,5,391,31,0],[392,5,392,37,0],[393,5,393,84,0],[397,5,397,45,0],[398,5,398,45,0],[399,5,399,43,0],[401,5,401,55,0],[402,32,402,62,0],[402,14,402,28,0],[403,6,403,40,0],[404,6,405,65,0],[406,7,406,31,0],[408,7,408,45,0],[409,7,409,23,0],[410,8,410,34,0],[411,13,412,69,0],[413,7,413,29,0],[416,6,417,62,0],[418,7,418,31,0],[402,29,402,31,0],[422,5,422,31,0],[424,6,424,80,0],[427,33,427,51,0],[427,15,427,29,0],[429,30,429,41,0],[429,16,429,26,0],[431,8,431,85,0],[433,8,433,54,0],[434,8,434,26,0],[435,13,435,23,0],[436,9,436,52,0],[437,9,437,35,0],[438,10,438,22,0],[435,41,435,44,0],[435,24,435,39,0],[443,8,443,37,0],[445,9,445,55,0],[446,9,446,31,0],[448,10,448,57,0],[451,10,451,34,0],[452,10,452,57,0],[453,15,453,25,0],[454,11,454,60,0],[455,11,455,62,0],[456,12,456,30,0],[453,43,453,46,0],[453,26,453,41,0],[459,10,459,25,0],[462,11,462,90,0],[469,10,469,75,0],[429,27,429,29,0],[427,30,427,32,0],[481,5,481,29,0],[482,6,482,45,0],[485,6,485,67,0],[488,6,488,109,0],[490,6,490,42,0],[493,5,493,69,0],[494,5,494,41,0],[495,6,495,44,0],[500,5,500,11,0],[503,5,503,49,0],[505,3,505,4,0],[508,4,508,41,0],[509,4,510,71,0],[512,5,512,12,0],[517,4,517,69,0],[518,4,518,39,0],[519,4,519,77,0],[520,4,520,70,0],[523,4,523,29,0],[524,5,524,49,0],[526,6,535,13,0],[539,28,539,38,0],[539,14,539,24,0],[540,6,540,71,0],[541,6,541,29,0],[543,6,543,49,0],[545,7,545,41,0],[546,13,546,56,0],[547,12,547,22,0],[548,8,548,36,0],[547,43,547,46,0],[547,23,547,41,0],[550,7,550,35,0],[551,13,551,59,0],[552,12,552,22,0],[553,8,553,48,0],[552,43,552,46,0],[552,23,552,41,0],[555,7,555,35,0],[557,7,557,82,0],[539,25,539,27,0],[562,5,562,34,0],[565,3,565,4,0],[568,4,568,26,0],[569,3,569,4,0],[572,4,572,29,0],[573,3,573,4,0],[595,5,595,24,0],[596,4,596,5,0],[603,11,603,26,0],[38,3,38,111,1],[39,4,39,30,1],[40,4,40,30,1],[41,4,41,34,1],[42,4,42,50,1],[43,4,43,78,1],[44,4,44,23,1],[46,4,46,31,1],[47,4,47,38,1],[48,4,48,46,1],[49,4,49,48,1],[50,3,50,4,1],[53,4,53,19,1],[54,3,54,4,1],[57,10,57,39,1],[63,10,63,39,1],[69,5,69,33,1],[70,5,70,27,1],[75,4,75,38,1],[76,4,76,48,1],[78,5,78,56,1],[79,5,79,34,1],[80,6,80,45,1],[81,6,81,37,1],[83,6,84,60,1],[86,7,86,45,1],[98,5,98,20,1],[77,4,77,39,1],[102,4,102,34,1],[103,3,103,4,1],[106,4,106,38,1],[112,4,112,45,1],[113,4,113,48,1],[115,5,115,59,1],[116,5,116,37,1],[117,6,117,48,1],[118,6,119,60,1],[120,7,120,40,1],[129,5,129,20,1],[114,4,114,39,1],[132,4,132,41,1],[133,3,133,4,1],[136,4,136,62,1],[140,4,140,56,1],[143,4,143,44,1],[146,4,146,22,1],[147,5,147,73,1],[148,5,148,41,1],[152,4,152,43,1],[154,4,154,17,1],[159,5,159,26,1],[160,6,160,38,1],[162,5,162,21,1],[173,10,173,37,1],[186,4,186,32,1],[187,4,187,46,1],[188,4,188,47,1],[196,4,196,18,1],[200,5,200,31,1],[201,34,201,47,1],[201,15,201,30,1],[202,7,202,31,1],[203,8,203,30,1],[201,31,201,33,1],[208,4,208,25,1],[209,4,209,20,1],[210,4,210,25,1],[211,4,211,25,1],[212,4,212,20,1],[213,4,213,23,1],[214,3,214,4,1],[217,4,217,18,1],[218,4,218,30,1],[219,3,219,4,1],[226,4,226,31,1],[229,4,229,31,1],[234,5,234,38,1],[240,4,240,29,1],[245,4,245,86,1],[246,3,246,4,1],[249,4,249,31,1],[253,4,253,31,1],[256,4,256,25,1],[259,4,259,37,1],[262,4,262,37,1],[264,4,264,19,1],[269,4,269,95,1],[274,5,274,43,1],[279,4,279,34,1],[283,4,283,97,1],[284,3,284,4,1],[315,4,315,32,1],[318,9,318,19,1],[319,5,319,17,1],[318,46,318,49,1],[318,20,318,44,1],[321,3,321,4,1],[581,4,581,82,1],[582,5,582,24,1],[583,5,583,34,1],[584,4,584,5,1],[587,5,587,26,1],[588,4,588,5,1],[591,5,591,34,1],[599,11,599,53,1]]);
    </script>
  </body>
</html>