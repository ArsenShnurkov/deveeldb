<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.index\columnindex.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.Linq;

using Deveel.Data.Sql;

namespace Deveel.Data.Index {
	public abstract class ColumnIndex : IDisposable {
		private static readonly BlockIndex&lt;int&gt; EmptyList;
		private static readonly BlockIndex&lt;int&gt; OneList;

		protected ColumnIndex(ITable table, int columnOffset) {
			ColumnOffset = columnOffset;
			Table = table;
		}

		~ColumnIndex() {
			Dispose(false);
		}

		static ColumnIndex() {
			EmptyList = new BlockIndex&lt;int&gt;();
			EmptyList.IsReadOnly = true;
			OneList = new BlockIndex&lt;int&gt;();
			OneList.Add(0);
			OneList.IsReadOnly = true;
		}

		public ITable Table { get; private set; }

		public int ColumnOffset { get; private set; }

		public virtual bool IsReadOnly {
			get { return false; }
		}

		public virtual bool HandlesTextSearch {
			get { return false; }
		}

		public abstract string IndexType { get; }

		protected DataObject GetValue(long row) {
			return Table.GetValue(row, ColumnOffset);
		}

		public abstract ColumnIndex Copy(ITable table, bool readOnly);

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing) {
		}

		public abstract void Insert(int rowNumber);

		public abstract void Remove(int rowNumber);

		public IIndex&lt;int&gt; Order(IEnumerable&lt;int&gt; rows) {
			var rowSet = rows.ToList();

			// The length of the set to order
			int rowSetLength = rowSet.Count;

			// Trivial cases where sorting is not required:
			// NOTE: We use readOnly objects to save some memory.
			if (rowSetLength == 0)
				return EmptyList;
			if (rowSetLength == 1)
				return OneList;

			// This will be &#39;row set&#39; sorted by its entry lookup.  This must only
			// contain indices to rowSet entries.
			var newSet = new BlockIndex&lt;int&gt;();

			if (rowSetLength &lt;= 250000) {
				// If the subset is less than or equal to 250,000 elements, we generate
				// an array in memory that contains all values in the set and we sort
				// it.  This requires use of memory from the heap but is faster than
				// the no heap use method.
				var subsetList = new List&lt;DataObject&gt;(rowSetLength);
				foreach (long row in rowSet) {
					subsetList.Add(GetValue(row));
				}

				// The comparator we use to sort
				var comparer = new SubsetIndexComparer(subsetList.ToArray());

				// Fill new_set with the set { 0, 1, 2, .... , row_set_length }
				for (int i = 0; i &lt; rowSetLength; ++i) {
					var cell = subsetList[i];
					newSet.InsertSort(cell, i, comparer);
				}

			} else {
				// This is the no additional heap use method to sorting the sub-set.

				// The comparator we use to sort
				var comparer = new IndexComparer(this, rowSet);

				// Fill new_set with the set { 0, 1, 2, .... , row_set_length }
				for (int i = 0; i &lt; rowSetLength; ++i) {
					var cell = GetValue(rowSet[i]);
					newSet.InsertSort(cell, i, comparer);
				}
			}

			return newSet;
		}

		public IEnumerable&lt;int&gt; SelectRange(IndexRange range) {
			return SelectRange(new[] {range});
		}

		public abstract IEnumerable&lt;int&gt; SelectRange(IndexRange[] ranges);

		public virtual IEnumerable&lt;int&gt; SelectAll() {
			return SelectRange(new IndexRange(
					 RangeFieldOffset.FirstValue, IndexRange.FirstInSet,
					 RangeFieldOffset.LastValue, IndexRange.LastInSet));
		}

		public virtual IEnumerable&lt;int&gt; SelectFirst() {
			// NOTE: This will find NULL at start which is probably wrong.  The
			//   first value should be the first non null value.
			return SelectRange(new IndexRange(
					 RangeFieldOffset.FirstValue, IndexRange.FirstInSet,
					 RangeFieldOffset.LastValue, IndexRange.FirstInSet));
		}

		public IEnumerable&lt;int&gt; SelectNotFirst() {
			// NOTE: This will find NULL at start which is probably wrong.  The
			//   first value should be the first non null value.
			return SelectRange(new IndexRange(
					 RangeFieldOffset.AfterLastValue, IndexRange.FirstInSet,
					 RangeFieldOffset.LastValue, IndexRange.LastInSet));
		}

		public IEnumerable&lt;int&gt; SelectLast() {
			return SelectRange(new IndexRange(
					 RangeFieldOffset.FirstValue, IndexRange.LastInSet,
					 RangeFieldOffset.LastValue, IndexRange.LastInSet));
		}

		public IEnumerable&lt;int&gt; SelectNotLast() {
			return SelectRange(new IndexRange(
					 RangeFieldOffset.FirstValue, IndexRange.FirstInSet,
					 RangeFieldOffset.BeforeFirstValue, IndexRange.LastInSet));
		}

		///&lt;summary&gt;
		/// Selects all values in the column that are not null.
		///&lt;/summary&gt;
		///&lt;returns&gt;&lt;/returns&gt;
		public IEnumerable&lt;int&gt; SelectAllNonNull() {
			return SelectRange(new IndexRange(
						 RangeFieldOffset.AfterLastValue, DataObject.Null(),
						 RangeFieldOffset.LastValue, IndexRange.LastInSet));
		}

		public IEnumerable&lt;int&gt; SelectEqual(DataObject ob) {
			if (ob.IsNull)
				return new List&lt;int&gt;(0);

			return SelectRange(new IndexRange(
								 RangeFieldOffset.FirstValue, ob,
								 RangeFieldOffset.LastValue, ob));
		}

		public IEnumerable&lt;int&gt; SelectNotEqual(DataObject ob) {
			if (ob.IsNull) {
				return new List&lt;int&gt;(0);
			}
			return SelectRange(new IndexRange[]
			                   	{
			                   		new IndexRange(
			                   			RangeFieldOffset.AfterLastValue, DataObject.Null(),
			                   			RangeFieldOffset.BeforeFirstValue, ob)
			                   		, new IndexRange(
			                   		  	RangeFieldOffset.AfterLastValue, ob,
			                   		  	RangeFieldOffset.LastValue, IndexRange.LastInSet)
			                   	});
		}

		public IEnumerable&lt;int&gt; SelectGreater(DataObject ob) {
			if (ob.IsNull)
				return new List&lt;int&gt;(0);

			return SelectRange(new IndexRange(
					   RangeFieldOffset.AfterLastValue, ob,
					   RangeFieldOffset.LastValue, IndexRange.LastInSet));
		}

		public IEnumerable&lt;int&gt; SelectLess(DataObject ob) {
			if (ob.IsNull)
				return new List&lt;int&gt;(0);

			return SelectRange(new IndexRange(
					   RangeFieldOffset.AfterLastValue, DataObject.Null(),
					   RangeFieldOffset.BeforeFirstValue, ob));
		}

		public IEnumerable&lt;int&gt; SelectGreaterOrEqual(DataObject ob) {
			if (ob.IsNull)
				return new List&lt;int&gt;(0);

			return SelectRange(new IndexRange(
					   RangeFieldOffset.FirstValue, ob,
					   RangeFieldOffset.LastValue, IndexRange.LastInSet));
		}

		public IEnumerable&lt;int&gt; SelectLessOrEqual(DataObject ob) {
			if (ob.IsNull)
				return new List&lt;int&gt;(0);

			return SelectRange(new IndexRange(
					   RangeFieldOffset.AfterLastValue, DataObject.Null(),
					   RangeFieldOffset.LastValue, ob));
		}

		public IEnumerable&lt;int&gt; SelectBetween(DataObject ob1, DataObject ob2) {
			if (ob1.IsNull || ob2.IsNull)
				return new List&lt;int&gt;(0);

			return SelectRange(new IndexRange(
					   RangeFieldOffset.FirstValue, ob1,
					   RangeFieldOffset.BeforeFirstValue, ob2));
		}

		public IEnumerable&lt;int&gt; SelectLike(DataObject value) {
			if (value.IsNull)
				return new List&lt;int&gt;(0);

			if (!HandlesTextSearch)
				return SelectEqual(value);

			return SearchText(value);
		}

		protected virtual IEnumerable&lt;int&gt; SearchText(DataObject value) {
			throw new NotSupportedException(&quot;The column index does not support text search.&quot;);
		}

		public virtual ColumnIndex GetSubset(ITable subsetTable, int subsetColumn) {
			if (subsetTable == null)
				throw new ArgumentNullException(&quot;subsetTable&quot;);

			// Resolve table rows in this table scheme domain.
			List&lt;int&gt; rowSet = new List&lt;int&gt;(subsetTable.RowCount);
			var e = subsetTable.GetEnumerator();
			while (e.MoveNext()) {
				rowSet.Add(e.Current.RowId.RowNumber);
			}

			var rows = subsetTable.ResolveRows(subsetColumn, rowSet, Table);

			// Generates an IIndex which contains indices into &#39;rowSet&#39; in
			// sorted order.
			var newSet = Order(rows);

			// Our &#39;new_set&#39; should be the same size as &#39;rowSet&#39;
			if (newSet.Count != rowSet.Count) {
				throw new Exception(&quot;Internal sort error in finding sub-set.&quot;);
			}

			return CreateSubset(subsetTable, subsetColumn, newSet);
		}

		protected virtual ColumnIndex CreateSubset(ITable table, int column, IEnumerable&lt;int&gt; rows) {
			var index = new InsertSearchIndex(table, column, rows);
			index.RecordUid = false;
			return index;
		}

		#region IndexComparer

		private class IndexComparer : IIndexComparer&lt;int&gt; {
			private readonly ColumnIndex scheme;
			private readonly IEnumerable&lt;int&gt; rowSet;

			public IndexComparer(ColumnIndex scheme, IEnumerable&lt;int&gt; rowSet) {
				this.scheme = scheme;
				this.rowSet = rowSet;
			}

			public int CompareValue(int index, DataObject val) {
				var cell = scheme.GetValue(rowSet.ElementAt((int)index));
				return cell.CompareTo(val);
			}

			public int Compare(int index1, int index2) {
				throw new NotSupportedException(&quot;Shouldn&#39;t be called!&quot;);
			}
		}

		#endregion

		#region SubsetIndexComparer

		private class SubsetIndexComparer : IIndexComparer&lt;int&gt; {
			private readonly DataObject[] subsetList;

			public SubsetIndexComparer(DataObject[] subsetList) {
				this.subsetList = subsetList;
			}

			public int CompareValue(int index, DataObject val) {
				var cell = subsetList[index];
				return cell.CompareTo(val);
			}

			public int Compare(int index1, int index2) {
				throw new NotSupportedException(&quot;Shouldn&#39;t be called!&quot;);
			}
		}

		#endregion
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[54,10,54,23,0],[92,4,92,39,0],[94,4,94,31,0],[99,5,99,57,0],[100,26,100,32,0],[100,14,100,22,0],[101,6,101,36,0],[100,23,100,25,0],[105,5,105,66,0],[108,10,108,20,0],[109,6,109,31,0],[110,6,110,43,0],[108,39,108,42,0],[108,21,108,37,0],[117,5,117,52,0],[120,10,120,20,0],[121,6,121,37,0],[122,6,122,43,0],[120,39,120,42,0],[120,21,120,37,0],[126,4,126,18,0],[136,4,138,58,0],[144,4,146,59,0],[152,4,154,58,0],[158,4,160,58,0],[164,4,166,65,0],[174,4,176,59,0],[181,5,181,29,0],[189,4,189,18,0],[190,5,190,29,0],[192,4,200,27,0],[205,5,205,29,0],[213,4,213,18,0],[214,5,214,29,0],[216,4,218,49,0],[222,4,222,18,0],[223,5,223,29,0],[225,4,227,60,0],[231,4,231,18,0],[232,5,232,29,0],[234,4,236,42,0],[240,4,240,33,0],[241,5,241,29,0],[243,4,245,50,0],[249,4,249,21,0],[250,5,250,29,0],[252,4,252,27,0],[253,5,253,31,0],[255,4,255,29,0],[259,4,259,86,0],[264,5,264,52,0],[281,5,281,68,0],[299,4,299,69,0],[300,5,300,26,0],[301,5,301,26,0],[302,4,302,5,0],[305,5,305,62,0],[306,5,306,32,0],[310,5,310,61,0],[321,4,321,55,0],[322,5,322,34,0],[323,4,323,5,0],[326,5,326,34,0],[327,5,327,32,0],[331,5,331,61,0],[28,3,28,56,1],[29,4,29,32,1],[30,4,30,18,1],[31,3,31,4,1],[34,4,34,19,1],[35,3,35,4,1],[38,4,38,38,1],[39,4,39,32,1],[40,4,40,36,1],[41,4,41,19,1],[42,4,42,30,1],[43,3,43,4,1],[50,10,50,23,1],[60,4,60,45,1],[66,4,66,18,1],[67,4,67,30,1],[68,3,68,4,1],[71,3,71,4,1],[78,4,78,31,1],[81,4,81,36,1],[85,4,85,26,1],[86,5,86,22,1],[87,4,87,26,1],[88,5,88,20,1],[130,4,130,38,1],[180,4,180,18,1],[183,4,185,43,1],[204,4,204,18,1],[207,4,209,60,1],[263,4,263,28,1],[267,4,267,59,1],[268,4,268,40,1],[270,5,270,43,1],[269,4,269,24,1],[273,4,273,68,1],[277,4,277,29,1],[280,4,280,37,1],[284,4,284,59,1],[288,4,288,59,1],[289,4,289,28,1],[290,4,290,17,1]]);
    </script>
  </body>
</html>