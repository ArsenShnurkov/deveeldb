<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.store\inmemorystore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.IO;

namespace Deveel.Data.Store {
	/// &lt;summary&gt;
	/// An implementation of &lt;see cref=&quot;IStore&quot;/&gt; that persists
	/// data in the application memory.
	/// &lt;/summary&gt;
	public class InMemoryStore : IStore {
		private InMemoryBlock fixedAreaBlock;
		private InMemoryBlock[] areaMap;
		private long uniqueIdKey;

		internal InMemoryStore(string name, int hashSize) {
			Name = name;
			areaMap = new InMemoryBlock[hashSize];
			uniqueIdKey = 0;
		}

		~InMemoryStore() {
			Dispose(false);
		}

		/// &lt;summary&gt;
		/// Gets the unique name of the store within the application.
		/// &lt;/summary&gt;
		public string Name { get; private set; }

		private InMemoryBlock FixedAreaBlock {
			get {
				lock (this) {
					if (fixedAreaBlock == null)
						fixedAreaBlock = new InMemoryBlock(-1, 64);

					return fixedAreaBlock;
				}
			}
		}

		private void Dispose(bool disposing) {
			if (disposing) {
				fixedAreaBlock = null;
				areaMap = null;
			}
		}

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		private InMemoryBlock GetBlock(long pointer) {
			if (pointer == -1)
				return FixedAreaBlock;

			return GetAreaBlock(pointer);
		}

		private InMemoryBlock GetAreaBlock(long pointer) {
			lock (this) {
				// Find the pointer in the hash
				var hashPos = (int)(pointer % areaMap.Length);
				InMemoryBlock prev = null;
				var block = areaMap[hashPos];

				// Search for this pointer
				while (block != null &amp;&amp; block.Id != pointer) {
					prev = block;
					block = block.Next;
				}

				if (block == null)
					throw new IOException(&quot;Pointer &quot; + pointer + &quot; is invalid.&quot;);

				// Move the element to the start of the list.
				if (prev != null) {
					prev.Next = block.Next;
					block.Next = areaMap[hashPos];
					areaMap[hashPos] = block;
				}

				return block;
			}
		}

		/// &lt;inheritdoc/&gt;
		public IArea CreateArea(long size) {
			if (size &gt; Int32.MaxValue)
				throw new IOException(&quot;&#39;size&#39; is too large.&quot;);

			lock (this) {
				// Generate a unique id for this area.
				long id = uniqueIdKey;
				++uniqueIdKey;

				// Create the element.
				var element = new InMemoryBlock(id, (int)size);

				// The position in the hash map
				int hashPos = (int)(id % areaMap.Length);

				// Add to the chain
				element.Next = areaMap[hashPos];
				areaMap[hashPos] = element;

				return element.GetArea(false);
			}
		}

		/// &lt;inheritdoc/&gt;
		public void DeleteArea(long id) {
			lock (this) {
				// Find the pointer in the hash
				var hashPos = (int)(id % areaMap.Length);
				InMemoryBlock prev = null;
				InMemoryBlock block = areaMap[hashPos];

				// Search for this pointer
				while (block != null &amp;&amp; block.Id != id) {
					prev = block;
					block = block.Next;
				}

				// If not found
				if (block == null)
					throw new IOException(&quot;Area ID &quot; + id + &quot; is invalid.&quot;);

				// Remove
				if (prev == null) {
					areaMap[hashPos] = block.Next;
				} else {
					prev.Next = block.Next;
				}

				// Garbage collector should do the rest...
			}
		}

		/// &lt;inheritdoc/&gt;
		public IArea GetArea(long id, bool readOnly) {
			return GetBlock(id).GetArea(readOnly);
		}

		/// &lt;inheritdoc/&gt;
		public void LockForWrite() {
		}

		/// &lt;inheritdoc/&gt;
		public void UnlockForWrite() {
		}

		/// &lt;inheritdoc/&gt;
		public void CheckPoint() {
		}

		/// &lt;inheritdoc/&gt;
		public bool ClosedClean {
			get { return true; }
		}

		/// &lt;inheritdoc/&gt;
		public IEnumerable&lt;long&gt; GetAllAreas() {
			throw new NotImplementedException();
		}

		#region InMemoryBlock

		class InMemoryBlock {
			private readonly byte[] block;

			public InMemoryBlock(long id, int size) {
				Id = id;
				block = new byte[size];
			}

			public long Id { get; private set; }

			public InMemoryBlock Next { get; set; }

			public IArea GetArea(bool readOnly) {
				return new InMemoryArea(Id, readOnly, block, 0, block.Length);
			}
		}

		#endregion

		#region InMemoryArea

		class InMemoryArea : IArea {
			private readonly byte[] data;
			private int position;
			private readonly int startPosition;
			private readonly int endPosition;

			public InMemoryArea(long id, bool readOnly, byte[] data, int offset, int length) {
				this.data = data;
				Length = length;

				position = startPosition = offset;
				endPosition = offset + length;

				Id = id;
				IsReadOnly = readOnly;
			}

			public long Id { get; private set; }

			public bool IsReadOnly { get; private set; }

			public int Position {
				get { return position; }
				set {
					int actPosition = startPosition + value;
					if (actPosition &lt; 0 || actPosition &gt;= endPosition)
						throw new IOException(&quot;Moved position out of bounds.&quot;);

					position = actPosition;
				}
			}

			public int Capacity {
				get { return endPosition - startPosition; }
			}

			public int Length { get; private set; }

			private int CheckPositionBounds(int diff) {
				int newPos = position + diff;
				if (newPos &gt; endPosition) {
					throw new IOException(&quot;Position out of bounds. &quot; +
										  &quot; start=&quot; + startPosition +
										  &quot; end=&quot; + endPosition +
										  &quot; pos=&quot; + position +
										  &quot; newPos=&quot; + newPos);
				}

				int oldPos = position;
				position = newPos;
				return oldPos;
			}

			public void CopyTo(IArea destArea, int size) {
				const int bufferSize = 2048;
				byte[] buf = new byte[bufferSize];
				int toCopy = System.Math.Min(size, bufferSize);

				while (toCopy &gt; 0) {
					Read(buf, 0, toCopy);
					destArea.Write(buf, 0, toCopy);
					size -= toCopy;
					toCopy = System.Math.Min(size, bufferSize);
				}
			}

			public int Read(byte[] buffer, int offset, int length) {
				Array.Copy(data, CheckPositionBounds(length), buffer, offset, length);
				return length;
			}

			public void Write(byte[] buffer, int offset, int length) {
				Array.Copy(buffer, offset, data, CheckPositionBounds(length), length);
			}

			public void Flush() {
			}
		}

		#endregion
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[59,5,59,27,0],[60,5,60,20,0],[65,4,65,18,0],[66,4,66,30,0],[67,3,67,4,0],[85,6,85,19,0],[86,6,86,25,0],[90,6,90,67,0],[94,6,94,29,0],[95,6,95,36,0],[96,6,96,31,0],[106,5,106,51,0],[137,6,137,19,0],[138,6,138,25,0],[143,6,143,62,0],[149,6,149,29,0],[171,3,171,4,0],[180,4,180,40,0],[232,7,232,62,0],[239,11,239,46,0],[247,6,251,34,0],[261,5,261,39,0],[262,5,262,52,0],[265,6,265,27,0],[266,6,266,37,0],[267,6,267,21,0],[268,6,268,49,0],[264,5,264,23,0],[270,4,270,5,0],[31,3,31,52,1],[32,4,32,16,1],[33,4,33,42,1],[34,4,34,20,1],[35,3,35,4,1],[38,4,38,19,1],[39,3,39,4,1],[48,5,48,16,1],[49,6,49,33,1],[50,7,50,50,1],[52,6,52,28,1],[54,4,54,5,1],[58,4,58,18,1],[62,3,62,4,1],[70,4,70,22,1],[71,5,71,27,1],[73,4,73,33,1],[77,4,77,15,1],[79,5,79,51,1],[80,5,80,31,1],[81,5,81,34,1],[84,5,84,49,1],[89,5,89,23,1],[93,5,93,22,1],[99,5,99,18,1],[101,3,101,4,1],[105,4,105,30,1],[108,4,108,15,1],[110,5,110,27,1],[111,5,111,19,1],[114,5,114,52,1],[117,5,117,46,1],[120,5,120,37,1],[121,5,121,32,1],[123,5,123,35,1],[125,3,125,4,1],[129,4,129,15,1],[131,5,131,46,1],[132,5,132,31,1],[133,5,133,44,1],[136,5,136,44,1],[142,5,142,23,1],[146,5,146,22,1],[147,6,147,36,1],[154,3,154,4,1],[158,4,158,42,1],[163,3,163,4,1],[167,3,167,4,1],[175,10,175,22,1],[188,4,188,43,1],[189,5,189,13,1],[190,5,190,28,1],[191,4,191,5,1],[198,5,198,67,1],[212,4,212,84,1],[213,5,213,22,1],[214,5,214,21,1],[216,5,216,39,1],[217,5,217,35,1],[219,5,219,13,1],[220,5,220,27,1],[221,4,221,5,1],[228,11,228,27,1],[230,6,230,46,1],[231,6,231,56,1],[234,6,234,29,1],[235,5,235,6,1],[245,5,245,34,1],[246,5,246,30,1],[254,5,254,27,1],[255,5,255,23,1],[256,5,256,19,1],[273,5,273,75,1],[274,5,274,19,1],[278,5,278,75,1],[279,4,279,5,1],[282,4,282,5,1]]);
    </script>
  </body>
</html>