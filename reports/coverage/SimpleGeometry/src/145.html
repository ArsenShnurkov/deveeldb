<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.compile\expressionbuilder.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.Linq;

using Deveel.Data.Sql.Expressions;
using Deveel.Data.Sql.Objects;

namespace Deveel.Data.Sql.Compile {
	class ExpressionBuilder : SqlNodeVisitor {
		private SqlExpression outputExpression;

		public SqlExpression Build(ISqlNode node) {
			Visit(node);
			return outputExpression;
		}

		public override void VisitVariableRefExpression(SqlVariableRefExpressionNode node) {
			outputExpression = SqlExpression.VariableReference(node.Variable);
		}

		public override void VisitTupleExpression(SqlExpressionTupleNode node) {
			outputExpression = SqlExpression.Tuple(node.Expressions.Select(Build).ToArray());
		}


		public override void VisitQueryExpression(SqlQueryExpressionNode node) {
			var selectColumns = GetSelectColumns(node);
			var exp = new SqlQueryExpression(selectColumns);

			if (node.FromClause != null) {
				SetFromClause(exp.FromClause, node.FromClause);
			}

			if (node.WhereExpression != null) {
				exp.WhereExpression = Build(node.WhereExpression);
			}

			if (node.GroupBy != null) {
				var groupBy = new List&lt;SqlExpression&gt;();
				if (node.GroupBy.GroupExpressions != null)
					groupBy.AddRange(node.GroupBy.GroupExpressions.Select(Build));

				exp.GroupBy = groupBy.ToList();

				var having = node.GroupBy.HavingExpression;
				if (having != null)
					exp.HavingExpression = Build(having);

			}

			if (node.Composite != null) {
				var compositeExp = Build(node.Composite.QueryExpression);
				exp.NextComposite = compositeExp as SqlQueryExpression;
				exp.IsCompositeAll = node.Composite.IsAll;
				exp.CompositeFunction = GetCompositeFunction(node.Composite.CompositeFunction);
			}

			outputExpression = exp;
		}

		private static CompositeFunction GetCompositeFunction(string s) {
			if (String.Equals(s, &quot;UNION&quot;, StringComparison.OrdinalIgnoreCase))
				return CompositeFunction.Union;
			if (String.Equals(s, &quot;EXCEPT&quot;, StringComparison.OrdinalIgnoreCase))
				return CompositeFunction.Except;
			if (String.Equals(s, &quot;INTERSECT&quot;, StringComparison.OrdinalIgnoreCase))
				return CompositeFunction.Intersect;
			
			throw new InvalidOperationException(String.Format(&quot;Composite function {0} is invalid.&quot;, s));
		}

		private void SetFromTableInClause(FromClause clause, IFromSourceNode source, JoinNode join) {
			AddSourceToClause(clause, source);

			if (join != null) {
				var joinType = JoinType.Inner;
				if (!String.IsNullOrEmpty(join.JoinType))
					joinType = GetJoinType(join.JoinType);

				SqlExpression onExpression = null;
				if (join.OnExpression != null)
					onExpression = Build(join.OnExpression);

				clause.Join(joinType, onExpression);

				SetFromTableInClause(clause, join.Source, join.NextJoin);
			}
		}

		private void AddSourceToClause(FromClause clause, IFromSourceNode source) {
			string alias = null;
			if (source.Alias != null)
				alias = source.Alias.Text;

			if (source is FromTableSourceNode) {
				var tableSource = (FromTableSourceNode)source;
				clause.AddTable(alias, tableSource.TableName.Name.FullName);
			} else if (source is FromQuerySourceNode) {
				var querySource = (FromQuerySourceNode)source;
				var queryExpression = (SqlQueryExpression) Build(querySource.Query);
				clause.AddSubQuery(alias, queryExpression);
			}
		}

		private JoinType GetJoinType(string typeName) {
			if (String.Equals(typeName, &quot;INNER&quot;, StringComparison.OrdinalIgnoreCase) ||
				String.Equals(typeName, &quot;INNER JOIN&quot;, StringComparison.OrdinalIgnoreCase) ||
			    String.Equals(typeName, &quot;,&quot;, StringComparison.InvariantCulture))
				return JoinType.Inner;
			if (String.Equals(typeName, &quot;LEFT OUTER&quot;, StringComparison.OrdinalIgnoreCase) ||
				String.Equals(typeName, &quot;LFT OUTER JOIN&quot;, StringComparison.OrdinalIgnoreCase) ||
			    String.Equals(typeName, &quot;LEFT&quot;, StringComparison.OrdinalIgnoreCase) ||
				String.Equals(typeName, &quot;LFT JOIN&quot;, StringComparison.OrdinalIgnoreCase))
				return JoinType.Left;
			if (String.Equals(typeName, &quot;RIGHT OUTER&quot;, StringComparison.OrdinalIgnoreCase) ||
				String.Equals(typeName, &quot;RIGHT OUTER JOIN&quot;, StringComparison.OrdinalIgnoreCase) ||
			    String.Equals(typeName, &quot;RIGHT&quot;, StringComparison.OrdinalIgnoreCase) ||
				String.Equals(typeName, &quot;RIGHT JOIN&quot;, StringComparison.OrdinalIgnoreCase))
				return JoinType.Right;

			return JoinType.None;
		}

		private void SetFromClause(FromClause clause, FromClauseNode node) {
			SetFromTableInClause(clause, node.Source, node.Join);
		}

		private IEnumerable&lt;SelectColumn&gt; GetSelectColumns(SqlQueryExpressionNode node) {
			if (node.IsAll) {
				return new[] {new SelectColumn(SqlExpression.Reference(new ObjectName(&quot;*&quot;)))};
			}

			var items = new List&lt;SelectColumn&gt;();
			foreach (var item in node.SelectItems) {
				SqlExpression exp;
				if (item.Name != null) {
					exp = SqlExpression.Reference(item.Name.Name);
				} else if (item.Expression != null) {
					exp = Build(item.Expression);
				} else {
					throw new InvalidOperationException();
				}

				string alias = null;
				if (item.Alias != null)
					alias = item.Alias.Text;

				items.Add(new SelectColumn(exp, alias));
			}

			return items.AsReadOnly();
		}

		public override void VisitCaseExpression(SqlCaseExpressionNode expressionNode) {
			throw new NotImplementedException();
		}

		public override void VisitConstantExpression(SqlConstantExpressionNode expressionNode) {
			var sqlValue = expressionNode.Value;
			DataObject obj;
			if (sqlValue is SqlString) {
				obj = DataObject.VarChar((SqlString) sqlValue);
			} else if (sqlValue is SqlBoolean) {
				obj = DataObject.Boolean((SqlBoolean) sqlValue);
			} else if (sqlValue is SqlNumber) {
				obj = DataObject.Number((SqlNumber) sqlValue);
			} else {
				throw new NotSupportedException(&quot;Constant value is not supported.&quot;);
			}

			outputExpression = SqlExpression.Constant(obj);
		}

		public override void VisitReferenceExpression(SqlReferenceExpressionNode node) {
			outputExpression = SqlExpression.Reference(node.Reference.Name);
		}

		public override void VisitFunctionCall(SqlFunctionCallExpressionNode node) {
			var args = new List&lt;SqlExpression&gt;();
			if (node.Arguments != null)
				args.AddRange(node.Arguments.Select(Build));

			outputExpression = SqlExpression.FunctionCall(node.FunctionName, args.ToArray());
		}

		public override void VisitBetweenExpression(SqlBetweenExpressionNode expressionNode) {
			var testExp = Build(expressionNode.Expression);
			var minValue = Build(expressionNode.MinValue);
			var maxValue = Build(expressionNode.MaxValue);

			var smallerExp = SqlExpression.SmallerOrEqualThan(testExp, maxValue);
			var greaterExp = SqlExpression.GreaterOrEqualThan(testExp, minValue);

			outputExpression = SqlExpression.And(smallerExp, greaterExp);
		}

		public override void VisitBinaryExpression(SqlBinaryExpressionNode expressionNode) {
			var left = Build(expressionNode.Left);
			var right = Build(expressionNode.Right);
			var op = expressionNode.Operator;

			var expType = GetBinaryExpressionType(op);

			outputExpression = SqlExpression.Binary(left, expType, right);
		}

		private SqlExpressionType GetBinaryExpressionType(string op) {
			if (op == &quot;+&quot; ||
			    op == &quot;||&quot;)
				return SqlExpressionType.Add;
			if (op == &quot;-&quot;)
				return SqlExpressionType.Subtract;
			if (op == &quot;*&quot;)
				return SqlExpressionType.Multiply;
			if (op == &quot;/&quot;)
				return SqlExpressionType.Divide;
			if (op == &quot;%&quot; ||
			    String.Equals(op, &quot;MOD&quot;, StringComparison.OrdinalIgnoreCase))
				return SqlExpressionType.Modulo;
			if (op == &quot;=&quot;)
				return SqlExpressionType.Equal;
			if (op == &quot;&lt;&gt;&quot;)
				return SqlExpressionType.NotEqual;
			if (op == &quot;&gt;&quot;)
				return SqlExpressionType.GreaterThan;
			if (op == &quot;&gt;=&quot;)
				return SqlExpressionType.GreaterOrEqualThan;
			if (op == &quot;&lt;&quot;)
				return SqlExpressionType.SmallerThan;
			if (op == &quot;&lt;=&quot;)
				return SqlExpressionType.SmallerOrEqualThan;
			if (String.Equals(op, &quot;LIKE&quot;, StringComparison.OrdinalIgnoreCase))
				return SqlExpressionType.Like;
			if (String.Equals(op, &quot;NOT LIKE&quot;, StringComparison.OrdinalIgnoreCase))
				return SqlExpressionType.NotLike;

			if (String.Equals(op, &quot;IS&quot;, StringComparison.OrdinalIgnoreCase))
				return SqlExpressionType.Is;
			if (String.Equals(op, &quot;IS NOT&quot;, StringComparison.OrdinalIgnoreCase))
				return SqlExpressionType.IsNot;

			if (String.Equals(op, &quot;AND&quot;, StringComparison.OrdinalIgnoreCase))
				return SqlExpressionType.And;
			if (String.Equals(op, &quot;OR&quot;, StringComparison.OrdinalIgnoreCase))
				return SqlExpressionType.Or;

			throw new ArgumentException(String.Format(&quot;The operator {0} is not a binary one.&quot;, op));
		}

		public override void VisitUnaryExpression(SqlUnaryExpressionNode expressionNode) {
			var expressionType = GetUnaryExpressionType(expressionNode.Operator);
			var operand = Build(expressionNode.Operand);

			outputExpression = SqlExpression.Unary(expressionType, operand);
		}

		private SqlExpressionType GetUnaryExpressionType(string op) {
			if (op == &quot;+&quot;)
				return SqlExpressionType.UnaryPlus;
			if (op == &quot;-&quot;)
				return SqlExpressionType.Negate;
			if (String.Equals(op, &quot;NOT&quot;, StringComparison.OrdinalIgnoreCase))
				return SqlExpressionType.Not;

			throw new ArgumentException(String.Format(&quot;The operator {0} is not a unary one.&quot;, op));
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[34,4,34,70,0],[35,3,35,4,0],[63,6,63,43,0],[68,5,68,62,0],[69,5,69,60,0],[70,5,70,47,0],[71,5,71,84,0],[78,4,78,70,0],[79,5,79,36,0],[80,4,80,71,0],[81,5,81,37,0],[82,4,82,74,0],[83,5,83,40,0],[85,4,85,96,0],[126,4,129,77,0],[130,5,130,26,0],[131,4,134,79,0],[135,5,135,27,0],[137,4,137,25,0],[153,6,153,52,0],[157,6,157,44,0],[171,4,171,40,0],[178,5,178,52,0],[180,5,180,53,0],[184,5,184,73,0],[203,4,203,51,0],[204,4,204,50,0],[205,4,205,50,0],[207,4,207,73,0],[208,4,208,73,0],[210,4,210,65,0],[211,3,211,4,0],[232,5,232,37,0],[235,5,235,37,0],[239,5,239,39,0],[242,4,242,19,0],[243,5,243,49,0],[244,4,244,18,0],[245,5,245,42,0],[246,4,246,19,0],[247,5,247,49,0],[248,4,248,70,0],[249,5,249,35,0],[250,4,250,74,0],[251,5,251,38,0],[253,4,253,68,0],[254,5,254,33,0],[255,4,255,72,0],[256,5,256,36,0],[258,4,258,69,0],[259,5,259,34,0],[260,4,260,68,0],[261,5,261,33,0],[263,4,263,92,0],[267,4,267,73,0],[268,4,268,48,0],[270,4,270,68,0],[271,3,271,4,0],[274,4,274,18,0],[275,5,275,40,0],[276,4,276,18,0],[277,5,277,37,0],[278,4,278,69,0],[279,5,279,34,0],[281,4,281,91,0],[29,4,29,16,1],[30,4,30,28,1],[38,4,38,85,1],[39,3,39,4,1],[43,4,43,47,1],[44,4,44,52,1],[46,4,46,32,1],[47,5,47,52,1],[50,4,50,37,1],[51,5,51,55,1],[54,4,54,29,1],[55,5,55,45,1],[56,5,56,47,1],[57,6,57,68,1],[59,5,59,36,1],[61,5,61,48,1],[62,5,62,24,1],[67,4,67,31,1],[74,4,74,27,1],[75,3,75,4,1],[89,4,89,38,1],[91,4,91,21,1],[92,5,92,35,1],[93,5,93,46,1],[94,6,94,44,1],[96,5,96,39,1],[97,5,97,35,1],[98,6,98,46,1],[100,5,100,41,1],[102,5,102,62,1],[104,3,104,4,1],[107,4,107,24,1],[108,4,108,29,1],[109,5,109,31,1],[111,4,111,38,1],[112,5,112,51,1],[113,5,113,65,1],[114,11,114,45,1],[115,5,115,51,1],[116,5,116,73,1],[117,5,117,48,1],[119,3,119,4,1],[122,4,124,72,1],[125,5,125,27,1],[141,4,141,57,1],[142,3,142,4,1],[145,4,145,19,1],[146,5,146,83,1],[149,4,149,41,1],[150,25,150,41,1],[150,13,150,21,1],[152,5,152,27,1],[154,12,154,40,1],[155,6,155,35,1],[160,5,160,25,1],[161,5,161,28,1],[162,6,162,30,1],[164,5,164,45,1],[150,22,150,24,1],[167,4,167,30,1],[175,4,175,40,1],[177,4,177,30,1],[179,11,179,38,1],[181,11,181,37,1],[182,5,182,51,1],[187,4,187,51,1],[188,3,188,4,1],[191,4,191,68,1],[192,3,192,4,1],[195,4,195,41,1],[196,4,196,31,1],[197,5,197,49,1],[199,4,199,85,1],[200,3,200,4,1],[214,4,214,42,1],[215,4,215,44,1],[216,4,216,37,1],[218,4,218,46,1],[220,4,220,66,1],[221,3,221,4,1],[224,4,225,19,1],[226,5,226,34,1],[227,4,227,18,1],[228,5,228,39,1],[229,4,229,18,1],[230,5,230,39,1],[231,4,231,18,1],[233,4,234,69,1],[236,4,236,18,1],[237,5,237,36,1],[238,4,238,19,1],[240,4,240,18,1],[241,5,241,42,1]]);
    </script>
  </body>
</html>