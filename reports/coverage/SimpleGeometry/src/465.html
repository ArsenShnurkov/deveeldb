<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.transactions\transactionwork.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;

using Deveel.Data.DbSystem;
using Deveel.Data.Index;
using Deveel.Data.Sql;

namespace Deveel.Data.Transactions {
	class TransactionWork {
		internal TableSourceComposite Composite { get; private set; }

		internal Transaction Transaction { get; private set; }

		public IEnumerable&lt;TableSource&gt; SelectedFromTables { get; private set; }

		internal TransactionWork(TableSourceComposite composite, Transaction transaction, IEnumerable&lt;TableSource&gt; selectedFromTables, IEnumerable&lt;IMutableTable&gt; touchedTables, TransactionRegistry journal) {
			Composite = composite;
			Transaction = transaction;
			SelectedFromTables = selectedFromTables;

			// Get individual journals for updates made to tables in this
			// transaction.
			// The list TableEventRegistry

			ChangedTables = touchedTables.Select(t =&gt; t.EventRegistry).Where(tableJournal =&gt; tableJournal.EventCount &gt; 0);

			// The list of tables created by this journal.
			CreatedTables = journal.TablesCreated;
			// Ths list of tables dropped by this journal.
			DroppedTables = journal.TablesDropped;
			// The list of tables that constraints were alter by this journal
			ConstraintAlteredTables = journal.TablesConstraintAltered;

			// Get the list of all database objects that were created in the
			// transaction.
			ObjectsCreated = transaction.Registry.ObjectsCreated;
			// Get the list of all database objects that were dropped in the
			// transaction.
			ObjectsDropped = transaction.Registry.ObjectsDropped;

			CommitId = transaction.CommitId;
		}

		public IEnumerable&lt;int&gt; CreatedTables { get; private set; }

		public IEnumerable&lt;int&gt; DroppedTables { get; private set; }

		public IEnumerable&lt;int&gt; ConstraintAlteredTables { get; private set; }

		public IEnumerable&lt;TableEventRegistry&gt; ChangedTables { get; private set; }

		public IEnumerable&lt;ObjectName&gt; ObjectsCreated { get; private set; }

		public IEnumerable&lt;ObjectName&gt; ObjectsDropped { get; private set; }

		public bool Done { get; private set; }

		public long CommitId { get; private set; }

		public bool HasChanges {
			get { return CreatedTables.Any() || DroppedTables.Any() || ConstraintAlteredTables.Any() || ChangedTables.Any(); }
		}

		/// &lt;summary&gt;
		/// Returns true if the given List of &lt;see cref=&quot;CommitTableInfo&quot;/&gt; objects 
		/// contains an entry for the given master table.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;list&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;master&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		private static bool CommitTableListContains(IEnumerable&lt;CommitTableInfo&gt; list, TableSource master) {
			return list.Any(info =&gt; info.Master.Equals(master));
		}

		private void AssertNoDirtySelect() {
			// We only perform this check if transaction error on dirty selects
			// are enabled.
			if (Transaction.ErrorOnDirtySelect()) {
				// For each table that this transaction selected from, if there are
				// any committed changes then generate a transaction error.
				foreach (TableSource selectedTable in SelectedFromTables) {
					// Find all committed journals equal to or greater than this
					// transaction&#39;s commit_id.
					var journalsSince = selectedTable.FindChangesSinceCmmit(CommitId);
					if (journalsSince.Any()) {
						// Yes, there are changes so generate transaction error and
						// rollback.
						throw new TransactionException(
							TransactionErrorCodes.DirtySelect,
							&quot;Concurrent Serializable Transaction Conflict(4): &quot; +
							&quot;Select from table that has committed changes: &quot; +
							selectedTable.TableName);
					}
				}
			}
		}

		internal void CheckConflicts(IEnumerable&lt;TransactionObjectState&gt; namespaceJournals) {
			AssertNoDirtySelect();

			// Check there isn&#39;t a namespace clash with database objects.
			// We need to create a list of all create and drop activity in the
			// Composite from when the transaction started.
			var allDroppedObs = new List&lt;ObjectName&gt;();
			var allCreatedObs = new List&lt;ObjectName&gt;();
			foreach (var nsJournal in namespaceJournals) {
				if (nsJournal.CommitId &gt;= CommitId) {
					allDroppedObs.AddRange(nsJournal.DroppedObjects);
					allCreatedObs.AddRange(nsJournal.CreatedObjects);
				}
			}

			// The list of all dropped objects since this transaction
			// began.
			bool conflict5 = false;
			object conflictName = null;
			string conflictDesc = &quot;&quot;;
			foreach (ObjectName droppedOb in allDroppedObs) {
				if (ObjectsDropped.Contains(droppedOb)) {
					conflict5 = true;
					conflictName = droppedOb;
					conflictDesc = &quot;Drop Clash&quot;;
				}
			}
			// The list of all created objects since this transaction
			// began.
			foreach (ObjectName createdOb in allCreatedObs) {
				if (ObjectsCreated.Contains(createdOb)) {
					conflict5 = true;
					conflictName = createdOb;
					conflictDesc = &quot;Create Clash&quot;;
				}
			}
			if (conflict5) {
				// Namespace conflict...
				throw new TransactionException(
					TransactionErrorCodes.DuplicateTable,
					&quot;Concurrent Serializable Transaction Conflict(5): &quot; +
					&quot;Namespace conflict: &quot; + conflictName + &quot; &quot; +
					conflictDesc);
			}

			// For each journal,
			foreach (TableEventRegistry changeJournal in ChangedTables) {
				// The table the change was made to.
				int tableId = changeJournal.TableId;
				// Get the master table with this table id.
				TableSource master = Composite.GetTableSource(tableId);

				// True if the state contains a committed resource with the given name
				bool committedResource = Composite.ContainsVisibleResource(tableId);

				// Check this table is still in the committed tables list.
				if (!CreatedTables.Contains(tableId) &amp;&amp; !committedResource) {
					// This table is no longer a committed table, so rollback
					throw new TransactionException(
						TransactionErrorCodes.TableDropped,
						&quot;Concurrent Serializable Transaction Conflict(2): &quot; +
						&quot;Table altered/dropped: &quot; + master.TableName);
				}

				// Since this journal was created, check to see if any changes to the
				// tables have been committed since.
				// This will return all journals on the table with the same commit_id
				// or greater.
				var journalsSince = master.FindChangesSinceCmmit(CommitId);

				// For each journal, determine if there&#39;s any clashes.
				foreach (TableEventRegistry tableJournal in journalsSince) {
					// This will thrown an exception if a commit classes.
					changeJournal.TestCommitClash(master.TableInfo, tableJournal);
				}
			}

			// Look at the transaction journal, if a table is dropped that has
			// journal entries since the last commit then we have an exception
			// case.
			foreach (int tableId in DroppedTables) {
				// Get the master table with this table id.
				TableSource master = Composite.GetTableSource(tableId);
				// Any journal entries made to this dropped table?
				if (master.FindChangesSinceCmmit(CommitId).Any()) {
					// Oops, yes, rollback!
					throw new TransactionException(
						TransactionErrorCodes.TableRemoveClash,
						&quot;Concurrent Serializable Transaction Conflict(3): &quot; +
						&quot;Dropped table has modifications: &quot; + master.TableName);
				}
			}
		}

		private CommitTableInfo[] GetNormalizedChangedTables() {
			// Create a normalized list of TableSource of all tables that
			// were either changed (and not dropped), and created (and not dropped).
			// This list represents all tables that are either new or changed in
			// this transaction.

			var normalizedChangedTables = new List&lt;CommitTableInfo&gt;(8);

			// Add all tables that were changed and not dropped in this transaction.

			normalizedChangedTables.AddRange(
				ChangedTables.Select(tableJournal =&gt; new { tableJournal, tableId = tableJournal.TableId })
					.Where(t =&gt; !DroppedTables.Contains(t.tableId))
					.Select(t =&gt; new { t, masterTable = Composite.GetTableSource(t.tableId) })
					.Select(t =&gt; new CommitTableInfo {
						Master = t.masterTable,
						Journal = t.t.tableJournal,
						ChangesSinceCommit = t.masterTable.FindChangesSinceCmmit(CommitId).ToArray()
					}));

			// Add all tables that were created and not dropped in this transaction.
			foreach (var tableId in CreatedTables) {
				// If this table is not dropped in this transaction then this is a
				// new table in this transaction.
				if (!DroppedTables.Contains(tableId)) {
					TableSource masterTable = Composite.GetTableSource(tableId);
					if (!CommitTableListContains(normalizedChangedTables, masterTable)) {

						// This is for entries that are created but modified (no journal).
						var tableInfo = new CommitTableInfo {
							Master = masterTable
						};

						normalizedChangedTables.Add(tableInfo);
					}
				}
			}

			return normalizedChangedTables.ToArray();
		}

		private TableSource[] GetNormalizedDroppedTables() {
			// Create a normalized list of TableSource of all tables that
			// were dropped (and not created) in this transaction.  This list
			// represents tables that will be dropped if the transaction
			// successfully commits.

			var normalizedDroppedTables = new List&lt;TableSource&gt;(8);
			foreach (var tableId in DroppedTables) {
				// Was this dropped table also created?  If it was created in this
				// transaction then we don&#39;t care about it.
				if (!CreatedTables.Contains(tableId)) {
					TableSource masterTable = Composite.GetTableSource(tableId);
					normalizedDroppedTables.Add(masterTable);
				}
			}

			return normalizedDroppedTables.ToArray();
		}

		private ITable[] FindChangedTables(ITransaction checkTransaction, CommitTableInfo[] normalizedChangedTables) {
			var changedTableSource = new ITable[normalizedChangedTables.Length];

			// Set up the above arrays
			for (int i = 0; i &lt; normalizedChangedTables.Length; ++i) {
				// Get the information for this changed table
				CommitTableInfo tableInfo = normalizedChangedTables[i];

				// Get the master table that changed from the normalized list.
				TableSource master = tableInfo.Master;
				// Did this table change since the transaction started?
				TableEventRegistry[] allTableChanges = tableInfo.ChangesSinceCommit;

				if (allTableChanges == null || allTableChanges.Length == 0) {
					// No changes so we can pick the correct IIndexSet from the current
					// transaction.

					// Get the state of the changed tables from the Transaction
					var mtable = Transaction.GetMutableTable(master.TableName);
					// Get the current index set of the changed table
					tableInfo.IndexSet = Transaction.GetIndexSetForTable(master);
					// Flush all index changes in the table
					mtable.FlushIndexes();

					// Set the &#39;check_transaction&#39; object with the latest version of the
					// table.
					checkTransaction.UpdateVisibleTable(tableInfo.Master, tableInfo.IndexSet);
				} else {
					// There were changes so we need to merge the changes with the
					// current view of the table.

					// It&#39;s not immediately obvious how this merge update works, but
					// basically what happens is we WriteByte the table journal with all the
					// changes into a new IMutableTableDataSource of the current
					// committed state, and then we flush all the changes into the
					// index and then update the &#39;check_transaction&#39; with this change.

					// Create the IMutableTableDataSource with the changes from this
					// journal.
					var mtable = master.CreateTableAtCommit(checkTransaction, tableInfo.Journal);
					// Get the current index set of the changed table
					tableInfo.IndexSet = checkTransaction.GetIndexSetForTable(master);
					// Flush all index changes in the table
					mtable.FlushIndexes();

					// Dispose the table
					mtable.Dispose();
				}

				// And now refresh the &#39;changedTableSource&#39; entry
				changedTableSource[i] = checkTransaction.GetTable(master.TableName);
			}

			return changedTableSource;
		}

		private void FireChangeEvents(ITransaction checkTransaction, CommitTableInfo[] normalizedChangedTables, Action&lt;TableCommitInfo&gt; commitActions) {
			if (commitActions == null)
				return;

			foreach (var tableInfo in normalizedChangedTables) {
				// Get the journal that details the change to the table.
				TableEventRegistry changeJournal = tableInfo.Journal;
				if (changeJournal != null) {
					// Get the table name
					var tableName = tableInfo.Master.TableName;
					commitActions(new TableCommitInfo(checkTransaction.CommitId, tableName, tableInfo.NormalizedAddedRows,
						tableInfo.NormalizedAddedRows));
				}
			}
		}

		private void CheckConstraintViolations(ITransaction checkTransaction, CommitTableInfo[] normalizedChangedTables, ITable[] changedTableSource) {
			// Any tables that the constraints were altered for we need to check
			// if any rows in the table violate the new constraints.
			foreach (var tableId in ConstraintAlteredTables) {
				// We need to check there are no constraint violations for all the
				// rows in the table.
				for (int n = 0; n &lt; normalizedChangedTables.Length; ++n) {
					CommitTableInfo tableInfo = normalizedChangedTables[n];
					if (tableInfo.Master.TableId == tableId) {
						checkTransaction.CheckAddConstraintViolations(changedTableSource[n], ConstraintDeferrability.InitiallyDeferred);
					}
				}
			}

			// For each changed table we must determine the rows that
			// were deleted and perform the remove constraint checks on the
			// deleted rows.  Note that this happens after the records are
			// removed from the index.

			// For each changed table,
			for (int i = 0; i &lt; normalizedChangedTables.Length; ++i) {
				CommitTableInfo tableInfo = normalizedChangedTables[i];
				// Get the journal that details the change to the table.
				TableEventRegistry changeJournal = tableInfo.Journal;
				if (changeJournal != null) {
					// Find the normalized deleted rows.
					int[] normalizedRemovedRows = changeJournal.RemovedRows.ToArray();
					// Check removing any of the data doesn&#39;t cause a constraint
					// violation.
					checkTransaction.CheckRemoveConstraintViolations(changedTableSource[i], normalizedRemovedRows, ConstraintDeferrability.InitiallyDeferred);

					// Find the normalized added rows.
					int[] normalizedAddedRows = changeJournal.AddedRows.ToArray();
					// Check adding any of the data doesn&#39;t cause a constraint
					// violation.
					checkTransaction.CheckAddConstraintViolations(changedTableSource[i], normalizedAddedRows, ConstraintDeferrability.InitiallyDeferred);

					// Set up the list of added and removed rows
					tableInfo.NormalizedAddedRows = normalizedAddedRows;
					tableInfo.NormalizedRemovedRows = normalizedRemovedRows;

				}
			}
		}

		internal IEnumerable&lt;TableSource&gt; Commit(IList&lt;TransactionObjectState&gt; nameSpaceJournals, Action&lt;TableCommitInfo&gt; commitActions) {
			var changedTablesList = new List&lt;TableSource&gt;();

			// This is a transaction that will represent the view of the database
			// at the end of the commit
			ITransaction checkTransaction = null;

			bool entriesCommitted = false;

			try {
				// ---- Commit check stage ----
				CheckConflicts(nameSpaceJournals);

				// Tests passed so go on to commit,

				// ---- Commit stage ----

				var normalizedChangedTables = GetNormalizedChangedTables();
				var normalizedDroppedTables = GetNormalizedDroppedTables();

				// We now need to create a ITransaction object that we
				// use to send to the triggering mechanism.  This
				// object represents a very specific view of the
				// transaction.  This view contains the latest version of changed
				// tables in this transaction.  It also contains any tables that have
				// been created by this transaction and does not contain any tables
				// that have been dropped.  Any tables that have not been touched by
				// this transaction are shown in their current committed state.
				// To summarize - this view is the current view of the database plus
				// any modifications made by the transaction that is being committed.

				// How this works - All changed tables are merged with the current
				// committed table.  All created tables are added into check_transaction
				// and all dropped tables are removed from check_transaction.  If
				// there were no other changes to a table between the time the
				// transaction was created and now, the view of the table in the
				// transaction is used, otherwise the latest changes are merged.

				// Note that this view will be the view that the database will
				// ultimately become if this transaction successfully commits.  Also,
				// you should appreciate that this view is NOT exactly the same as
				// the current trasaction view because any changes that have been
				// committed by concurrent transactions will be reflected in this view.

				// Create a new transaction of the database which will represent the
				// committed view if this commit is successful.
				checkTransaction = Composite.CreateTransaction(TransactionIsolation.Serializable);

				// Overwrite this view with tables from this transaction that have
				// changed or have been added or dropped.

				// (Note that order here is important).  First drop any tables from
				// this view.
				foreach (TableSource masterTable in normalizedDroppedTables) {
					// Drop this table in the current view
					checkTransaction.RemoveVisibleTable(masterTable);
				}

				// Now add any changed tables to the view.

				// Represents view of the changed tables
				var changedTableSource = FindChangedTables(checkTransaction, normalizedChangedTables);

				// The &#39;checkTransaction&#39; now represents the view the database will be
				// if the commit succeeds.  We Lock &#39;checkTransaction&#39; so it is
				// Read-only (the view is immutable).
				checkTransaction.ReadOnly(true);

				CheckConstraintViolations(checkTransaction, normalizedChangedTables, changedTableSource);

				// Deferred trigger events.
				FireChangeEvents(checkTransaction, normalizedChangedTables, commitActions);

				// NOTE: This isn&#39;t as fail safe as it could be.  We really need to
				//  do the commit in two phases.  The first writes updated indices to
				//  the index files.  The second updates the header pointer for the
				//  respective table.  Perhaps we can make the header update
				//  procedure just one file Write.

				// Finally, at this point all constraint checks have passed and the
				// changes are ready to finally be committed as permanent changes
				// to the Composite.  All that needs to be done is to commit our
				// IIndexSet indices for each changed table as final.
				// ISSUE: Should we separate the &#39;committing of indexes&#39; changes and
				//   &#39;committing of delete/add flags&#39; to make the FS more robust?
				//   It would be more robust if all indexes are committed in one go,
				//   then all table flag data.

				// Set flag to indicate we have committed entries.
				entriesCommitted = true;

				// For each change to each table,
				foreach (CommitTableInfo tableInfo in normalizedChangedTables) {
					// Get the journal that details the change to the table.
					TableEventRegistry changeJournal = tableInfo.Journal;
					if (changeJournal != null) {
						// Get the master table with this table id.
						TableSource master = tableInfo.Master;
						// Commit the changes to the table.
						// We use &#39;this.commit_id&#39; which is the current commit level we are
						// at.
						master.CommitTransactionChange(Composite.CurrentCommitId, changeJournal, tableInfo.IndexSet);
						// Add to &#39;changed_tables_list&#39;
						changedTablesList.Add(master);
					}
				}

				// Only do this if we&#39;ve created or dropped tables.
				if (CreatedTables.Any() || DroppedTables.Any()) {
					// Update the committed tables in the Composite state.
					// This will update and synchronize the headers in this Composite.
					Composite.CommitToTables(CreatedTables, DroppedTables);
				}

				// Update the namespace clash list
				if (ObjectsCreated.Any() || ObjectsDropped.Any()) {
					nameSpaceJournals.Add(new TransactionObjectState(CommitId, ObjectsCreated, ObjectsDropped));
				}
			} finally {
				try {
					// If entries_committed == false it means we didn&#39;t get to a point
					// where any changed tables were committed.  Attempt to rollback the
					// changes in this transaction if they haven&#39;t been committed yet.
					if (entriesCommitted == false) {
						// For each change to each table,
						foreach (TableEventRegistry changeJournal in ChangedTables) {
							// The table the changes were made to.
							int tableId = changeJournal.TableId;
							// Get the master table with this table id.
							TableSource master = Composite.GetTableSource(tableId);
							// Commit the rollback on the table.
							master.RollbackTransactionChange(changeJournal);
						}

						// TODO: Notify the system we&#39;re rolling back
					}
				} finally {
					try {
						// Dispose the &#39;checkTransaction&#39;
						if (checkTransaction != null) {
							checkTransaction.Dispose();
							Composite.CloseTransaction(checkTransaction);
						}
						// Always ensure a transaction close, even if we have an exception.
						// Notify the Composite that this transaction has closed.
						Composite.CloseTransaction(Transaction);
					} catch (Exception e) {
						// TODO: notify the error
					} finally {
						Done = true;
					}
				}
			}

			return changedTablesList.AsReadOnly();
		}

		/// &lt;summary&gt;
		/// A static container class for information collected about a table 
		/// during the commit cycle.
		/// &lt;/summary&gt;
		private sealed class CommitTableInfo {
			// The master table
			public TableSource Master;
			// The immutable index set
			public IIndexSet IndexSet;
			// The journal describing the changes to this table by this
			// transaction.
			public TableEventRegistry Journal;
			// A list of journals describing changes since this transaction
			// started.
			public TableEventRegistry[] ChangesSinceCommit;
			// Break down of changes to the table
			// Normalized list of row ids that were added
			public int[] NormalizedAddedRows;
			// Normalized list of row ids that were removed
			public int[] NormalizedRemovedRows;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[99,43,99,61,0],[99,14,99,39,0],[102,6,102,72,0],[103,6,103,30,0],[106,7,110,33,0],[99,40,99,42,0],[124,13,124,26,0],[125,5,125,40,0],[126,6,126,55,0],[127,6,127,55,0],[136,13,136,33,0],[137,5,137,44,0],[138,6,138,23,0],[139,6,139,31,0],[140,6,140,34,0],[145,13,145,33,0],[146,5,146,44,0],[147,6,147,23,0],[148,6,148,31,0],[149,6,149,36,0],[154,5,158,20,0],[174,6,177,53,0],[187,14,187,45,0],[189,6,189,68,0],[196,13,196,24,0],[198,5,198,60,0],[200,5,200,54,0],[202,6,205,63,0],[258,13,258,24,0],[261,5,261,42,0],[262,6,262,66,0],[263,6,263,47,0],[309,6,309,83,0],[311,6,311,72,0],[313,6,313,28,0],[316,6,316,23,0],[330,30,330,53,0],[330,13,330,26,0],[332,5,332,58,0],[333,5,333,31,0],[335,6,335,49,0],[336,6,337,39,0],[330,27,330,29,0],[340,3,340,4,0],[345,13,345,24,0],[348,10,348,20,0],[349,6,349,61,0],[350,6,350,46,0],[351,7,351,119,0],[348,57,348,60,0],[348,21,348,55,0],[440,14,440,37,0],[442,6,442,55,0],[512,52,512,65,0],[512,16,512,48,0],[514,8,514,44,0],[516,8,516,63,0],[518,8,518,56,0],[512,49,512,51,0],[533,8,533,27,0],[34,3,34,200,1],[35,4,35,26,1],[36,4,36,30,1],[37,4,37,44,1],[43,4,43,46,1],[43,112,43,114,1],[46,4,46,42,1],[48,4,48,42,1],[50,4,50,62,1],[54,4,54,57,1],[57,4,57,57,1],[59,4,59,36,1],[60,3,60,4,1],[79,10,79,116,1],[90,4,90,28,1],[90,54,90,56,1],[96,4,96,41,1],[114,3,114,4,1],[117,4,117,26,1],[122,4,122,47,1],[123,4,123,47,1],[124,30,124,47,1],[124,27,124,29,1],[133,4,133,27,1],[134,4,134,31,1],[135,4,135,29,1],[136,37,136,50,1],[136,34,136,36,1],[145,37,145,50,1],[145,34,145,36,1],[152,4,152,18,1],[162,49,162,62,1],[162,13,162,45,1],[164,5,164,41,1],[166,5,166,60,1],[169,5,169,73,1],[172,5,172,64,1],[184,5,184,64,1],[187,49,187,62,1],[187,46,187,48,1],[162,46,162,48,1],[196,28,196,41,1],[196,25,196,27,1],[208,3,208,4,1],[216,4,216,63,1],[220,4,221,42,1],[228,7,228,10,1],[231,28,231,41,1],[231,13,231,24,1],[234,5,234,42,1],[235,6,235,66,1],[236,6,236,73,1],[239,7,241,9,1],[243,7,243,46,1],[231,25,231,27,1],[248,4,248,45,1],[257,4,257,59,1],[258,28,258,41,1],[258,25,258,27,1],[267,4,267,45,1],[271,4,271,72,1],[274,9,274,19,1],[276,5,276,60,1],[279,5,279,43,1],[281,5,281,73,1],[283,5,283,64,1],[288,6,288,65,1],[290,6,290,67,1],[292,6,292,28,1],[296,6,296,80,1],[320,5,320,73,1],[274,56,274,59,1],[274,20,274,54,1],[323,4,323,30,1],[327,4,327,30,1],[328,5,328,12,1],[345,28,345,51,1],[345,25,345,27,1],[362,9,362,19,1],[363,5,363,60,1],[365,5,365,58,1],[366,5,366,31,1],[368,6,368,72,1],[371,6,371,144,1],[374,6,374,68,1],[377,6,377,139,1],[380,6,380,58,1],[381,6,381,62,1],[362,56,362,59,1],[362,20,362,54,1],[385,3,385,4,1],[388,4,388,52,1],[392,4,392,41,1],[394,4,394,34,1],[398,5,398,39,1],[404,5,404,64,1],[405,5,405,64,1],[433,5,433,87,1],[440,41,440,64,1],[440,38,440,40,1],[448,5,448,91,1],[453,5,453,37,1],[455,5,455,94,1],[458,5,458,80,1],[476,5,476,29,1],[479,43,479,66,1],[479,14,479,39,1],[481,6,481,59,1],[482,6,482,32,1],[484,7,484,45,1],[488,7,488,100,1],[490,7,490,37,1],[479,40,479,42,1],[495,5,495,52,1],[498,6,498,61,1],[502,5,502,54,1],[503,6,503,98,1],[510,6,510,36,1],[526,7,526,36,1],[527,8,527,35,1],[528,8,528,53,1],[532,7,532,47,1],[536,7,536,19,1],[541,4,541,42,1],[43,46,43,61,1],[43,85,43,112,1],[221,42,221,94,1],[222,18,222,52,1],[223,19,223,79,1],[224,19,228,7,1],[90,28,90,54,1]]);
    </script>
  </body>
</html>