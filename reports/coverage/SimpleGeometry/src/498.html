<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.text\metaphone.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Text;

namespace Deveel.Data.Text {
	public sealed class Metaphone {
		#region ctor
		public Metaphone() {
		}
		#endregion

		#region Fields
		private string vowels = &quot;AEIOU&quot;;
		private string frontv = &quot;EIY&quot;;
		private string varson = &quot;CSPTG&quot;;
		private int maxCodeLen = 4;
		#endregion

		#region Private Methods
		private bool IsLastChar(int wdsz, int n) {
			return n + 1 == wdsz;
		}

		private bool RegionMatch(StringBuilder sb, int index, String test) {
			bool matches = false;
			if( index &gt;= 0 &amp;&amp;
				(index + test.Length - 1) &lt; sb.Length) {
				string substring = sb.ToString(index, test.Length);
				matches = substring.Equals(test);
			}
			return matches;
		}

		private bool IsVowel(StringBuilder sb, int index) {
			return (this.vowels.IndexOf(sb[index]) &gt;= 0);
		}

		private bool IsPreviousChar(StringBuilder sb, int index, char c) {
			bool matches = false;
			if( index &gt; 0 &amp;&amp; index &lt; sb.Length) {
				matches = sb[index - 1] == c;
			}
			return matches;
		}

		private bool IsNextChar(StringBuilder sb, int index, char c) {
			bool matches = false;
			if (index &gt;= 0 &amp;&amp; index &lt; sb.Length - 1) {
				matches = sb[index + 1] == c;
			}
			return matches;
		}
		#endregion

		#region Public Methods
		public string Compute(string s) {
			if (string.IsNullOrEmpty(s))
				return &quot;&quot;;

			// single character is itself
			if (s.Length == 1)
				return s.ToUpper();
       
			char[] inwd = s.ToUpper().ToCharArray() ;
       
			StringBuilder local = new StringBuilder(40); // manipulate
			StringBuilder code = new StringBuilder(10) ; //   output
			// handle initial 2 characters exceptions
			switch(inwd[0]) {
				case &#39;K&#39; : 
				case &#39;G&#39; : 
				case &#39;P&#39; : /* looking for KN, etc*/
					if (inwd[1] == &#39;N&#39;) {
						local.Append(inwd, 1, inwd.Length - 1);
					} else {
						local.Append(inwd);
					}
					break;
				case &#39;A&#39;: /* looking for AE */
					if (inwd[1] == &#39;E&#39;) {
						local.Append(inwd, 1, inwd.Length - 1);
					} else {
						local.Append(inwd);
					}
					break;
				case &#39;W&#39; : /* looking for WR or WH */
					if (inwd[1] == &#39;R&#39;) {   // WR -&gt; R
						local.Append(inwd, 1, inwd.Length - 1); 
						break ;
					}
					if (inwd[1] == &#39;H&#39;) {
						local.Append(inwd, 1, inwd.Length - 1);
						local[0] = &#39;W&#39;; // WH -&gt; W
					} else {
						local.Append(inwd);
					}
					break;
				case &#39;X&#39; : /* initial X becomes S */
					inwd[0] = &#39;S&#39;;
					local.Append(inwd);
					break ;
				default :
					local.Append(inwd);
					break;
			} // now local has working string with initials fixed

			int wdsz = local.Length;
			int n = 0 ;

			while ((code.Length &lt; this.maxCodeLen) &amp;&amp; 
				(n &lt; wdsz) ) { // max code size of 4 works well
				char symb = local[n];
				// remove duplicate letters except C
				if ((symb != &#39;C&#39;) &amp;&amp; (IsPreviousChar( local, n, symb )) ) {
					n++ ;
				} else { // not dup
					switch(symb) {
						case &#39;A&#39; : case &#39;E&#39; : case &#39;I&#39; : case &#39;O&#39; : case &#39;U&#39; :
							if (n == 0) { 
								code.Append(symb);
							}
							break ; // only use vowel if leading char
						case &#39;B&#39; :
							if (IsPreviousChar(local, n, &#39;M&#39;) &amp;&amp; 
								IsLastChar(wdsz, n) ) { // B is silent if word ends in MB
								break;
							}
							code.Append(symb);
							break;
						case &#39;C&#39; : // lots of C special cases
							/* discard if SCI, SCE or SCY */
							if (IsPreviousChar(local, n, &#39;S&#39;) &amp;&amp; 
								!IsLastChar(wdsz, n) &amp;&amp; 
								(this.frontv.IndexOf(local[n + 1]) &gt;= 0)) {
								break;
							}
							if (RegionMatch(local, n, &quot;CIA&quot;)) { // &quot;CIA&quot; -&gt; X
								code.Append(&#39;X&#39;); 
								break;
							}
							if (!IsLastChar(wdsz, n) &amp;&amp; 
								(this.frontv.IndexOf(local[n + 1]) &gt;= 0)) {
								code.Append(&#39;S&#39;);
								break; // CI,CE,CY -&gt; S
							}
							if (IsPreviousChar(local, n, &#39;S&#39;) &amp;&amp;
								IsNextChar(local, n, &#39;H&#39;) ) { // SCH-&amp;gtsk
								code.Append(&#39;K&#39;) ; 
								break ;
							}
							if (IsNextChar(local, n, &#39;H&#39;)) { // detect CH
								if ((n == 0) &amp;&amp; 
									(wdsz &gt;= 3) &amp;&amp; 
									IsVowel(local,2) ) { // CH consonant -&gt; K consonant
									code.Append(&#39;K&#39;);
								} else { 
									code.Append(&#39;X&#39;); // CHvowel -&gt; X
								}
							} else { 
								code.Append(&#39;K&#39;);
							}
							break ;
						case &#39;D&#39; :
							if (!IsLastChar(wdsz, n + 1) &amp;&amp; 
								IsNextChar(local, n, &#39;G&#39;) &amp;&amp; 
								(this.frontv.IndexOf(local[n + 2]) &gt;= 0)) { // DGE DGI DGY -&gt; J 
								code.Append(&#39;J&#39;); n += 2 ;
							} else { 
								code.Append(&#39;T&#39;);
							}
							break ;
						case &#39;G&#39; : // GH silent at end or before consonant
							if (IsLastChar(wdsz, n + 1) &amp;&amp; 
								IsNextChar(local, n, &#39;H&#39;)) {
								break;
							}
							if (!IsLastChar(wdsz, n + 1) &amp;&amp;  
								IsNextChar(local,n,&#39;H&#39;) &amp;&amp; 
								!IsVowel(local,n+2)) {
								break;
							}
							if ((n &gt; 0) &amp;&amp; 
								(RegionMatch(local, n, &quot;GN&quot;) ||
								RegionMatch(local, n, &quot;GNED&quot;) ) ) {
								break; // silent G
							}
							var hard = false ;
							if (IsPreviousChar(local, n, &#39;G&#39;)) {
								hard = true ;
							} else {
								hard = false ;
							}
							if (!IsLastChar(wdsz, n) &amp;&amp; 
								(this.frontv.IndexOf(local[n + 1]) &gt;= 0) &amp;&amp; 
								(!hard)) {
								code.Append(&#39;J&#39;);
							} else {
								code.Append(&#39;K&#39;);
							}
							break ;
						case &#39;H&#39;:
							if (IsLastChar(wdsz, n)) {
								break ; // terminal H
							}
							if ((n &gt; 0) &amp;&amp; 
								(this.varson.IndexOf(local[n - 1]) &gt;= 0)) {
								break;
							}
							if (IsVowel(local,n+1)) {
								code.Append(&#39;H&#39;); // Hvowel
							}
							break;
						case &#39;F&#39;: 
						case &#39;J&#39; : 
						case &#39;L&#39; :
						case &#39;M&#39;: 
						case &#39;N&#39; : 
						case &#39;R&#39; :
							code.Append(symb); 
							break;
						case &#39;K&#39; :
							if (n &gt; 0) { // not initial
								if (!IsPreviousChar(local, n, &#39;C&#39;)) {
									code.Append(symb);
								}
							} else {
								code.Append(symb); // initial K
							}
							break ;
						case &#39;P&#39; :
							if (IsNextChar(local,n,&#39;H&#39;)) {
								// PH -&gt; F
								code.Append(&#39;F&#39;);
							} else {
								code.Append(symb);
							}
							break ;
						case &#39;Q&#39; :
							code.Append(&#39;K&#39;);
							break;
						case &#39;S&#39; :
							if (RegionMatch(local,n,&quot;SH&quot;) || 
								RegionMatch(local,n,&quot;SIO&quot;) || 
								RegionMatch(local,n,&quot;SIA&quot;)) {
								code.Append(&#39;X&#39;);
							} else {
								code.Append(&#39;S&#39;);
							}
							break;
						case &#39;T&#39; :
							if (RegionMatch(local,n,&quot;TIA&quot;) || 
								RegionMatch(local,n,&quot;TIO&quot;)) {
								code.Append(&#39;X&#39;); 
								break;
							}
							if (RegionMatch(local,n,&quot;TCH&quot;)) {
								// Silent if in &quot;TCH&quot;
								break;
							}
							// substitute numeral 0 for TH (resembles theta after all)
							if (RegionMatch(local,n,&quot;TH&quot;)) {
								code.Append(&#39;0&#39;);
							} else {
								code.Append(&#39;T&#39;);
							}
							break ;
						case &#39;V&#39; :
							code.Append(&#39;F&#39;);
							break ;
						case &#39;W&#39; : case &#39;Y&#39; : // silent if not followed by vowel
							if (!IsLastChar(wdsz,n) &amp;&amp; 
								IsVowel(local,n+1)) {
								code.Append(symb);
							}
							break ;
						case &#39;X&#39; :
							code.Append(&#39;K&#39;);
							code.Append(&#39;S&#39;);
							break ;
						case &#39;Z&#39; :
							code.Append(&#39;S&#39;);
							break ;
					} // end switch
					n++ ;
				} // end else from symb != &#39;C&#39;
				if (code.Length &gt; this.maxCodeLen) { 
					code.Length = maxCodeLen; 
				}
			}
			return code.ToString();
		}
		#endregion
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[28,3,28,35,0],[29,3,29,33,0],[30,3,30,35,0],[31,3,31,30,0],[23,3,23,21,0],[24,3,24,4,0],[36,4,36,25,0],[40,4,40,25,0],[41,4,42,43,0],[43,5,43,56,0],[44,5,44,38,0],[46,4,46,19,0],[50,4,50,49,0],[54,4,54,25,0],[55,4,55,39,0],[56,5,56,34,0],[58,4,58,19,0],[62,4,62,25,0],[63,4,63,44,0],[64,5,64,34,0],[66,4,66,19,0],[72,4,72,32,0],[73,5,73,15,0],[76,4,76,22,0],[77,5,77,24,0],[79,4,79,45,0],[81,4,81,48,0],[82,4,82,48,0],[84,4,84,19,0],[88,6,88,25,0],[89,7,89,46,0],[91,7,91,26,0],[93,6,93,12,0],[95,6,95,25,0],[96,7,96,46,0],[98,7,98,26,0],[100,6,100,12,0],[102,6,102,25,0],[103,7,103,46,0],[104,7,104,14,0],[106,6,106,25,0],[107,7,107,46,0],[108,7,108,22,0],[110,7,110,26,0],[112,6,112,12,0],[114,6,114,20,0],[115,6,115,25,0],[116,6,116,13,0],[118,6,118,25,0],[122,4,122,28,0],[123,4,123,15,0],[127,5,127,26,0],[129,5,129,62,0],[130,6,130,11,0],[132,6,132,18,0],[134,8,134,19,0],[135,9,135,27,0],[137,8,137,15,0],[139,8,140,30,0],[143,8,143,26,0],[144,8,144,14,0],[147,8,149,50,0],[152,8,152,41,0],[153,9,153,26,0],[154,9,154,15,0],[156,8,157,50,0],[158,9,158,26,0],[159,9,159,15,0],[161,8,162,36,0],[163,9,163,27,0],[164,9,164,16,0],[166,8,166,38,0],[167,9,169,28,0],[170,10,170,27,0],[172,10,172,27,0],[175,9,175,26,0],[177,8,177,15,0],[179,8,181,50,0],[182,9,182,26,0],[182,27,182,35,0],[184,9,184,26,0],[186,8,186,15,0],[188,8,189,35,0],[192,8,194,29,0],[197,8,199,42,0],[202,8,202,26,0],[203,8,203,42,0],[204,9,204,22,0],[206,9,206,23,0],[208,8,210,17,0],[211,9,211,26,0],[213,9,213,26,0],[215,8,215,15,0],[217,8,217,32,0],[220,8,221,50,0],[224,8,224,31,0],[225,9,225,26,0],[227,8,227,14,0],[234,8,234,26,0],[235,8,235,14,0],[237,8,237,18,0],[238,9,238,44,0],[239,10,239,28,0],[242,9,242,27,0],[244,8,244,15,0],[246,8,246,36,0],[248,9,248,26,0],[250,9,250,27,0],[252,8,252,15,0],[254,8,254,25,0],[255,8,255,14,0],[257,8,259,36,0],[260,9,260,26,0],[262,9,262,26,0],[264,8,264,14,0],[266,8,267,36,0],[268,9,268,26,0],[269,9,269,15,0],[271,8,271,39,0],[276,8,276,38,0],[277,9,277,26,0],[279,9,279,26,0],[281,8,281,15,0],[283,8,283,25,0],[284,8,284,15,0],[286,8,287,28,0],[288,9,288,27,0],[290,8,290,15,0],[292,8,292,25,0],[293,8,293,25,0],[294,8,294,15,0],[296,8,296,25,0],[299,6,299,11,0],[301,5,301,39,0],[302,6,302,31,0],[125,4,126,17,0],[305,4,305,27,0]]);
    </script>
  </body>
</html>