<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.store\scatteringfilestoredata.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Deveel.Data.Store {
	public sealed class ScatteringFileStoreData : IStoreData {
		private readonly object objectLock = new object();
		private List&lt;FileStoreData&gt; fileSlices;
		private long trueFileLength;
		
		public ScatteringFileStoreData(string basePath, string fileName, string fileExtention, int maxFileSlice) {
			MaxFileSlice = maxFileSlice;
			FileExtention = fileExtention;
			FileName = fileName;
			BasePath = basePath;
			fileSlices = new List&lt;FileStoreData&gt;(maxFileSlice);
		}

		~ScatteringFileStoreData() {
			Dispose(false);
		}

		public string BasePath { get; private set; }

		public string FileName { get; private set; }

		public string FileExtention { get; private set; }

		public int MaxFileSlice { get; private set; }

		public int FileCount {
			get {
				int i = 0;
				string f = SliceFileName(i);
				while (File.Exists(f)) {
					++i;
					f = SliceFileName(i);
				}
				return i;
			}
		}

		public bool IsOpen { get; private set; }

		private string SliceFileName(int i) {
			if (i == 0)
				return Path.Combine(BasePath, String.Format(&quot;{0}.{1}&quot;, FileName, FileExtention));

			var fn = new StringBuilder();
			fn.Append(FileName);
			fn.Append(&quot;.&quot;);
			if (i &lt; 10) {
				fn.Append(&quot;00&quot;);
			} else if (i &lt; 100) {
				fn.Append(&quot;0&quot;);
			}
			fn.Append(i);
			return Path.Combine(BasePath, fn.ToString());
		}

		private long DiscoverSize() {
			long runningTotal = 0;

			lock (objectLock) {
				// Does the file exist?
				int i = 0;
				string f = SliceFileName(i);
				while (File.Exists(f)) {
					runningTotal += new FileInfo(f).Length;

					++i;
					f = SliceFileName(i);
				}
			}

			return runningTotal;
		}

		private void Dispose(bool disposing) {
			if (disposing) {
				foreach (var slice in fileSlices) {
					if (slice != null)
						slice.Dispose();
				}

				fileSlices.Clear();
				fileSlices = null;
			}
		}

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		public bool Exists {
			get { return File.Exists(SliceFileName(0)); }
		}

		public long Length {
			get {
				lock (objectLock) {
					return IsOpen ? trueFileLength : DiscoverSize();
				}
			}
		}

		public bool IsReadOnly { get; private set; }

		public bool Delete() {
			// The number of files
			int countFiles = FileCount;
			// Delete each file from back to front
			for (int i = countFiles - 1; i &gt;= 0; --i) {
				string f = SliceFileName(i);
				bool deleteSuccess = new FileStoreData(f).Delete();
				if (!deleteSuccess)
					return false;
			}
			return true;
		}

		public void Open(bool readOnly) {
			lock (objectLock) {
				// Does the file exist?
				string f = SliceFileName(0);
				bool openExisting = File.Exists(f);

				// If the file already exceeds the threshold and there isn&#39;t a secondary
				// file then we need to convert the file.
				if (openExisting &amp;&amp; f.Length &gt; MaxFileSlice) {
					string f2 = SliceFileName(1);
					if (File.Exists(f2))
						throw new IOException(&quot;File length exceeds maximum slice size setting.&quot;);

					// We need to scatter the file.
					if (readOnly)
						throw new IOException(&quot;Unable to convert to a scattered store because Read-only.&quot;);						
				}

				// Setup the first file slice
				var slice = new FileStoreData(f);
				slice.Open(readOnly);

				fileSlices.Add(slice);
				long runningLength = slice.Length;

				// If we are opening a store that exists already, there may be other
				// slices we need to setup.
				if (openExisting) {
					int i = 1;
					string slicePart = SliceFileName(i);
					while (File.Exists(slicePart)) {
						// Create the new slice information for this part of the file.
						slice = new FileStoreData(slicePart);
						slice.Open(readOnly);

						fileSlices.Add(slice);
						runningLength += slice.Length;

						++i;
						slicePart = SliceFileName(i);
					}
				}

				trueFileLength = runningLength;
				IsOpen = true;
				IsReadOnly = readOnly;
			}

		}

		public void Close() {
			lock (objectLock) {
				foreach (var slice in fileSlices) {
					slice.Close();
				}
			}
		}

		public int Read(long position, byte[] buffer, int offset, int length) {
			// Reads the array (potentially across multiple slices).
			int count = 0;
			while (length &gt; 0) {
				int fileI = (int)(position / MaxFileSlice);
				long fileP = (position % MaxFileSlice);
				int fileLen = (int)System.Math.Min((long)length, MaxFileSlice - fileP);

				FileStoreData slice;
				lock (objectLock) {
					// Return if out of bounds.
					if (fileI &lt; 0 || fileI &gt;= fileSlices.Count) {
						// Error if not open
						if (!IsOpen)
							throw new IOException(&quot;Store not open.&quot;);

						return 0;
					}
					slice = fileSlices[fileI];
				}

				int readCount =slice.Read(fileP, buffer, offset, fileLen);
				if (readCount == 0)
					break;

				position += readCount;
				offset += readCount;
				length -= readCount;
				count += readCount;
			}

			return count;
		}

		public void Write(long position, byte[] buffer, int offset, int length) {
			// Writes the array (potentially across multiple slices).
			while (length &gt; 0) {
				var fileI = (int)(position / MaxFileSlice);
				var fileP = (position % MaxFileSlice);
				var fileLen = (int)System.Math.Min((long)length, MaxFileSlice - fileP);

				FileStoreData slice;
				lock (objectLock) {
					// Return if out of bounds.
					if (fileI &lt; 0 || fileI &gt;= fileSlices.Count) {
						if (!IsOpen)
							throw new IOException(&quot;Store not open.&quot;);

						return;
					}
					slice = fileSlices[fileI];
				}

				slice.Write(fileP, buffer, offset, fileLen);

				position += fileLen;
				offset += fileLen;
				length -= fileLen;
			}
		}

		public void Flush() {
			lock (objectLock) {
				foreach (var slice in fileSlices) {
					slice.Flush();
				}
			}
		}

		public void SetLength(long value) {
			lock (objectLock) {
				// The size we need to grow the data area
				long totalSizeToGrow = value - trueFileLength;
				// Assert that we aren&#39;t shrinking the data area size.
				if (totalSizeToGrow &lt; 0) {
					throw new IOException(&quot;Unable to make the data area size &quot; +
										  &quot;smaller for this type of store.&quot;);
				}

				while (totalSizeToGrow &gt; 0) {
					// Grow the last slice by this size
					int last = fileSlices.Count - 1;
					var slice = fileSlices[last];
					long oldSliceLength = slice.Length;
					long toGrow = System.Math.Min(totalSizeToGrow, (MaxFileSlice - oldSliceLength));

					// Flush the buffer and set the length of the file
					slice.SetLength(oldSliceLength + toGrow);
					slice.Flush();

					totalSizeToGrow -= toGrow;
					// Create a new empty slice if we need to extend the data area
					if (totalSizeToGrow &gt; 0) {
						string sliceFile = SliceFileName(last + 1);

						slice = new FileStoreData(sliceFile);
						slice.Open(false);

						fileSlices.Add(slice);
					}
				}
				trueFileLength = value;
			}
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[24,3,24,53,0],[28,3,28,107,0],[29,4,29,32,0],[30,4,30,34,0],[31,4,31,24,0],[32,4,32,24,0],[33,4,33,55,0],[34,3,34,4,0],[37,4,37,19,0],[38,3,38,4,0],[50,5,50,15,0],[51,5,51,33,0],[53,6,53,10,0],[54,6,54,27,0],[52,5,52,27,0],[56,5,56,14,0],[63,4,63,15,0],[64,5,64,86,0],[66,4,66,33,0],[67,4,67,24,0],[68,4,68,19,0],[69,4,69,15,0],[70,5,70,21,0],[71,11,71,23,0],[72,5,72,20,0],[74,4,74,17,0],[75,4,75,49,0],[79,4,79,26,0],[81,4,81,21,0],[83,5,83,15,0],[84,5,84,33,0],[86,6,86,45,0],[88,6,88,10,0],[89,6,89,27,0],[85,5,85,27,0],[93,4,93,24,0],[97,4,97,18,0],[98,27,98,37,0],[98,14,98,23,0],[99,6,99,24,0],[100,7,100,23,0],[98,24,98,26,0],[103,5,103,24,0],[104,5,104,23,0],[106,3,106,4,0],[109,4,109,18,0],[110,4,110,30,0],[111,3,111,4,0],[114,10,114,47,0],[119,5,119,22,0],[120,6,120,54,0],[122,4,122,5,0],[129,4,129,31,0],[131,9,131,32,0],[132,5,132,33,0],[133,5,133,56,0],[134,5,134,24,0],[135,6,135,19,0],[131,41,131,44,0],[131,33,131,39,0],[137,4,137,16,0],[141,4,141,21,0],[143,5,143,33,0],[144,5,144,40,0],[148,5,148,49,0],[149,6,149,35,0],[150,6,150,26,0],[151,7,151,80,0],[154,6,154,19,0],[155,7,155,90,0],[159,5,159,38,0],[160,5,160,26,0],[162,5,162,27,0],[163,5,163,39,0],[167,5,167,22,0],[168,6,168,16,0],[169,6,169,42,0],[172,7,172,44,0],[173,7,173,28,0],[175,7,175,29,0],[176,7,176,37,0],[178,7,178,11,0],[179,7,179,36,0],[170,6,170,36,0],[183,5,183,36,0],[184,5,184,19,0],[185,5,185,27,0],[188,3,188,4,0],[191,4,191,21,0],[192,27,192,37,0],[192,14,192,23,0],[193,6,193,20,0],[192,24,192,26,0],[196,3,196,4,0],[200,4,200,18,0],[202,5,202,48,0],[203,5,203,44,0],[204,5,204,76,0],[207,5,207,22,0],[209,6,209,49,0],[211,7,211,19,0],[212,8,212,49,0],[214,7,214,16,0],[216,6,216,32,0],[219,5,219,63,0],[220,5,220,24,0],[223,5,223,27,0],[224,5,224,25,0],[225,5,225,25,0],[226,5,226,24,0],[201,4,201,22,0],[229,4,229,17,0],[230,3,230,4,0],[235,5,235,48,0],[236,5,236,43,0],[237,5,237,76,0],[240,5,240,22,0],[242,6,242,49,0],[243,7,243,19,0],[244,8,244,49,0],[246,7,246,14,0],[248,6,248,32,0],[251,5,251,49,0],[253,5,253,25,0],[254,5,254,23,0],[255,5,255,23,0],[234,4,234,22,0],[257,3,257,4,0],[260,4,260,21,0],[261,27,261,37,0],[261,14,261,23,0],[262,6,262,20,0],[261,24,261,26,0],[265,3,265,4,0],[268,4,268,21,0],[270,5,270,51,0],[272,5,272,29,0],[273,6,274,48,0],[279,6,279,38,0],[280,6,280,35,0],[281,6,281,41,0],[282,6,282,86,0],[285,6,285,47,0],[286,6,286,20,0],[288,6,288,32,0],[290,6,290,30,0],[291,7,291,50,0],[293,7,293,44,0],[294,7,294,25,0],[296,7,296,29,0],[277,5,277,32,0],[299,5,299,28,0],[301,3,301,4,0]]);
    </script>
  </body>
</html>