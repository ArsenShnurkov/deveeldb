<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql\tablequeryextensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text;

using Deveel.Data.DbSystem;
using Deveel.Data.Index;
using Deveel.Data.Sql.Expressions;
using Deveel.Data.Sql.Objects;
using Deveel.Data.Types;

namespace Deveel.Data.Sql {
	/// &lt;summary&gt;
	/// Provides a set of extension methods to &lt;see cref=&quot;ITable&quot;/&gt;
	/// and &lt;see cref=&quot;IMutableTable&quot;/&gt; objects.
	/// &lt;/summary&gt;
	public static class TableQueryExtensions {
		#region Internals

		internal static int FindColumn(this ITable table, ObjectName columnName) {
			if (table is IQueryTable)
				return ((IQueryTable) table).FindColumn(columnName);

			var parent = columnName.Parent;
			if (!parent.Equals(table.TableInfo.TableName))
				return -1;

			return table.TableInfo.IndexOfColumn(columnName.Name);
		}

		internal static int ColumnCount(this ITable table) {
			if (table is IQueryTable)
				return ((IQueryTable) table).ColumnCount;

			return table.TableInfo.ColumnCount;
		}

		internal static ObjectName GetResolvedColumnName(this ITable table, int columnOffset) {
			if (table is IQueryTable)
				return ((IQueryTable) table).GetResolvedColumnName(columnOffset);

			var tableName = table.TableInfo.TableName;
			var columnName = table.TableInfo[columnOffset].ColumnName;
			return new ObjectName(tableName, columnName);
		}

		internal static IEnumerable&lt;int&gt; ResolveRows(this ITable table, int columnOffset, IEnumerable&lt;int&gt; rows,
			ITable ancestor) {
			if (table is IQueryTable)
				return ((IQueryTable) table).ResolveRows(columnOffset, rows, ancestor);

			if (table != ancestor)
				throw new ArgumentException();

			return rows.ToList();
		}

		internal static ColumnIndex GetIndex(this ITable thisTable, int column, int originalColumn, ITable table) {
			if (thisTable is IQueryTable)
				return ((IQueryTable) thisTable).GetIndex(column, originalColumn, table);

			var index = thisTable.GetIndex(column);
			if (table == thisTable)
				return index;

			// Otherwise, get the scheme to calculate a subset of the given scheme.
			return index.GetSubset(table, originalColumn);
		}

		internal static ITableVariableResolver GetVariableResolver(this ITable table) {
			if (table is IQueryTable)
				return ((IQueryTable) table).GetVariableResolver();

			// TODO: implement a default table resolver
			throw new NotImplementedException();
		}

		private static ObjectName ResolveColumnName(this ITable table, string columnName) {
			return new ObjectName(table.TableInfo.TableName, columnName);
		}

		internal static void LockRoot(this ITable table, int lockKey) {
			if (table is IQueryTable)
				((IQueryTable)table).LockRoot(lockKey);
		}

		internal static void UnlockRoot(this ITable table, int lockKey) {
			if (table is IQueryTable)
				((IQueryTable)table).UnlockRoot(lockKey);
		}

		internal static RawTableInfo GetRawTableInfo(this ITable table) {
			return GetRawTableInfo(table, new RawTableInfo());
		}

		internal static RawTableInfo GetRawTableInfo(this ITable table, RawTableInfo info) {
			if (table is IQueryTable)
				return ((IQueryTable) table).GetRawTableInfo(info);

			throw new NotSupportedException();
		}

		#endregion

		#region Get Value

		public static DataObject GetValue(this ITable table, int rowIndex, ObjectName columnName) {
			return table.GetValue(rowIndex, table.IndexOfColumn(columnName));
		}

		public static DataObject GetValue(this ITable table, int rowIndex, string columnName) {
			return table.GetValue(rowIndex, table.ResolveColumnName(columnName));
		}

		public static DataObject GetLastValue(this ITable table, int columnOffset) {
			var rows = table.SelectLast(columnOffset).ToList();
			return rows.Count &gt; 0 ? table.GetValue(rows[0], columnOffset) : null;
		}

		public static DataObject[] GetLastValues(this ITable table, int[] columnOffsets) {
			if (columnOffsets.Length &gt; 1)
				throw new ArgumentException(&quot;Multi-column gets not supported.&quot;);

			return new[] {table.GetLastValue(columnOffsets[0])};
		}

		public static DataObject GetFirstValue(this ITable table, int columnOffset) {
			var rows = table.SelectFirst(columnOffset).ToList();
			return rows.Count &gt; 0 ? table.GetValue(rows[0], columnOffset) : null;
		}

		public static DataObject[] GetFirstValues(this ITable table, int[] columnOffsets) {
			if (columnOffsets.Length &gt; 1)
				throw new ArgumentException(&quot;Multi-column gets not supported.&quot;);

			return new[] {table.GetFirstValue(columnOffsets[0])};
		}

		public static DataObject GetSingleValue(this ITable table, int columnOffset) {
			IList&lt;int&gt; rows = table.SelectFirst(columnOffset).ToList();
			int sz = rows.Count;
			return sz == table.RowCount &amp;&amp; sz &gt; 0 ? table.GetValue(rows[0], columnOffset) : null;
		}

		public static DataObject[] GetSingleValues(this ITable table, int[] columnOffsets) {
			if (columnOffsets.Length &gt; 1)
				throw new ArgumentException(&quot;Multi-column gets not supported.&quot;);

			return new[] {table.GetSingleValue(columnOffsets[0])};
		}

		#endregion

		public static IEnumerable&lt;int&gt; FindKeys(this ITable table, int[] columnOffsets, DataObject[] keyValue) {
			int keySize = keyValue.Length;

			// Now command table 2 to determine if the key values are present.
			// Use index scan on first key.
			var columnIndex = table.GetIndex(columnOffsets[0]);
			var list = columnIndex.SelectEqual(keyValue[0]).ToList();

			if (keySize &lt;= 1)
				return list;

			// Full scan for the rest of the columns
			int sz = list.Count;

			// For each element of the list
			for (int i = sz - 1; i &gt;= 0; --i) {
				int rIndex = list[i];
				// For each key in the column list
				for (int c = 1; c &lt; keySize; ++c) {
					int columnOffset = columnOffsets[c];
					var columnValue = keyValue[c];
					if (columnValue.CompareTo(table.GetValue(rIndex, columnOffset)) != 0) {
						// If any values in the key are not equal set this flag to false
						// and remove the index from the list.
						list.RemoveAt(i);
						// Break the for loop
						break;
					}
				}
			}

			return list;
		}

		private static DataObject MakeObject(this ITable table, int columnOffset, ISqlObject value) {
			if (columnOffset &lt; 0 || columnOffset &gt;= table.TableInfo.ColumnCount)
				throw new ArgumentOutOfRangeException(&quot;columnOffset&quot;);

			var columnType = table.TableInfo[columnOffset].ColumnType;
			return new DataObject(columnType, value);
		}

		public static int IndexOfColumn(this ITable table, string columnName) {
			if (table is IQueryTable)
				return ((IQueryTable) table).FindColumn(ObjectName.Parse(columnName));

			return table.TableInfo.IndexOfColumn(columnName);
		}

		public static int IndexOfColumn(this ITable table, ObjectName columnName) {
			if (table is IQueryTable)
				return ((IQueryTable) table).FindColumn(columnName);

			if (columnName.Parent != null &amp;&amp;
			    !columnName.Parent.Equals(table.TableInfo.TableName))
				return -1;

			return table.TableInfo.IndexOfColumn(columnName);
		}

		public static IEnumerable&lt;int&gt; SelectRowsEqual(this ITable table, int columnIndex, DataObject value) {
			return table.GetIndex(columnIndex).SelectEqual(value);
		}

		public static IEnumerable&lt;int&gt; SelectRowsEqual(this ITable table, string columnName, DataObject value) {
			return table.SelectRowsEqual(table.IndexOfColumn(columnName), value);
		}

		public static ITable SelectEqual(this ITable table, int columnIndex, DataObject value) {
			return table.AsVirtual(() =&gt; table.SelectRowsEqual(columnIndex, value));
		}


		public static ITable SelectEqual(this ITable table, string columnName, DataObject value) {
			return table.AsVirtual(() =&gt; table.SelectRowsEqual(columnName, value));
		}

		public static IEnumerable&lt;int&gt; SelectNotEqual(this ITable table, int columnOffset, DataObject value) {
			return table.GetIndex(columnOffset).SelectNotEqual(value);
		}

		public static IEnumerable&lt;int&gt; SelectNotEqual(this ITable table, int columnOffset, ISqlObject value) {
			return table.SelectNotEqual(columnOffset, table.MakeObject(columnOffset, value));
		} 

		public static IEnumerable&lt;int&gt; SelectRowsEqual(this ITable table, int columnIndex1, DataObject value1, int columnIndex2, DataObject value2) {
			var result = new List&lt;int&gt;();

			var index1 = table.GetIndex(columnIndex1).SelectEqual(value1);
			foreach (var rowIndex in index1) {
				var tableValue = table.GetValue(rowIndex, columnIndex2);
				if (tableValue.IsEqualTo(value2))
					result.Add(rowIndex);
			}

			return result;
		}

		public static IEnumerable&lt;int&gt; SelectRange(this ITable table, int column, IndexRange[] ranges) {
			return table.GetIndex(column).SelectRange(ranges);
		}

		public static IEnumerable&lt;int&gt; SelectGreater(this ITable table, int columnOffset, DataObject value) {
			return table.GetIndex(columnOffset).SelectGreater(value);
		}

		public static IEnumerable&lt;int&gt; SelectGreater(this ITable table, int columnOffset, ISqlObject value) {
			return table.SelectGreater(columnOffset, table.MakeObject(columnOffset, value));
		}

		public static IEnumerable&lt;int&gt; SelectGreaterOrEqual(this ITable table, int columnOffset, DataObject value) {
			return table.GetIndex(columnOffset).SelectGreaterOrEqual(value);
		}

		public static IEnumerable&lt;int&gt; SelectGreaterOrEqual(this ITable table, int columnOffset, ISqlObject value) {
			return table.SelectGreaterOrEqual(columnOffset, table.MakeObject(columnOffset, value));
		} 

		public static IEnumerable&lt;int&gt; SelectLess(this ITable table, int columnOffset, DataObject value) {
			return table.GetIndex(columnOffset).SelectLess(value);
		}

		public static IEnumerable&lt;int&gt; SelectLess(this ITable table, int columnOffset, ISqlObject value) {
			return table.SelectLess(columnOffset, table.MakeObject(columnOffset, value));
		}

		public static IEnumerable&lt;int&gt; SelectLessOrEqualRows(this ITable table, int columnOffset, DataObject value) {
			return table.GetIndex(columnOffset).SelectLessOrEqual(value);
		}

		public static IEnumerable&lt;int&gt; SelectLessOrEqualRows(this ITable table, int columnOffset, ISqlObject value) {
			return table.SelectLessOrEqualRows(columnOffset, table.MakeObject(columnOffset, value));
		}

		public static IEnumerable&lt;int&gt; SelectAllRows(this ITable table, int columnOffset) {
			return table.GetIndex(columnOffset).SelectAll();
		}

		public static IEnumerable&lt;int&gt; SelectAllRows(this ITable table) {
			return table.Select(x =&gt; x.RowId.RowNumber);
		}

		public static ITable SelectAll(this ITable table, int columnOffset) {
			return table.AsVirtual(() =&gt; table.SelectAllRows(columnOffset));
		}

		public static IEnumerable&lt;int&gt; SelectLast(this ITable table, int columnOffset) {
			return table.GetIndex(columnOffset).SelectLast();
		}

		public static IEnumerable&lt;int&gt; SelectFirst(this ITable table, int columnOffset) {
			return table.GetIndex(columnOffset).SelectFirst();
		}

		public static bool Exists(this ITable table, int columnOffset, DataObject value) {
			return table.SelectRowsEqual(columnOffset, value).Any();
		}

		public static bool Exists(this ITable table, int columnOffset1, DataObject value1, int columnOffset2, DataObject value2) {
			return table.SelectRowsEqual(columnOffset1, value1, columnOffset2, value2).Any();
		}

		public static IEnumerable&lt;int&gt; SelectRows(this ITable table, int[] columnOffsets, SqlExpressionType op,
			DataObject[] values) {
			if (columnOffsets.Length &gt; 1)
				throw new NotSupportedException(&quot;Multi-column selects not supported yet.&quot;);

			return table.SelectRows(columnOffsets[0], op, values[0]);
		}

		public static IEnumerable&lt;int&gt; SelectBetween(this ITable table, int column, DataObject minCell, DataObject maxCell) {
			// Check all the tables are comparable
			var colType = table.TableInfo[column].ColumnType;
			if (!minCell.Type.IsComparable(colType) ||
				!maxCell.Type.IsComparable(colType)) {
				// Types not comparable, so return 0
				return new List&lt;int&gt;(0);
			}

			return table.GetIndex(column).SelectBetween(minCell, maxCell);
		}

		public static IEnumerable&lt;int&gt; SelectRows(this ITable table, int column, SqlExpressionType op, DataObject value) {
			// If the cell is of an incompatible type, return no results,
			var colType = table.TableInfo[column].ColumnType;
			if (!value.Type.IsComparable(colType)) {
				// Types not comparable, so return 0
				return new List&lt;int&gt;(0);
			}

			// Get the selectable scheme for this column
			var index = table.GetIndex(column);

			// If the operator is a standard operator, use the interned SelectableScheme
			// methods.
			if (op == SqlExpressionType.Equal)
				return index.SelectEqual(value);
			if (op == SqlExpressionType.NotEqual)
				return index.SelectNotEqual(value);
			if (op == SqlExpressionType.GreaterThan)
				return index.SelectGreater(value);
			if (op == SqlExpressionType.SmallerThan)
				return index.SelectLess(value);
			if (op == SqlExpressionType.GreaterOrEqualThan)
				return index.SelectGreaterOrEqual(value);
			if (op == SqlExpressionType.SmallerOrEqualThan)
				return index.SelectLessOrEqual(value);

			// If it&#39;s not a standard operator (such as IS, NOT IS, etc) we generate the
			// range set especially.
			var rangeSet = new IndexRangeSet();
			rangeSet = rangeSet.Intersect(op, value);
			return index.SelectRange(rangeSet.ToArray());
		}

		public static IEnumerable&lt;int&gt; SelectRows(this ITable table,
			IVariableResolver resolver,
			IQueryContext context,
			SqlBinaryExpression expression) {

			var objRef = expression.Left as SqlReferenceExpression;
			if (objRef == null)
				throw new NotSupportedException();

			var columnName = objRef.ReferenceName;

			var column = table.FindColumn(columnName);
			if (column &lt; 0)
				throw new InvalidOperationException();

			var reduced = expression.Right.Evaluate(context, resolver);
			if (reduced.ExpressionType != SqlExpressionType.Constant)
				throw new InvalidOperationException();

			var value = ((SqlConstantExpression) reduced).Value;
			var binOperator = expression.ExpressionType;

			return table.SelectRows(column, binOperator, value);
		}

		public static ITable SimpleSelect(this ITable table, IQueryContext context, ObjectName columnName, SqlExpressionType op, SqlExpression exp) {
			// Find the row with the name given in the condition.
			int column = table.FindColumn(columnName);

			if (column == -1)
				throw new ArgumentException(String.Format(&quot;Unable to find the column {0} in the condition.&quot;, columnName.Name));

			// If we are doing a sub-query search
			if (op.IsSubQuery()) {
				// We can only handle constant expressions in the RHS expression, and
				// we must assume that the RHS is a Expression[] array.
				if (exp.ExpressionType != SqlExpressionType.Constant &amp;&amp;
				    exp.ExpressionType != SqlExpressionType.Tuple)
					throw new ArgumentException();

				IEnumerable&lt;SqlExpression&gt; list;

				if (exp.ExpressionType == SqlExpressionType.Constant) {
					var tob = ((SqlConstantExpression) exp).Value;
					if (tob.Type is ArrayType) {
						var array = (SqlArray) tob.Value;
						list = array;
					} else {
						throw new Exception(&quot;Error with format or RHS expression.&quot;);
					}
				} else {
					list = ((SqlTupleExpression) exp).Expressions;
				}

				// Construct a temporary table with a single column that we are
				// comparing to.
				var col = table.TableInfo[column];
				var ttable = TemporaryTable.SingleColumnTable(table.DatabaseContext, col.ColumnName, col.ColumnType);

				foreach (var expression in list) {
					var rowNum = ttable.NewRow();

					var evalExp = (SqlConstantExpression)expression.Evaluate(context, null, null);
					ttable.SetValue(rowNum, 0, evalExp.Value);
				}

				ttable.BuildIndexes();

				// Perform the any/all sub-query on the constant table.

				return table.AnyAllNonCorrelated(new[] { columnName }, op, ttable);
			}

			{
				if (!exp.IsConstant())
					throw new ArgumentException(&quot;The search expression is not constant.&quot;);

				var evalExp = exp.Evaluate(context, null);
				if (evalExp.ExpressionType != SqlExpressionType.Constant)
					throw new InvalidOperationException();

				var value = ((SqlConstantExpression) evalExp).Value;

				IEnumerable&lt;int&gt; rows;

				if (op == SqlExpressionType.Like ||
				    op == SqlExpressionType.NotLike
					/* TODO: ||
				op.IsOfType(BinaryOperatorType.Regex)*/) {

					/*
				TODO:
				if (op.IsOfType(BinaryOperatorType.Regex)) {
					rows = SelectFromRegex(column, op, value);
				} else {
				 */
					rows = table.SelectFromPattern(column, op, value);
				} else {

					// Is the column we are searching on indexable?
					var colInfo = table.TableInfo[column];
					if (!colInfo.IsIndexable)
						throw new InvalidOperationException(String.Format(&quot;Column {0} os type {1} cannot be searched.&quot;, colInfo.ColumnName,
							colInfo.ColumnType));

					rows = table.SelectRows(column, op, value);
				}

				return new VirtualTable(table, rows) {SortColumn = column};
			}
		}

		public static ITable RangeSelect(this ITable thisTable, ObjectName columnName, IndexRange[] ranges) {
			// If this table is empty then there is no range to select so
			// trivially return this object.
			if (thisTable.RowCount == 0)
				return thisTable;

			// Are we selecting a black or null range?
			if (ranges == null || ranges.Length == 0)
				// Yes, so return an empty table
				return thisTable.EmptySelect();

			// Are we selecting the entire range?
			if (ranges.Length == 1 &amp;&amp;
				ranges[0].Equals(IndexRange.FullRange))
				// Yes, so return this table.
				return thisTable;

			// Must be a non-trivial range selection.

			// Find the column index of the column selected
			int column = thisTable.IndexOfColumn(columnName);

			if (column == -1) {
				throw new Exception(
				   &quot;Unable to find the column given to select the range of: &quot; +
				   columnName.Name);
			}

			// Select the range
			var rows = thisTable.SelectRange(column, ranges);

			// Make a new table with the range selected
			var result = new VirtualTable(thisTable, rows);

			// We know the new set is ordered by the column.
			result.SortColumn = column;

			return result;
		}


		public static ITable ExhaustiveSelect(this ITable table, IQueryContext context, SqlExpression expression) {
			var result = table;

			// Exit early if there&#39;s nothing in the table to select from
			int rowCount = table.RowCount;
			if (rowCount &gt; 0) {
				var tableResolver = table.GetVariableResolver();
				List&lt;int&gt; selectedSet = new List&lt;int&gt;(rowCount);

				foreach (var row in table) {
					int rowIndex = row.RowId.RowNumber;

					var rowResolver = tableResolver.ForRow(rowIndex);

					// Resolve expression into a constant.
					var exp = expression.Evaluate(context, rowResolver);
					if (exp.ExpressionType != SqlExpressionType.Constant)
						throw new NotSupportedException();

					var value = ((SqlConstantExpression) exp).Value;
					// If resolved to true then include in the selected set.
					if (!value.IsNull &amp;&amp; value.Type is BooleanType &amp;&amp;
						value == true) {
						selectedSet.Add(rowIndex);
					}
				}

				result = new VirtualTable(table, selectedSet); ;
			}

			return result;
		}


		public static IEnumerable&lt;int&gt; SelectFromPattern(this ITable table, int column, SqlExpressionType op, DataObject ob) {
			if (ob.IsNull)
				return new List&lt;int&gt;();

			if (op == SqlExpressionType.NotLike) {
				// How this works:
				//   Find the set or rows that are like the pattern.
				//   Find the complete set of rows in the column.
				//   Sort the &#39;like&#39; rows
				//   For each row that is in the original set and not in the like set,
				//     add to the result list.
				//   Result is the set of not like rows ordered by the column.

				var likeSet = (List&lt;int&gt;)table.Search(column, ob.ToString());
				// Don&#39;t include NULL values
				var nullCell = DataObject.Null(ob.Type);
				IList&lt;int&gt; originalSet = table.SelectRows(column, SqlExpressionType.IsNot, nullCell).ToList();
				int listSize = System.Math.Max(4, (originalSet.Count - likeSet.Count) + 4);
				List&lt;int&gt; resultSet = new List&lt;int&gt;(listSize);
				likeSet.Sort();
				int size = originalSet.Count;
				for (int i = 0; i &lt; size; ++i) {
					int val = originalSet[i];
					// If val not in like set, add to result
					if (likeSet.BinarySearch(val) == 0) {
						resultSet.Add(val);
					}
				}
				return resultSet;
			}

			// if (op.is(&quot;like&quot;)) {
			return table.Search(column, ob.ToString());
		}

		/// &lt;summary&gt;
		/// This is the search method.&lt;/summary&gt;
		/// &lt;remarks&gt;
		/// It requires a table to search, a column of the table, and a pattern.
		/// It returns the rows in the table that match the pattern if any. 
		/// Pattern searching only works successfully on columns that are of 
		/// type &lt;see cref=&quot;DbType.String&quot;/&gt;. This works by first reducing the 
		/// search to all cells that contain the first section of text. ie. 
		/// &lt;c&gt;pattern = &quot;Anto% ___ano&quot;&lt;/c&gt; will first reduce search to all 
		/// rows between &lt;i&gt;Anto&lt;/i&gt; and &lt;i&gt;Anton&lt;/i&gt;. This makes for better
		/// efficiency.
		/// &lt;/remarks&gt;
		public static IEnumerable&lt;int&gt; Search(this ITable table, int column, string pattern) {
			return table.Search(column, pattern, &#39;\\&#39;);
		}

		public static IEnumerable&lt;int&gt; Search(this ITable table, int column, string pattern, char escapeChar) {
			var colType = table.TableInfo[column].ColumnType;

			// If the column type is not a string type then report an error.
			if (!(colType is StringType))
				throw new ApplicationException(&quot;Unable to perform a pattern search on a non-String type column.&quot;);

			// First handle the case that the column has an index that supports text search
			var index = table.GetIndex(column);
			if (index != null &amp;&amp; index.HandlesTextSearch)
				return index.SelectLike(DataObject.String(pattern));

			var colStringType = (StringType)colType;

			// ---------- Pre Search ----------

			// First perform a &#39;pre-search&#39; on the head of the pattern.  Note that
			// there may be no head in which case the entire column is searched which
			// has more potential to be expensive than if there is a head.

			StringBuilder prePattern = new StringBuilder();
			int i = 0;
			bool finished = i &gt;= pattern.Length;
			bool lastIsEscape = false;

			while (!finished) {
				char c = pattern[i];
				if (lastIsEscape) {
					lastIsEscape = true;
					prePattern.Append(c);
				} else if (c == escapeChar) {
					lastIsEscape = true;
				} else if (!PatternSearch.IsWildCard(c)) {
					prePattern.Append(c);

					++i;
					if (i &gt;= pattern.Length) {
						finished = true;
					}

				} else {
					finished = true;
				}
			}

			// This is set with the remaining search.
			string postPattern;

			// This is our initial search row set.  In the second stage, rows are
			// eliminated from this vector.
			IEnumerable&lt;int&gt; searchCase;

			if (i &gt;= pattern.Length) {
				// If the pattern has no &#39;wildcards&#39; then just perform an EQUALS
				// operation on the column and return the results.

				var cell = new DataObject(colType, new SqlString(pattern));
				return table.SelectRows(column, SqlExpressionType.Equal, cell);
			}

			if (prePattern.Length == 0 ||
				colStringType.Locale != null) {

				// No pre-pattern easy search :-(.  This is either because there is no
				// pre pattern (it starts with a wild-card) or the locale of the string
				// is non-lexicographical.  In either case, we need to select all from
				// the column and brute force the search space.

				searchCase = table.SelectAllRows(column);
				postPattern = pattern;
			} else {

				// Criteria met: There is a pre_pattern, and the column locale is
				// lexicographical.

				// Great, we can do an upper and lower bound search on our pre-search
				// set.  eg. search between &#39;Geoff&#39; and &#39;Geofg&#39; or &#39;Geoff &#39; and
				// &#39;Geoff\33&#39;

				var lowerBounds = prePattern.ToString();
				int nextChar = prePattern[i - 1] + 1;
				prePattern[i - 1] = (char)nextChar;
				var upperBounds = prePattern.ToString();

				postPattern = pattern.Substring(i);

				var cellLower = new DataObject(colType, new SqlString(lowerBounds));
				var cellUpper = new DataObject(colType, new SqlString(upperBounds));

				// Select rows between these two points.

				searchCase = table.SelectBetween(column, cellLower, cellUpper);
			}

			// ---------- Post search ----------

			int preIndex = i;

			// Now eliminate from our &#39;search_case&#39; any cells that don&#39;t match our
			// search pattern.
			// Note that by this point &#39;post_pattern&#39; will start with a wild card.
			// This follows the specification for the &#39;PatternMatch&#39; method.
			// EFFICIENCY: This is a brute force iterative search.  Perhaps there is
			//   a faster way of handling this?

			var iList = new BlockIndex&lt;int&gt;(searchCase);
			var enumerator = iList.GetEnumerator(0, iList.Count - 1);

			while (enumerator.MoveNext()) {
				// Get the expression (the contents of the cell at the given column, row)

				bool patternMatches = false;
				var cell = table.GetValue(enumerator.Current, column);
				// Null values doesn&#39;t match with anything
				if (!cell.IsNull) {
					string expression = cell.AsVarChar().Value.ToString();
					// We must remove the head of the string, which has already been
					// found from the pre-search section.
					expression = expression.Substring(preIndex);
					patternMatches = PatternSearch.PatternMatch(postPattern, expression, escapeChar);
				}
				if (!patternMatches) {
					// If pattern does not match then remove this row from the search.
					enumerator.Remove();
				}
			}

			return iList.ToList();
		}

		public static ITable EmptySelect(this ITable table) {
			if (table.RowCount == 0)
				return table;

			return new VirtualTable(table, new int[0]);
		}

		public static ITable Distinct(this ITable table, int[] columns) {
			List&lt;int&gt; resultList = new List&lt;int&gt;();
			var rowList = table.OrderedRows(columns).ToList();

			int rowCount = rowList.Count;
			int previousRow = -1;
			for (int i = 0; i &lt; rowCount; ++i) {
				int rowIndex = rowList[i];

				if (previousRow != -1) {

					bool equal = true;
					// Compare cell in column in this row with previous row.
					for (int n = 0; n &lt; columns.Length &amp;&amp; equal; ++n) {
						var c1 = table.GetValue(columns[n], rowIndex);
						var c2 = table.GetValue(columns[n], previousRow);
						equal = (c1.CompareTo(c2) == 0);
					}

					if (!equal) {
						resultList.Add(rowIndex);
					}
				} else {
					resultList.Add(rowIndex);
				}

				previousRow = rowIndex;
			}

			// Return the new table with distinct rows only.
			return new VirtualTable(table, resultList);
		}


		#region Sub-Query

		public static ITable AnyAllNonCorrelated(this ITable table, ObjectName[] leftColumns, SqlExpressionType op, ITable rightTable) {
			if (rightTable.TableInfo.ColumnCount != leftColumns.Length) {
				throw new ArgumentException(String.Format(&quot;The right table has {0} columns that is different from the specified column names ({1})&quot;,
						rightTable.TableInfo.ColumnCount, leftColumns.Length));
			}

			// Handle trivial case of no entries to select from
			if (table.RowCount == 0)
				return table;

			// Resolve the vars in the left table and check the references are
			// compatible.
			var sz = leftColumns.Length;
			var leftColMap = new int[sz];
			var rightColMap = new int[sz];
			for (int i = 0; i &lt; sz; ++i) {
				leftColMap[i] = table.FindColumn(leftColumns[i]);
				rightColMap[i] = i;

				if (leftColMap[i] == -1)
					throw new Exception(&quot;Invalid reference: &quot; + leftColumns[i]);

				var leftType = table.TableInfo[leftColMap[i]].ColumnType;
				var rightType = rightTable.TableInfo[i].ColumnType;
				if (!leftType.IsComparable(rightType)) {
					throw new ArgumentException(String.Format(&quot;The type of the sub-query expression {0}({1}) &quot; +
					                                          &quot;is not compatible with the sub-query type {2}.&quot;,
															  leftColumns[i], leftType, rightType));
				}
			}

			IEnumerable&lt;int&gt; rows;

			if (!op.IsSubQuery())
				throw new ArgumentException(String.Format(&quot;The operator {0} is not a sub-query form.&quot;, op));

			if (op.IsAll()) {
				// ----- ALL operation -----
				// We work out as follows:
				//   For &gt;, &gt;= type ALL we find the highest value in &#39;table&#39; and
				//   select from &#39;source&#39; all the rows that are &gt;, &gt;= than the
				//   highest value.
				//   For &lt;, &lt;= type ALL we find the lowest value in &#39;table&#39; and
				//   select from &#39;source&#39; all the rows that are &lt;, &lt;= than the
				//   lowest value.
				//   For = type ALL we see if &#39;table&#39; contains a single value.  If it
				//   does we select all from &#39;source&#39; that equals the value, otherwise an
				//   empty table.
				//   For &lt;&gt; type ALL we use the &#39;not in&#39; algorithm.

				if (op == SqlExpressionType.AllGreaterThan || 
					op == SqlExpressionType.AllGreaterOrEqualThan) {
					// Select the last from the set (the highest value),
					var highestCells = rightTable.GetLastValues(rightColMap);
					// Select from the source table all rows that are &gt; or &gt;= to the
					// highest cell,
					rows = table.SelectRows(leftColMap, op, highestCells);
				} else if (op == SqlExpressionType.AllSmallerThan || 
					op == SqlExpressionType.AllSmallerOrEqualThan) {
					// Select the first from the set (the lowest value),
					var lowestCells = rightTable.GetFirstValues(rightColMap);
					// Select from the source table all rows that are &lt; or &lt;= to the
					// lowest cell,
					rows = table.SelectRows(leftColMap, op, lowestCells);
				} else if (op == SqlExpressionType.AllEqual) {
					// Select the single value from the set (if there is one).
					var singleCell = rightTable.GetSingleValues(rightColMap);
					if (singleCell != null) {
						// Select all from source_table all values that = this cell
						rows = table.SelectRows(leftColMap, op, singleCell);
					} else {
						// No single value so return empty set (no value in LHS will equal
						// a value in RHS).
						return table.EmptySelect();
					}
				} else if (op == SqlExpressionType.AllNotEqual) {
					// Equiv. to NOT IN
					rows = table.RowsNotIn(rightTable, leftColMap, rightColMap);
				} else {
					throw new ArgumentException(String.Format(&quot;Operator of type {0} is not valid in ALL functions.&quot;, op.SubQueryPlainType()));
				}
			} else {
				// ----- ANY operation -----
				// We work out as follows:
				//   For &gt;, &gt;= type ANY we find the lowest value in &#39;table&#39; and
				//   select from &#39;source&#39; all the rows that are &gt;, &gt;= than the
				//   lowest value.
				//   For &lt;, &lt;= type ANY we find the highest value in &#39;table&#39; and
				//   select from &#39;source&#39; all the rows that are &lt;, &lt;= than the
				//   highest value.
				//   For = type ANY we use same method from INHelper.
				//   For &lt;&gt; type ANY we iterate through &#39;source&#39; only including those
				//   rows that a &lt;&gt; query on &#39;table&#39; returns size() != 0.

				if (op == SqlExpressionType.AnyGreaterThan || 
					op == SqlExpressionType.AnyGreaterOrEqualThan) {
					// Select the first from the set (the lowest value),
					var lowestCells = rightTable.GetFirstValues(rightColMap);
					// Select from the source table all rows that are &gt; or &gt;= to the
					// lowest cell,
					rows = table.SelectRows(leftColMap, op, lowestCells);
				} else if (op == SqlExpressionType.AnySmallerThan || 
					op == SqlExpressionType.AnySmallerOrEqualThan) {
					// Select the last from the set (the highest value),
					var highestCells = rightTable.GetLastValues(rightColMap);
					// Select from the source table all rows that are &lt; or &lt;= to the
					// highest cell,
					rows = table.SelectRows(leftColMap, op, highestCells);
				} else if (op == SqlExpressionType.AnyEqual) {
					// Equiv. to IN
					rows = table.In(rightTable, leftColMap, rightColMap);
				} else if (op == SqlExpressionType.AnyNotEqual) {
					// Select the value that is the same of the entire column
					var cells = rightTable.GetSingleValues(rightColMap);
					if (cells != null) {
						// All values from &#39;source_table&#39; that are &lt;&gt; than the given cell.
						rows = table.SelectRows(leftColMap, op, cells);
					} else {
						// No, this means there are different values in the given set so the
						// query evaluates to the entire table.
						return table;
					}
				} else {
					throw new ArgumentException(String.Format(&quot;Operator of type {0} is not valid in ANY functions.&quot;, op.SubQueryPlainType()));
				}
			}

			return new VirtualTable(table, rows);
		}

		public static ITable Outer(this ITable table, ITable rightTable) {
			// Form the row list for right hand table,
			var rowList = rightTable.Select(x =&gt; x.RowId.RowNumber).ToList();

			int colIndex = rightTable.IndexOfColumn(table.GetResolvedColumnName(0));
			rowList = rightTable.ResolveRows(colIndex, rowList, table).ToList();

			// This row set
			var thisTableSet = table.Select(x =&gt; x.RowId.RowNumber).ToList();

			thisTableSet.Sort();
			rowList.Sort();

			// Find all rows that are in &#39;this table&#39; and not in &#39;right&#39;
			List&lt;int&gt; resultList = new List&lt;int&gt;(96);
			int size = thisTableSet.Count;
			int rowListIndex = 0;
			int rowListSize = rowList.Count;
			for (int i = 0; i &lt; size; ++i) {
				int thisVal = thisTableSet[i];
				if (rowListIndex &lt; rowListSize) {
					int inVal = rowList[rowListIndex];
					if (thisVal &lt; inVal) {
						resultList.Add(thisVal);
					} else if (thisVal == inVal) {
						while (rowListIndex &lt; rowListSize &amp;&amp;
						       rowList[rowListIndex] == inVal) {
							++rowListIndex;
						}
					} else {
						throw new ApplicationException(&quot;&#39;this_val&#39; &gt; &#39;in_val&#39;&quot;);
					}
				} else {
					resultList.Add(thisVal);
				}
			}

			// Return the new VirtualTable
			return new VirtualTable(table, resultList);
		}

		public static ITable Union(this ITable thisTable, ITable otherTable) {
			// Optimizations - handle trivial case of row count in one of the tables
			//   being 0.
			// NOTE: This optimization assumes this table and the unioned table are
			//   of the same type.
			if ((thisTable.RowCount == 0 &amp;&amp; otherTable.RowCount == 0) ||
				 otherTable.RowCount == 0) {
				return thisTable;
			}

			if (thisTable.RowCount == 0)
				return otherTable;

			// First we merge this table with the input table.

			var raw1 = thisTable.GetRawTableInfo();
			var raw2 = otherTable.GetRawTableInfo();

			// This will throw an exception if the table types do not match up.

			var union = raw1.Union(raw2);

			// Now &#39;union&#39; contains a list of uniquely merged rows (ie. the union).
			// Now make it into a new table and return the information.

			var tableList = union.GetTables().AsEnumerable();
			return new VirtualTable(tableList, union.GetRows());
		}

		/// &lt;summary&gt;
		/// This implements the &lt;c&gt;in&lt;/c&gt; command.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;table1&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;table2&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;column1&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;column2&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns the rows selected from &lt;paramref name=&quot;table1&quot;/&gt;.
		/// &lt;/returns&gt;
		public static IEnumerable&lt;int&gt; In(this ITable table, ITable table2, int column1, int column2) {
			// First pick the the smallest and largest table.  We only want to iterate
			// through the smallest table.
			// NOTE: This optimisation can&#39;t be performed for the &#39;not_in&#39; command.

			ITable smallTable;
			ITable largeTable;
			int smallColumn;
			int largeColumn;

			if (table.RowCount &lt; table2.RowCount) {
				smallTable = table;
				largeTable = table2;

				smallColumn = column1;
				largeColumn = column2;

			} else {
				smallTable = table2;
				largeTable = table;

				smallColumn = column2;
				largeColumn = column1;
			}

			// Iterate through the small table&#39;s column.  If we can find identical
			// cells in the large table&#39;s column, then we should include the row in our
			// final result.

			var resultRows = new BlockIndex&lt;int&gt;();
			var op = SqlExpressionType.Equal;

			foreach (var row in smallTable) {
				var cell = row.GetValue(smallColumn);

				var selectedSet = largeTable.SelectRows(largeColumn, op, cell).ToList();

				// We&#39;ve found cells that are IN both columns,

				if (selectedSet.Count &gt; 0) {
					// If the large table is what our result table will be based on, append
					// the rows selected to our result set.  Otherwise add the index of
					// our small table.  This only works because we are performing an
					// EQUALS operation.

					if (largeTable == table) {
						// Only allow unique rows into the table set.
						int sz = selectedSet.Count;
						bool rs = true;
						for (int i = 0; rs &amp;&amp; i &lt; sz; ++i) {
							rs = resultRows.UniqueInsertSort(selectedSet[i]);
						}
					} else {
						// Don&#39;t bother adding in sorted order because it&#39;s not important.
						resultRows.Add(row.RowId.RowNumber);
					}
				}
			}

			return resultRows.ToList();
		}

		/// &lt;summary&gt;
		/// A multi-column version of &lt;c&gt;IN&lt;/c&gt;.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;table1&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;table2&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;t1Cols&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;t2Cols&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static IEnumerable&lt;int&gt; In(this ITable table, ITable table2, int[] t1Cols, int[] t2Cols) {
			if (t1Cols.Length &gt; 1)
				throw new NotSupportedException(&quot;Multi-column &#39;in&#39; not supported yet.&quot;);

			return table.In(table2, t1Cols[0], t2Cols[0]);
		}

		/// &lt;summary&gt;
		/// This implements the &lt;c&gt;not in&lt;/c&gt; command.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;table1&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;table2&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;col1&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;col2&quot;&gt;&lt;/param&gt;
		/// &lt;remarks&gt;
		/// &lt;b&gt;Issue&lt;/b&gt;: This will be less efficient than &lt;see cref=&quot;In(Table,Table,int,int)&quot;&gt;in&lt;/see&gt; 
		/// if &lt;paramref name=&quot;table1&quot;/&gt; has many rows and &lt;paramref name=&quot;table2&quot;/&gt; has few rows.
		/// &lt;/remarks&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static IEnumerable&lt;int&gt; RowsNotIn(this ITable table, ITable table2, int col1, int col2) {
			// Handle trivial cases
			int t2RowCount = table2.RowCount;
			if (t2RowCount == 0)
				// No rows so include all rows.
				return table.SelectAllRows(col1);

			if (t2RowCount == 1) {
				// 1 row so select all from table1 that doesn&#39;t equal the value.
				var en = table2.GetEnumerator();
				if (!en.MoveNext())
					throw new InvalidOperationException(&quot;Cannot iterate through table rows.&quot;);

				var cell = table2.GetValue(en.Current.RowId.RowNumber, col2);
				return table.SelectRows(col1, SqlExpressionType.NotEqual, cell);
			}

			// Iterate through table1&#39;s column.  If we can find identical cell in the
			// tables&#39;s column, then we should not include the row in our final
			// result.
			List&lt;int&gt; resultRows = new List&lt;int&gt;();

			foreach (var row in table) {
				int rowIndex = row.RowId.RowNumber;
				var cell = row.GetValue(col1);

				var selectedSet = table2.SelectRows(col2, SqlExpressionType.Equal, cell);

				// We&#39;ve found a row in table1 that doesn&#39;t have an identical cell in
				// table2, so we should include it in the result.

				if (!selectedSet.Any())
					resultRows.Add(rowIndex);
			}

			return resultRows;
		}

		/// &lt;summary&gt;
		/// A multi-column version of NOT IN.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;table1&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;table2&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;t1Cols&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;t2Cols&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static IEnumerable&lt;int&gt; RowsNotIn(this ITable table, ITable table2, int[] t1Cols, int[] t2Cols) {
			if (t1Cols.Length &gt; 1)
				throw new NotSupportedException(&quot;Multi-column &#39;not in&#39; not supported yet.&quot;);

			return table.RowsNotIn(table2, t1Cols[0], t2Cols[0]);
		}

		public static ITable NotIn(this ITable table, ITable otherTable, int[] tableColumns, int[] otherColumns) {
			return table.AsVirtual(() =&gt; RowsNotIn(table, otherTable, tableColumns, otherColumns));
		}

		#endregion

		private static ITable AsVirtual(this ITable table, Func&lt;IEnumerable&lt;int&gt;&gt; selector) {
			return new VirtualTable(table, selector());
		}

		#region Order By

		public static IEnumerable&lt;int&gt; OrderedRows(this ITable table, int[] columns) {
			var work = table.OrderByColumns(columns);
			// &#39;work&#39; is now sorted by the columns,
			// Get the rows in this tables domain,
			var rowList = work.Select(row =&gt; row.RowId.RowNumber);

			return work.ResolveRows(0, rowList, table);
		}


		public static ITable OrderByColumns(this ITable table, int[] columns) {
			// Sort by the column list.
			ITable resultTable = table;
			for (int i = columns.Length - 1; i &gt;= 0; --i) {
				resultTable = resultTable.OrderByColumn(columns[i], true);
			}

			// A nice post condition to check on.
			if (resultTable.RowCount != table.RowCount)
				throw new ApplicationException(&quot;The final row count mismatches.&quot;);

			return table;
		}

		public static ITable OrderByColumn(this ITable table, int columnIndex, bool ascending) {
			if (table == null)
				return null;

			var rows = table.SelectAllRows(columnIndex);

			// Reverse the list if we are not ascending
			if (ascending == false)
				rows = rows.Reverse();

			return new VirtualTable(table, rows);
		}

		public static ITable OrderByColumn(this ITable table, ObjectName columnName, bool ascending) {
			var columnOffset = table.IndexOfColumn(columnName);
			if (columnOffset == -1)
				throw new ArgumentException(String.Format(&quot;Column &#39;{0}&#39; was not found in table.&quot;, columnName));

			return table.OrderByColumn(columnOffset, ascending);
		}

		#endregion

		public static ITable ColumnMerge(this ITable table, ITable other) {
			if (table.RowCount != other.RowCount)
				throw new ApplicationException(&quot;Tables have different row counts.&quot;);

			// Create the new VirtualTable with the joined tables.

			List&lt;int&gt; allRowSet = new List&lt;int&gt;();
			int rcount = table.RowCount;
			for (int i = 0; i &lt; rcount; ++i) {
				allRowSet.Add(i);
			}

			var tabs = new[] { table, other };
			var rowSets = new IEnumerable&lt;int&gt;[] { allRowSet, allRowSet };

			return new VirtualTable(tabs, rowSets);
		}

		public static Dictionary&lt;string, ISqlObject&gt; ToDictionary(this ITable table) {
			if (table.TableInfo.ColumnCount != 2)
				throw new NotSupportedException(&quot;Table must have two columns.&quot;);

			var map = new Dictionary&lt;string, ISqlObject&gt;();
			foreach (var row in table) {
				var key = row.GetValue(0);
				var value = row.GetValue(1);
				map[key.AsVarChar().Value.ToString()] = value.Value;
			}

			return map;
		}

		#region Join

		public static ITable Join(this ITable table, ITable otherTable, bool quick) {
			ITable outTable;

			if (quick) {
				// This implementation doesn&#39;t materialize the join
				outTable = new NaturallyJoinedTable(table, otherTable);
			} else {
				var tabs = new [] { table, otherTable};
				var rowSets = new IList&lt;int&gt;[2];

				// Optimized trivial case, if either table has zero rows then result of
				// join will contain zero rows also.
				if (table.RowCount == 0 || otherTable.RowCount == 0) {
					rowSets[0] = new List&lt;int&gt;(0);
					rowSets[1] = new List&lt;int&gt;(0);
				} else {
					// The natural join algorithm.
					List&lt;int&gt; thisRowSet = new List&lt;int&gt;();
					List&lt;int&gt; tableRowSet = new List&lt;int&gt;();

					// Get the set of all rows in the given table.
					var tableSelectedSet = otherTable.Select(x =&gt; x.RowId.RowNumber).ToList();

					int tableSelectedSetSize = tableSelectedSet.Count;

					// Join with the set of rows in this table.
					var e = table.GetEnumerator();
					while (e.MoveNext()) {
						int rowIndex = e.Current.RowId.RowNumber;
						for (int i = 0; i &lt; tableSelectedSetSize; ++i) {
							thisRowSet.Add(rowIndex);
						}

						tableRowSet.AddRange(tableSelectedSet);
					}

					// The row sets we are joining from each table.
					rowSets[0] = thisRowSet;
					rowSets[1] = tableRowSet;
				}

				// Create the new VirtualTable with the joined tables.
				outTable = new VirtualTable(tabs, rowSets);
			}

			return outTable;
		}

		public static ITable Join(this ITable table, ITable otherTable) {
			return table.Join(otherTable, true);
		}

		public static ITable SimpleJoin(this ITable thisTable, IQueryContext context, ITable other, SqlBinaryExpression binary) {
			var objRef = binary.Left as SqlReferenceExpression;
			if (objRef == null)
				throw new ArgumentException();

			// Find the row with the name given in the condition.
			int lhsColumn = thisTable.FindColumn(objRef.ReferenceName);

			if (lhsColumn == -1)
				throw new Exception(&quot;Unable to find the LHS column specified in the condition: &quot; + objRef.ReferenceName);

			// Create a variable resolver that can resolve columns in the destination
			// table.
			var resolver = other.GetVariableResolver();

			// The join algorithm.  It steps through the RHS expression, selecting the
			// cells that match the relation from the LHS table (this table).

			var thisRowSet = new List&lt;int&gt;();
			var tableRowSet = new List&lt;int&gt;();

			var e = other.GetEnumerator();

			while (e.MoveNext()) {
				int rowIndex = e.Current.RowId.RowNumber;

				// Select all the rows in this table that match the joining condition.
				var selectedSet = thisTable.SelectRows(resolver, context, binary);

				var selectList = selectedSet.ToList();

				var size = selectList.Count;
				// Include in the set.
				for (int i = 0; i &lt; size; i++) {
					tableRowSet.Add(rowIndex);
				}

				thisRowSet.AddRange(selectList);
			}

			// Create the new VirtualTable with the joined tables.

			var tabs = new[] {thisTable, other};
			var rowSets = new[] {thisRowSet.AsEnumerable(), tableRowSet.AsEnumerable()};

			return new VirtualTable(tabs, rowSets);
		}

		#endregion

		public static bool RemoveRow(this IMutableTable table, int rowIndex) {
			return table.RemoveRow(new RowId(table.TableInfo.Id, rowIndex));
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[57,5,57,70,0],[70,5,70,35,0],[81,5,81,18,0],[92,4,92,40,0],[96,4,96,65,0],[100,4,100,29,0],[101,5,101,44,0],[102,3,102,4,0],[105,4,105,29,0],[106,5,106,46,0],[107,3,107,4,0],[110,4,110,54,0],[114,4,114,29,0],[115,5,115,56,0],[117,4,117,38,0],[129,4,129,73,0],[133,4,133,55,0],[134,4,134,73,0],[138,4,138,33,0],[139,5,139,69,0],[141,4,141,56,0],[145,4,145,56,0],[146,4,146,73,0],[150,4,150,33,0],[151,5,151,69,0],[153,4,153,57,0],[157,4,157,63,0],[158,4,158,24,0],[159,4,159,89,0],[163,4,163,33,0],[164,5,164,69,0],[166,4,166,58,0],[183,4,183,24,0],[186,9,186,24,0],[187,5,187,26,0],[189,10,189,20,0],[190,6,190,42,0],[191,6,191,36,0],[192,6,192,75,0],[195,7,195,24,0],[197,7,197,13,0],[189,34,189,37,0],[189,21,189,32,0],[186,33,186,36,0],[186,25,186,31,0],[202,4,202,16,0],[206,4,206,72,0],[207,5,207,59,0],[209,4,209,62,0],[210,4,210,45,0],[214,4,214,29,0],[215,5,215,75,0],[217,4,217,53,0],[226,5,226,15,0],[236,4,236,73,0],[240,4,240,33,0],[240,74,240,76,0],[245,4,245,33,0],[245,73,245,75,0],[249,4,249,62,0],[253,4,253,85,0],[270,4,270,54,0],[278,4,278,84,0],[282,4,282,68,0],[286,4,286,91,0],[290,4,290,58,0],[294,4,294,81,0],[298,4,298,65,0],[302,4,302,92,0],[306,4,306,52,0],[310,4,310,29,0],[310,46,310,48,0],[314,4,314,33,0],[314,66,314,68,0],[318,4,318,53,0],[322,4,322,54,0],[330,4,330,85,0],[335,4,335,33,0],[336,5,336,80,0],[338,4,338,61,0],[343,4,343,53,0],[344,4,345,41,0],[347,5,347,29,0],[350,4,350,66,0],[358,5,358,29,0],[368,4,368,41,0],[369,5,369,40,0],[370,4,370,44,0],[371,5,371,39,0],[372,4,372,44,0],[373,5,373,36,0],[374,4,374,51,0],[375,5,375,46,0],[376,4,376,51,0],[377,5,377,43,0],[381,4,381,39,0],[382,4,382,45,0],[383,4,383,49,0],[391,4,391,59,0],[392,4,392,23,0],[393,5,393,39,0],[395,4,395,42,0],[397,4,397,46,0],[398,4,398,19,0],[399,5,399,43,0],[401,4,401,63,0],[402,4,402,61,0],[403,5,403,43,0],[405,4,405,56,0],[406,4,406,48,0],[408,4,408,56,0],[416,5,416,116,0],[422,5,423,55,0],[424,6,424,36,0],[428,5,428,58,0],[429,6,429,52,0],[430,6,430,32,0],[431,7,431,40,0],[432,7,432,20,0],[434,7,434,67,0],[437,6,437,52,0],[442,5,442,39,0],[443,5,443,106,0],[445,32,445,36,0],[445,14,445,28,0],[446,6,446,35,0],[448,6,448,84,0],[449,6,449,48,0],[445,29,445,31,0],[452,5,452,27,0],[456,5,456,72,0],[461,6,461,76,0],[465,6,465,44,0],[482,6,482,56,0],[488,7,489,29,0],[501,4,501,32,0],[502,5,502,22,0],[505,4,505,45,0],[507,5,507,36,0],[510,4,511,44,0],[513,5,513,22,0],[518,4,518,53,0],[520,4,520,21,0],[521,5,523,25,0],[527,4,527,53,0],[530,4,530,51,0],[533,4,533,31,0],[535,4,535,18,0],[556,7,556,41,0],[574,4,574,18,0],[575,5,575,28,0],[577,4,577,40,0],[586,5,586,66,0],[588,5,588,45,0],[589,5,589,99,0],[590,5,590,80,0],[591,5,591,51,0],[592,5,592,20,0],[593,5,593,34,0],[594,10,594,20,0],[595,6,595,31,0],[597,6,597,41,0],[598,7,598,26,0],[594,31,594,34,0],[594,21,594,29,0],[601,5,601,22,0],[605,4,605,47,0],[621,4,621,47,0],[625,4,625,53,0],[628,4,628,33,0],[629,5,629,103,0],[632,4,632,39,0],[633,4,633,49,0],[634,5,634,57,0],[636,4,636,44,0],[644,4,644,51,0],[645,4,645,14,0],[646,4,646,40,0],[647,4,647,30,0],[650,5,650,25,0],[651,5,651,22,0],[652,6,652,26,0],[653,6,653,27,0],[654,12,654,32,0],[655,6,655,26,0],[656,12,656,45,0],[657,6,657,27,0],[659,6,659,10,0],[660,6,660,30,0],[661,7,661,23,0],[665,6,665,22,0],[649,4,649,21,0],[676,4,676,28,0],[680,5,680,64,0],[681,5,681,68,0],[684,4,685,34,0],[692,5,692,46,0],[693,5,693,27,0],[703,5,703,45,0],[704,5,704,42,0],[705,5,705,40,0],[706,5,706,45,0],[708,5,708,40,0],[710,5,710,73,0],[711,5,711,73,0],[715,5,715,68,0],[720,4,720,21,0],[729,4,729,48,0],[730,4,730,61,0],[735,5,735,33,0],[736,5,736,59,0],[738,5,738,22,0],[739,6,739,60,0],[742,6,742,50,0],[743,6,743,87,0],[745,5,745,25,0],[747,6,747,26,0],[732,4,732,33,0],[751,4,751,26,0],[755,4,755,28,0],[756,5,756,18,0],[758,4,758,47,0],[762,4,762,43,0],[763,4,763,54,0],[765,4,765,33,0],[766,4,766,25,0],[767,9,767,19,0],[768,5,768,31,0],[770,5,770,27,0],[772,6,772,24,0],[774,11,774,21,0],[775,7,775,53,0],[776,7,776,56,0],[777,7,777,39,0],[774,51,774,54,0],[774,22,774,49,0],[780,6,780,17,0],[781,7,781,32,0],[784,6,784,31,0],[787,5,787,28,0],[767,34,767,37,0],[767,20,767,32,0],[791,4,791,47,0],[798,4,798,63,0],[799,5,800,62,0],[804,4,804,28,0],[805,5,805,18,0],[809,4,809,32,0],[810,4,810,33,0],[811,4,811,34,0],[812,9,812,19,0],[813,5,813,54,0],[814,5,814,24,0],[816,5,816,29,0],[817,6,817,66,0],[819,5,819,62,0],[820,5,820,56,0],[821,5,821,43,0],[822,6,824,56,0],[812,28,812,31,0],[812,20,812,26,0],[830,4,830,25,0],[831,5,831,97,0],[833,4,833,19,0],[847,5,848,52,0],[850,6,850,63,0],[853,6,853,60,0],[854,12,855,52,0],[857,6,857,63,0],[860,6,860,59,0],[861,12,861,49,0],[863,6,863,63,0],[864,6,864,29,0],[866,7,866,59,0],[870,7,870,34,0],[872,12,872,52,0],[874,6,874,66,0],[876,6,876,128,0],[891,5,892,52,0],[894,6,894,63,0],[897,6,897,59,0],[898,12,899,52,0],[901,6,901,63,0],[904,6,904,60,0],[905,12,905,49,0],[907,6,907,59,0],[908,12,908,52,0],[910,6,910,58,0],[911,6,911,24,0],[913,7,913,54,0],[917,7,917,20,0],[920,6,920,128,0],[924,4,924,41,0],[929,4,929,41,0],[929,58,929,69,0],[931,4,931,76,0],[932,4,932,72,0],[935,4,935,41,0],[935,58,935,69,0],[937,4,937,24,0],[938,4,938,19,0],[941,4,941,45,0],[942,4,942,34,0],[943,4,943,25,0],[944,4,944,36,0],[945,9,945,19,0],[946,5,946,35,0],[947,5,947,36,0],[948,6,948,40,0],[949,6,949,26,0],[950,7,950,31,0],[951,13,951,34,0],[954,8,954,23,0],[952,7,953,45,0],[957,7,957,63,0],[960,6,960,30,0],[945,30,945,33,0],[945,20,945,28,0],[965,4,965,47,0],[973,4,974,31,0],[975,5,975,22,0],[978,4,978,32,0],[979,5,979,23,0],[983,4,983,43,0],[984,4,984,44,0],[988,4,988,33,0],[993,4,993,53,0],[994,4,994,56,0],[1017,4,1017,41,0],[1018,5,1018,24,0],[1019,5,1019,25,0],[1021,5,1021,27,0],[1022,5,1022,27,0],[1025,5,1025,25,0],[1026,5,1026,24,0],[1028,5,1028,27,0],[1029,5,1029,27,0],[1036,4,1036,43,0],[1037,4,1037,37,0],[1039,24,1039,34,0],[1039,13,1039,20,0],[1040,5,1040,42,0],[1042,5,1042,77,0],[1046,5,1046,31,0],[1052,6,1052,30,0],[1054,7,1054,34,0],[1055,7,1055,22,0],[1056,12,1056,22,0],[1057,8,1057,57,0],[1056,37,1056,40,0],[1056,23,1056,35,0],[1061,7,1061,43,0],[1039,21,1039,23,0],[1066,4,1066,31,0],[1078,4,1078,26,0],[1079,5,1079,77,0],[1081,4,1081,50,0],[1098,4,1098,37,0],[1099,4,1099,24,0],[1101,5,1101,38,0],[1103,4,1103,24,0],[1105,5,1105,37,0],[1106,5,1106,24,0],[1107,6,1107,80,0],[1109,5,1109,66,0],[1110,5,1110,69,0],[1116,4,1116,43,0],[1118,24,1118,29,0],[1118,13,1118,20,0],[1119,5,1119,40,0],[1120,5,1120,35,0],[1122,5,1122,78,0],[1127,5,1127,28,0],[1128,6,1128,31,0],[1118,21,1118,23,0],[1131,4,1131,22,0],[1143,4,1143,26,0],[1144,5,1144,81,0],[1146,4,1146,57,0],[1150,4,1150,33,0],[1150,89,1150,91,0],[1156,4,1156,47,0],[1162,4,1162,45,0],[1165,4,1165,37,0],[1165,56,1165,58,0],[1167,4,1167,47,0],[1173,4,1173,31,0],[1174,9,1174,36,0],[1175,5,1175,63,0],[1174,45,1174,48,0],[1174,37,1174,43,0],[1179,4,1179,47,0],[1180,5,1180,71,0],[1182,4,1182,17,0],[1186,4,1186,22,0],[1187,5,1187,17,0],[1189,4,1189,48,0],[1192,4,1192,27,0],[1193,5,1193,27,0],[1195,4,1195,41,0],[1199,4,1199,55,0],[1200,4,1200,27,0],[1201,5,1201,100,0],[1203,4,1203,56,0],[1209,4,1209,41,0],[1210,5,1210,73,0],[1214,4,1214,42,0],[1215,4,1215,32,0],[1216,9,1216,19,0],[1217,5,1217,22,0],[1216,32,1216,35,0],[1216,20,1216,30,0],[1220,4,1220,38,0],[1221,4,1221,66,0],[1223,4,1223,43,0],[1227,4,1227,41,0],[1228,5,1228,69,0],[1230,4,1230,51,0],[1231,24,1231,29,0],[1231,13,1231,20,0],[1232,5,1232,31,0],[1233,5,1233,33,0],[1234,5,1234,57,0],[1231,21,1231,23,0],[1237,4,1237,15,0],[1249,5,1249,44,0],[1250,5,1250,37,0],[1254,5,1254,57,0],[1255,6,1255,36,0],[1256,6,1256,36,0],[1259,6,1259,45,0],[1260,6,1260,46,0],[1263,6,1263,52,0],[1263,69,1263,80,0],[1265,6,1265,56,0],[1268,6,1268,36,0],[1270,7,1270,48,0],[1271,12,1271,22,0],[1272,8,1272,33,0],[1271,49,1271,52,0],[1271,23,1271,47,0],[1275,7,1275,46,0],[1269,6,1269,26,0],[1279,6,1279,30,0],[1280,6,1280,31,0],[1284,5,1284,48,0],[1295,4,1295,55,0],[1296,4,1296,23,0],[1297,5,1297,35,0],[1300,4,1300,63,0],[1302,4,1302,24,0],[1303,5,1303,110,0],[1307,4,1307,47,0],[1312,4,1312,37,0],[1313,4,1313,38,0],[1315,4,1315,34,0],[1318,5,1318,46,0],[1321,5,1321,71,0],[1323,5,1323,43,0],[1325,5,1325,33,0],[1327,10,1327,20,0],[1328,6,1328,32,0],[1327,31,1327,34,0],[1327,21,1327,29,0],[1331,5,1331,37,0],[1317,4,1317,24,0],[1336,4,1336,40,0],[1337,4,1337,80,0],[1339,4,1339,43,0],[1345,4,1345,68,0],[310,29,310,46,0],[929,41,929,58,0],[935,41,935,58,0],[1165,37,1165,56,0],[1263,52,1263,69,0],[240,33,240,74,0],[245,33,245,73,0],[314,33,314,66,0],[1150,33,1150,89,0],[38,4,38,29,1],[39,5,39,57,1],[41,4,41,35,1],[42,4,42,50,1],[43,5,43,15,1],[45,4,45,58,1],[49,4,49,29,1],[50,5,50,46,1],[52,4,52,39,1],[56,4,56,29,1],[59,4,59,46,1],[60,4,60,62,1],[61,4,61,49,1],[66,4,66,29,1],[67,5,67,76,1],[69,4,69,26,1],[72,4,72,25,1],[76,4,76,33,1],[77,5,77,78,1],[79,4,79,43,1],[80,4,80,27,1],[84,4,84,50,1],[88,4,88,29,1],[89,5,89,56,1],[125,4,125,69,1],[172,4,172,34,1],[176,4,176,55,1],[177,4,177,61,1],[179,4,179,21,1],[180,5,180,17,1],[221,4,221,29,1],[222,5,222,57,1],[224,4,225,61,1],[228,4,228,53,1],[232,4,232,58,1],[257,4,257,33,1],[259,4,259,66,1],[260,29,260,35,1],[260,13,260,25,1],[261,5,261,61,1],[262,5,262,38,1],[263,6,263,27,1],[260,26,260,28,1],[266,4,266,18,1],[274,4,274,61,1],[326,4,326,60,1],[355,4,355,53,1],[356,4,356,42,1],[362,4,362,39,1],[366,4,366,38,1],[367,5,367,37,1],[413,4,413,46,1],[415,4,415,21,1],[419,4,419,24,1],[460,5,460,27,1],[463,5,463,47,1],[464,5,464,62,1],[467,5,467,57,1],[471,5,474,45,1],[486,6,486,44,1],[487,6,487,31,1],[491,6,491,49,1],[494,5,494,64,1],[540,4,540,23,1],[543,4,543,34,1],[544,4,544,21,1],[545,5,545,53,1],[546,5,546,53,1],[548,25,548,30,1],[548,14,548,21,1],[549,6,549,41,1],[551,6,551,55,1],[554,6,554,58,1],[555,6,555,59,1],[558,6,558,54,1],[560,6,561,21,1],[562,7,562,33,1],[548,22,548,24,1],[566,5,566,51,1],[569,4,569,18,1],[1245,4,1245,14,1],[1247,5,1247,60,1],[1287,4,1287,20,1],[1291,4,1291,40,1]]);
    </script>
  </body>
</html>