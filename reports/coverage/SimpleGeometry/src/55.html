<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.index\indexblock.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.Linq;

using Deveel.Data.Store;
using Deveel.Data.Util;

namespace Deveel.Data.Index {
	internal class IndexBlock {
		private readonly IndexSetStore indexSetStore;
		private readonly int indexNum;
		private readonly long blockEntries;

		private List&lt;int&gt; deletedAreas; 

		private int refCount;

		public IndexBlock(IndexSetStore indexSetStore, int indexNum, int blockSize, long startOffset) {
			this.indexSetStore = indexSetStore;
			this.indexNum = indexNum;
			BlockSize = blockSize;
			StartOffset = startOffset;

			// Read the index count
			var indexBlockArea = indexSetStore.Store.GetArea(startOffset);
			indexBlockArea.Position = 8;
			blockEntries = indexBlockArea.ReadInt8();

			refCount = 0;
		}

		public IndexBlock Parent { get; set; }

		public bool IsFreed { get; private set; }

		public bool IsDeleted { get; private set; }

		public int BlockSize { get; private set; }

		public long StartOffset { get; private set; }

		public long[] GetBlockPointers() {
			// Create an area for the index block pointer
			var indexBlockArea = indexSetStore.Store.GetArea(StartOffset);

			// First create the list of block entries for this list      
			long[] blocks = new long[(int)blockEntries];
			if (blockEntries != 0) {
				indexBlockArea.Position = 16;

				for (int i = 0; i &lt; blockEntries; ++i) {
					// NOTE: We cast to &#39;int&#39; here because of internal limitations.
					indexBlockArea.ReadInt8();
					indexBlockArea.ReadInt8();
					long elementP = indexBlockArea.ReadInt8();
					indexBlockArea.ReadInt4();

					blocks[i] = elementP;
				}
			}

			return blocks;
		}

		private IEnumerable&lt;IMappedBlock&gt; CreateMappedBlocks() {
			// Create an area for the index block pointer
			var indexBlockArea = indexSetStore.Store.GetArea(StartOffset);

			// First create the list of block entries for this list      
			var blocks = new IMappedBlock[(int) blockEntries];
			if (blockEntries != 0) {
				indexBlockArea.Position = 16;
				for (int i = 0; i &lt; blockEntries; ++i) {
					// NOTE: We cast to &#39;int&#39; here because of internal limitations.
					var firstEntry = indexBlockArea.ReadInt8();
					var lastEntry = indexBlockArea.ReadInt8();
					var blockPointer = indexBlockArea.ReadInt8();
					var typeSize = indexBlockArea.ReadInt4();

					//TODO: check this...
					// size is the first 24 bits (max size = 16MB)
					int elementCount = typeSize &amp; 0x0FFF;
					byte type = (byte) (ByteBuffer.URShift(typeSize, 24) &amp; 0x0F);

					blocks[i] = StoreIndex.NewMappedBlock(indexSetStore, firstEntry, lastEntry, blockPointer, elementCount, type,
						BlockSize);
				}
			}

			return blocks;
		}

		public IIndex CreateIndex() {
			// Create the MappedListBlock objects for this view
			var blocks = CreateMappedBlocks().Cast&lt;IIndexBlock&lt;int&gt;&gt;();
			// And return the Index
			return new StoreIndex(indexSetStore, indexNum, BlockSize, blocks);
		}

		private bool DeleteBlockChain() {
			bool parentDeleted = true;
			if (Parent != null) {
				parentDeleted = Parent.DeleteBlockChain();
				if (parentDeleted) {
					Parent = null;
				}
			}

			// If the parent is deleted,
			if (parentDeleted) {
				// Can we delete this block?
				if (refCount &lt;= 0) {
					if (IsDeleted &amp;&amp; deletedAreas != null) {
						indexSetStore.DeleteAreas(deletedAreas);
					}
					deletedAreas = null;
				} else {
					// We can&#39;t delete this block so return false
					return false;
				}
			}

			return parentDeleted;
		}

		public void AddReference() {
			lock (this) {
				if (IsFreed)
					throw new Exception(&quot;Assertion failed: Block was freed.&quot;);

				++refCount;
			}
		}

		public void RemoveReference() {
			bool pendingDelete = false;
			lock (this) {
				--refCount;
				if (refCount &lt;= 0) {
					if (IsFreed)
						throw new Exception(&quot;Assertion failed: remove reference called too many times.&quot;);

					if (!IsDeleted &amp;&amp; deletedAreas != null)
						throw new Exception(&quot;Assertion failed: not deleted and with deleted areas&quot;);

					IsFreed = true;

					if (IsDeleted) {
						AddDeletedArea(StartOffset);
						// Delete these areas
						pendingDelete = true;
					}
				}
			} // lock(this)

			if (pendingDelete) {
				lock (indexSetStore.Store) {
					DeleteBlockChain();
				}
			}
		}

		public void MarkAsDeleted() {
			lock (this) {
				IsDeleted = true;
			}
		}

		public void AddDeletedArea(long pointer) {
			lock (this) {
				if (deletedAreas == null) {
					deletedAreas = new List&lt;int&gt;();
				}

				deletedAreas.Add((int)pointer);
			}
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[60,4,60,66,0],[63,4,63,48,0],[64,4,64,26,0],[65,5,65,34,0],[67,10,67,20,0],[69,6,69,32,0],[70,6,70,32,0],[71,6,71,48,0],[72,6,72,32,0],[74,6,74,27,0],[67,39,67,42,0],[67,21,67,37,0],[78,4,78,18,0],[135,6,135,19,0],[145,6,145,64,0],[157,7,157,88,0],[160,7,160,83,0],[34,3,34,96,1],[35,4,35,39,1],[36,4,36,29,1],[37,4,37,26,1],[38,4,38,30,1],[41,4,41,66,1],[42,4,42,32,1],[43,4,43,45,1],[45,4,45,17,1],[46,3,46,4,1],[83,4,83,66,1],[86,4,86,54,1],[87,4,87,26,1],[88,5,88,34,1],[89,10,89,20,1],[91,6,91,49,1],[92,6,92,48,1],[93,6,93,51,1],[94,6,94,47,1],[98,6,98,43,1],[99,6,99,67,1],[101,6,102,18,1],[89,39,89,42,1],[89,21,89,37,1],[106,4,106,18,1],[111,4,111,63,1],[113,4,113,70,1],[117,4,117,30,1],[118,4,118,23,1],[119,5,119,47,1],[120,5,120,23,1],[121,6,121,20,1],[126,4,126,22,1],[128,5,128,23,1],[129,6,129,44,1],[130,7,130,47,1],[132,6,132,26,1],[139,4,139,25,1],[143,4,143,15,1],[144,5,144,17,1],[147,5,147,16,1],[149,3,149,4,1],[152,4,152,31,1],[153,4,153,15,1],[154,5,154,16,1],[155,5,155,23,1],[156,6,156,18,1],[159,6,159,45,1],[162,6,162,21,1],[164,6,164,20,1],[165,7,165,35,1],[167,7,167,28,1],[172,4,172,22,1],[173,5,173,31,1],[174,6,174,25,1],[177,3,177,4,1],[180,4,180,15,1],[181,5,181,22,1],[183,3,183,4,1],[186,4,186,15,1],[187,5,187,30,1],[188,6,188,37,1],[191,5,191,36,1],[193,3,193,4,1]]);
    </script>
  </body>
</html>