<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.types\numerictype.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.IO;
using System.Text;

using Deveel.Data.DbSystem;
using Deveel.Data.Sql.Objects;

namespace Deveel.Data.Types {
	[Serializable]
	public sealed class NumericType : DataType, ISizeableType {
		public NumericType(SqlTypeCode sqlType, int size, byte scale) 
			: base(&quot;NUMERIC&quot;, sqlType) {
			AssertIsNumeric(sqlType);
			Size = size;
			Scale = scale;
		}

		public NumericType(SqlTypeCode sqlType)
			: this(sqlType, -1) {
		}

		public NumericType(SqlTypeCode sqlType, int size)
			: this(sqlType, size, 0) {
		}

		public int Size { get; private set; }

		public byte Scale { get; private set; }

		public override bool Equals(object obj) {
			var other = obj as NumericType;
			if (other == null)
				return false;

			return SqlType == other.SqlType &amp;&amp;
			       Size == other.Size &amp;&amp;
			       Scale == other.Scale;
		}

		public override int GetHashCode() {
			return (SqlType.GetHashCode() * Scale) + Size.GetHashCode();
		}

		private static void AssertIsNumeric(SqlTypeCode typeCode) {
			if (!IsNumericType(typeCode))
				throw new ArgumentException(String.Format(&quot;The type &#39;{0}&#39; is not a valid NUMERIC type.&quot;, typeCode));
		}

		private static int GetIntSize(SqlTypeCode sqlType) {
			switch (sqlType) {
				case SqlTypeCode.TinyInt:
					return 1;
				case SqlTypeCode.SmallInt:
					return 2;
				case SqlTypeCode.Integer:
					return 4;
				case SqlTypeCode.BigInt:
					return 8;
				default:
					return 0;
			}
		}


		private static int GetFloatSize(SqlTypeCode sqlType) {
			switch (sqlType) {
				default:
					return 0;
				case SqlTypeCode.Real:
					return 4;
				case SqlTypeCode.Float:
				case SqlTypeCode.Double:
					return 8;
			}
		}

		public override DataType Wider(DataType otherType) {
			SqlTypeCode t1SqlType = SqlType;
			SqlTypeCode t2SqlType = otherType.SqlType;
			if (t1SqlType == SqlTypeCode.Decimal) {
				return this;
			}
			if (t2SqlType == SqlTypeCode.Decimal) {
				return otherType;
			}
			if (t1SqlType == SqlTypeCode.Numeric) {
				return this;
			}
			if (t2SqlType == SqlTypeCode.Numeric) {
				return otherType;
			}

			if (t1SqlType == SqlTypeCode.Bit) {
				return otherType; // It can&#39;t be any smaller than a Bit
			}
			if (t2SqlType == SqlTypeCode.Bit) {
				return this;
			}

			int t1IntSize = GetIntSize(t1SqlType);
			int t2IntSize = GetIntSize(t2SqlType);
			if (t1IntSize &gt; 0 &amp;&amp; t2IntSize &gt; 0) {
				// Both are int types, use the largest size
				return (t1IntSize &gt; t2IntSize) ? this : otherType;
			}

			int t1FloatSize = GetFloatSize(t1SqlType);
			int t2FloatSize = GetFloatSize(t2SqlType);
			if (t1FloatSize &gt; 0 &amp;&amp; t2FloatSize &gt; 0) {
				// Both are floating types, use the largest size
				return (t1FloatSize &gt; t2FloatSize) ? this : otherType;
			}

			if (t1FloatSize &gt; t2IntSize) {
				return this;
			}
			if (t2FloatSize &gt; t1IntSize) {
				return otherType;
			}
			if (t1IntSize &gt;= t2FloatSize || t2IntSize &gt;= t1FloatSize) {
				// Must be a long (8 bytes) and a real (4 bytes), widen to a double
				return new NumericType(SqlTypeCode.Double, 8, 0);
			}

			// NOTREACHED - can&#39;t get here, the last three if statements cover
			// all possibilities.
			throw new ApplicationException(&quot;Widest type error.&quot;);
		}

		public override bool IsComparable(DataType type) {
			return type is NumericType || type is BooleanType;
		}

		public override int Compare(ISqlObject x, ISqlObject y) {
			var n1 = (SqlNumber)x;
			SqlNumber n2;

			if (y is SqlNumber) {
				n2 = (SqlNumber)y;
			} else if (y is SqlBoolean) {
				n2 = (SqlBoolean) y ? SqlNumber.One : SqlNumber.Zero;
			} else {
				throw new NotSupportedException();
			}

			return n1.CompareTo(n2);
		}

		private static SqlDateTime ToDate(long time) {
			return new SqlDateTime(time);
		}

		public override bool CanCastTo(DataType type) {
			return type.SqlType != SqlTypeCode.Array &amp;&amp;
			       type.SqlType != SqlTypeCode.ColumnType &amp;&amp;
			       type.SqlType != SqlTypeCode.RowType &amp;&amp;
			       type.SqlType != SqlTypeCode.Object;
		}

		public override DataObject CastTo(DataObject value, DataType destType) {
			var n = (SqlNumber) value.Value;
			var sqlType = destType.SqlType;
			ISqlObject casted;

			switch (sqlType) {
				case (SqlTypeCode.Bit):
				case (SqlTypeCode.Boolean):
					casted = new SqlBoolean(n.ToBoolean());
					break;
				case (SqlTypeCode.TinyInt):
				case (SqlTypeCode.SmallInt):
				case (SqlTypeCode.Integer):
					casted = new SqlNumber(n.ToInt32());
					break;
				case (SqlTypeCode.BigInt):
					casted = new SqlNumber(n.ToInt64());
					break;
				case (SqlTypeCode.Float):
				case (SqlTypeCode.Real):
				case (SqlTypeCode.Double):
					double d;
					if (n.State == NumericState.NotANumber) {
						casted = new SqlNumber(Double.NaN);
					} else if (n.State == NumericState.PositiveInfinity) {
						casted = new SqlNumber(Double.PositiveInfinity);
					} else if (n.State == NumericState.NegativeInfinity) {
						casted = new SqlNumber(Double.NegativeInfinity);
					} else {
						casted = new SqlNumber(n.ToDouble());
					}

					break;
				case (SqlTypeCode.Numeric):
				case (SqlTypeCode.Decimal):
					casted = n;
					break;
				case (SqlTypeCode.Char):
					casted = new SqlString(n.ToString().PadRight(((StringType) destType).MaxSize));
					break;
				case (SqlTypeCode.VarChar):
				case (SqlTypeCode.LongVarChar):
					casted = new SqlString(n.ToString());
					break;
				case (SqlTypeCode.Date):
				case (SqlTypeCode.Time):
				case (SqlTypeCode.TimeStamp):
					casted = ToDate(n.ToInt64());
					break;
				case (SqlTypeCode.Blob):
				case (SqlTypeCode.Binary):
				case (SqlTypeCode.VarBinary):
				case (SqlTypeCode.LongVarBinary):
					casted = new SqlBinary(n.ToByteArray());
					break;
				case (SqlTypeCode.Null):
					casted = SqlNull.Value;
					break;
				default:
					throw new InvalidCastException();
			}

			return new DataObject(destType, casted);
		}

		public override string ToString() {
			var sb = new StringBuilder(Name);
			if (Size != -1) {
				sb.Append(&#39;(&#39;);
				sb.Append(Size);
				if (Scale &gt; 0) {
					sb.Append(&#39;,&#39;);
					sb.Append(Scale);
				}

				sb.Append(&#39;)&#39;);
			}
			return sb.ToString();
		}

		public override object ConvertTo(ISqlObject obj, Type destType) {
			if (!(obj is SqlNumber))
				throw new ArgumentException();

			var number = (SqlNumber)obj;
			if (number.IsNull)
				return null;

			if (destType == typeof(byte))
				return number.ToByte();
			if (destType == typeof(short))
				return number.ToInt16();
			if (destType == typeof(int))
				return number.ToInt32();
			if (destType == typeof(long))
				return number.ToInt64();
			if (destType == typeof(float))
				return number.ToSingle();
			if (destType == typeof(double))
				return number.ToDouble();

			if (destType == typeof(bool))
				return number.ToBoolean();

			if (destType == typeof(string))
				return number.ToString();

			return base.ConvertTo(obj, destType);
		}

		public override ISqlObject Add(ISqlObject a, ISqlObject b) {
			if (!(a is SqlNumber))
				throw new ArgumentException();
			if (b is SqlNull || b.IsNull)
				return SqlNumber.Null;

			var num1 = (SqlNumber) a;
			SqlNumber num2;

			if (b is SqlBoolean) {
				if ((SqlBoolean) b) {
					num2 = SqlNumber.One;
				} else if (!(SqlBoolean) b) {
					num2 = SqlNumber.Zero;
				} else {
					num2 = SqlNumber.Null;
				}
			} else if (b is SqlNumber) {
				num2 = (SqlNumber) b;
			} else {
				throw new ArgumentException();
			}

			return num1.Add(num2);
		}

		public override ISqlObject Subtract(ISqlObject a, ISqlObject b) {
			if (!(a is SqlNumber))
				throw new ArgumentException();
			if (b is SqlNull || b.IsNull)
				return SqlNumber.Null;

			var num1 = (SqlNumber) a;
			SqlNumber num2;

			if (b is SqlBoolean) {
				if ((SqlBoolean) b) {
					num2 = SqlNumber.One;
				} else if (!(SqlBoolean) b) {
					num2 = SqlNumber.Zero;
				} else {
					num2 = SqlNumber.Null;
				}
			} else if (b is SqlNumber) {
				num2 = (SqlNumber) b;
			} else {
				throw new ArgumentException();
			}

			return num1.Subtract(num2);
		}

		public override ISqlObject Multiply(ISqlObject a, ISqlObject b) {
			if (!(a is SqlNumber) ||
				!(b is SqlNumber))
				throw new ArgumentException();
			if (b.IsNull)
				return SqlNumber.Null;

			if (a.IsNull)
				return a;

			var num1 = (SqlNumber) a;
			var num2 = (SqlNumber) b;

			return num1.Multiply(num2);
		}

		public override void SerializeObject(Stream stream, ISqlObject obj, ISystemContext systemContext) {
			var writer = new BinaryWriter(stream);

			if (obj is SqlNull) {
				writer.Write((byte)0);
			} else {
				var number = (SqlNumber) obj;
				if (obj.IsNull) {
					writer.Write((byte) 0);
				} else if (number.CanBeInt32) {
					writer.Write((byte) 1);
					writer.Write(number.ToInt32());
				} else if (number.CanBeInt64) {
					writer.Write((byte) 2);
					writer.Write(number.ToInt64());
				} else {
					var bytes = number.ToByteArray();
					writer.Write((byte) 3);
					writer.Write(number.Precision);
					writer.Write(number.Scale);
					writer.Write(bytes.Length);
					writer.Write(bytes);
				}
			}
		}

		public override ISqlObject DeserializeObject(Stream stream, ISystemContext context) {
			var reader = new BinaryReader(stream);

			var type = reader.ReadByte();
			if (type == 0)
				return SqlNumber.Null;

			if (type == 1) {
				var value = reader.ReadInt32();
				return new SqlNumber(value);
			}
			if (type == 2) {
				var value = reader.ReadInt64();
				return new SqlNumber(value);
			}
			if (type == 3) {
				var precision = reader.ReadInt32();
				var scale = reader.ReadInt32();
				var length = reader.ReadInt32();
				var bytes = reader.ReadBytes(length);
				return new SqlNumber(bytes, scale, precision);
			}

			throw new FormatException();
		}

		public override int SizeOf(ISqlObject obj) {
			if (obj is SqlNull)
				return 1;

			if (!(obj is SqlNumber))
				throw new ArgumentException(String.Format(&quot;Cannot determine the size of an object of type &#39;{0}&#39;.&quot;, obj.GetType()));

			var number = (SqlNumber) obj;

			if (number.IsNull)
				return 1;

			if (number.CanBeInt32)
				return 1 + 4;
			if (number.CanBeInt64)
				return 1+ 8;

			// Type + Scale + Precision + Byte Count
			var length = number.ToByteArray().Length;
			return 1 + 4 + 4 + 4 + length;
		}

		internal static bool IsNumericType(SqlTypeCode typeCode) {
			return typeCode == SqlTypeCode.TinyInt ||
			       typeCode == SqlTypeCode.SmallInt ||
			       typeCode == SqlTypeCode.Integer ||
			       typeCode == SqlTypeCode.BigInt ||
			       typeCode == SqlTypeCode.Real ||
			       typeCode == SqlTypeCode.Float ||
			       typeCode == SqlTypeCode.Double ||
			       typeCode == SqlTypeCode.Decimal ||
			       typeCode == SqlTypeCode.Numeric;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[34,3,35,23,0],[36,3,36,4,0],[38,3,39,28,0],[40,3,40,4,0],[47,4,47,35,0],[48,4,48,22,0],[49,5,49,18,0],[51,4,53,32,0],[57,4,57,64,0],[62,5,62,105,0],[66,4,66,20,0],[68,6,68,15,0],[70,6,70,15,0],[72,6,72,15,0],[74,6,74,15,0],[76,6,76,15,0],[82,4,82,20,0],[84,6,84,15,0],[86,6,86,15,0],[89,6,89,15,0],[97,5,97,17,0],[100,5,100,22,0],[109,4,109,37,0],[110,5,110,22,0],[112,4,112,37,0],[113,5,113,17,0],[116,4,116,42,0],[117,4,117,42,0],[118,4,118,39,0],[120,5,120,55,0],[123,4,123,46,0],[124,4,124,46,0],[125,4,125,43,0],[127,5,127,59,0],[130,4,130,32,0],[131,5,131,17,0],[133,4,133,32,0],[134,5,134,22,0],[136,4,136,61,0],[138,5,138,54,0],[143,4,143,57,0],[156,11,156,31,0],[157,5,157,58,0],[159,5,159,39,0],[166,4,166,33,0],[199,7,199,42,0],[201,7,201,55,0],[203,7,203,55,0],[211,6,211,17,0],[212,6,212,12,0],[214,6,214,85,0],[215,6,215,12,0],[223,6,223,35,0],[224,6,224,12,0],[229,6,229,46,0],[230,6,230,12,0],[232,6,232,29,0],[233,6,233,12,0],[235,6,235,39,0],[242,4,242,37,0],[243,4,243,19,0],[244,5,244,20,0],[245,5,245,21,0],[246,5,246,19,0],[247,6,247,21,0],[248,6,248,23,0],[251,5,251,20,0],[253,4,253,25,0],[258,5,258,35,0],[262,5,262,17,0],[265,5,265,28,0],[267,5,267,29,0],[270,4,270,33,0],[271,5,271,29,0],[272,4,272,34,0],[273,5,273,30,0],[274,4,274,35,0],[275,5,275,30,0],[277,4,277,33,0],[278,5,278,31,0],[280,4,280,35,0],[281,5,281,30,0],[283,4,283,41,0],[288,5,288,35,0],[290,5,290,27,0],[298,12,298,32,0],[299,6,299,28,0],[301,6,301,28,0],[306,5,306,35,0],[314,5,314,35,0],[316,5,316,27,0],[324,12,324,32,0],[325,6,325,28,0],[327,6,327,28,0],[332,5,332,35,0],[341,5,341,35,0],[343,5,343,27,0],[346,5,346,14,0],[362,6,362,29,0],[367,6,367,29,0],[368,6,368,37,0],[385,5,385,27,0],[392,5,392,36,0],[393,5,393,33,0],[403,4,403,32,0],[411,5,411,120,0],[416,5,416,14,0],[421,5,421,17,0],[27,3,28,30,1],[29,4,29,29,1],[30,4,30,16,1],[31,4,31,18,1],[32,3,32,4,1],[61,4,61,33,1],[63,3,63,4,1],[94,4,94,36,1],[95,4,95,46,1],[96,4,96,41,1],[99,4,99,41,1],[102,4,102,41,1],[103,5,103,17,1],[105,4,105,41,1],[106,5,106,22,1],[147,4,147,54,1],[151,4,151,26,1],[154,4,154,23,1],[155,5,155,23,1],[162,4,162,28,1],[170,4,173,46,1],[177,4,177,36,1],[178,4,178,35,1],[181,4,181,20,1],[184,6,184,45,1],[185,6,185,12,1],[189,6,189,42,1],[190,6,190,12,1],[192,6,192,42,1],[193,6,193,12,1],[198,6,198,45,1],[200,13,200,58,1],[202,13,202,58,1],[205,7,205,44,1],[208,6,208,12,1],[218,6,218,43,1],[219,6,219,12,1],[238,4,238,44,1],[257,4,257,28,1],[260,4,260,32,1],[261,4,261,22,1],[264,4,264,33,1],[266,4,266,34,1],[268,4,268,32,1],[269,5,269,29,1],[287,4,287,26,1],[289,4,289,33,1],[292,4,292,29,1],[295,4,295,24,1],[296,5,296,24,1],[297,6,297,27,1],[303,11,303,30,1],[304,5,304,26,1],[309,4,309,26,1],[313,4,313,26,1],[315,4,315,33,1],[318,4,318,29,1],[321,4,321,24,1],[322,5,322,24,1],[323,6,323,27,1],[329,11,329,30,1],[330,5,330,26,1],[335,4,335,31,1],[339,4,340,23,1],[342,4,342,17,1],[345,4,345,17,1],[348,4,348,29,1],[349,4,349,29,1],[351,4,351,31,1],[355,4,355,42,1],[357,4,357,23,1],[358,5,358,27,1],[360,5,360,34,1],[361,5,361,20,1],[363,12,363,34,1],[364,6,364,29,1],[365,6,365,37,1],[366,12,366,34,1],[370,6,370,39,1],[371,6,371,29,1],[372,6,372,37,1],[373,6,373,33,1],[374,6,374,33,1],[375,6,375,26,1],[378,3,378,4,1],[381,4,381,42,1],[383,4,383,33,1],[384,4,384,18,1],[387,4,387,18,1],[388,5,388,36,1],[389,5,389,33,1],[391,4,391,18,1],[395,4,395,18,1],[396,5,396,40,1],[397,5,397,36,1],[398,5,398,37,1],[399,5,399,42,1],[400,5,400,51,1],[407,4,407,23,1],[408,5,408,14,1],[410,4,410,28,1],[413,4,413,33,1],[415,4,415,22,1],[418,4,418,26,1],[419,5,419,18,1],[420,4,420,26,1],[424,4,424,45,1],[425,4,425,34,1],[429,4,437,43,1]]);
    </script>
  </body>
</html>