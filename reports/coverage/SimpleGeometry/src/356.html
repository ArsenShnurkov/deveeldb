<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data\patternsearch.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Text;

namespace Deveel.Data {
	/// &lt;summary&gt;
	/// This is a static class that performs the operations to do a pattern 
	/// search on a given column of a table.
	/// &lt;/summary&gt;
	/// &lt;remarks&gt;
	/// The pattern syntax is very simple and follows that of the SQL standard.
	/// &lt;para&gt;
	/// It works as follows:
	/// The &#39;%&#39; character represents any sequence of characters.
	/// The &#39;_&#39; character represents some character.
	/// &lt;/para&gt;
	/// &lt;para&gt;
	/// Therefore, the pattern search &lt;c&gt;Anto%&lt;/c&gt; will find all rows that 
	/// start with the string &lt;c&gt;Anto&lt;/c&gt; and end with any sequence of characters. 
	/// The pattern &lt;c&gt;A% Proven%&lt;/c&gt; will find all names starting with &lt;i&gt;A&lt;/i&gt; 
	/// and containing &lt;i&gt;Proven&lt;/i&gt; somewhere in the end. The pattern &lt;i&gt;_at&lt;/i&gt; 
	/// will find all three letter words ending with &lt;i&gt;at&lt;/i&gt;.
	/// &lt;/para&gt;
	/// &lt;para&gt;
	/// &lt;b&gt;Note&lt;/b&gt; A &lt;c&gt;ab%&lt;/c&gt; type search is faster than a &lt;c&gt;%bc&lt;/c&gt; type 
	/// search. If the start of the search pattern is unknown then the entire 
	/// contents of the column need to be accessed.
	/// &lt;/para&gt;
	/// &lt;/remarks&gt;
	public static class PatternSearch {

		// Statics for the tokens.
		private const char ZeroOrMoreChars = &#39;%&#39;;
		private const char OneChar = &#39;_&#39;;

		/// &lt;summary&gt;
		/// Returns true if the given character is a wild card (unknown).
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;ch&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static bool IsWildCard(char ch) {
			return (ch == OneChar || ch == ZeroOrMoreChars);
		}

		/// &lt;summary&gt;
		/// Matches a pattern against a string and returns true if it matches 
		/// or false otherwise.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// This matches patterns that do not necessarily start with a wild 
		/// card unlike the &lt;see cref=&quot;PatternMatch&quot;/&gt; method.
		/// &lt;/remarks&gt;
		public static bool FullPatternMatch(string pattern, string str, char escapeChar) {
			StringBuilder start = new StringBuilder();
			String rezt = null;
			int len = pattern.Length;
			int i = 0;
			bool lastEscapeChar = false;
			for (; i &lt; len &amp;&amp; rezt == null; ++i) {
				char c = pattern[i];
				if (lastEscapeChar) {
					lastEscapeChar = false;
					start.Append(c);
				} else if (c == escapeChar) {
					lastEscapeChar = true;
				} else if (IsWildCard(c)) {
					rezt = pattern.Substring(i);
				} else {
					start.Append(c);
				}
			}

			if (rezt == null)
				rezt = &quot;&quot;;

			string st = start.ToString();

			if (str.StartsWith(st)) {
				string strRezt = str.Substring(st.Length); // (i)

				return rezt.Length &gt; 0 ? PatternMatch(rezt, strRezt, escapeChar) : strRezt.Length == 0;
			}

			return false;
		}

		/// &lt;summary&gt;
		/// This is the pattern match recurrsive method.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// It recurses on each wildcard expression in the pattern which makes 
		/// for slightly better efficiency than a character recurse algorithm.
		/// However, patterns such as &lt;c&gt;_%_a&lt;/c&gt; will result in many recursive 
		/// calls.
		/// &lt;para&gt;
		/// &lt;b&gt;Note&lt;/b&gt; That &lt;c&gt;_%_&lt;/c&gt; will be less efficient than &lt;c&gt;__%&lt;/c&gt; 
		/// and will produce the same result.
		/// &lt;/para&gt;
		/// &lt;para&gt;
		/// &lt;b&gt;Note&lt;/b&gt; It requires that a wild card character is the first 
		/// character in the expression.
		/// &lt;/para&gt;
		/// &lt;para&gt;
		/// &lt;b&gt;Issue&lt;/b&gt; Pattern optimiser, we should optimize wild cards of 
		/// type &lt;c&gt;%__&lt;/c&gt; to &lt;c&gt;__%&lt;/c&gt;, or &lt;c&gt;%__%_%_%&lt;/c&gt; to &lt;c&gt;____%&lt;/c&gt;. 
		/// Optimised forms are identical in result and more efficient. This 
		/// optimization could be performed by the client during parsing of 
		/// the &lt;i&gt;LIKE&lt;/i&gt; statement.
		/// &lt;/para&gt;
		/// &lt;para&gt;
		/// &lt;b&gt;Hacking Issue&lt;/b&gt; Badly formed wild cards may result in hogging 
		/// of server side resources.
		/// &lt;/para&gt;
		/// &lt;/remarks&gt;
		public static bool PatternMatch(string pattern, string expression, char escapeChar) {
			// Look at first character in pattern, if it&#39;s a ONE_CHAR wildcard then
			// check expression and pattern match until next wild card.

			if (pattern[0] == OneChar) {

				// Else step through each character in pattern and see if it matches up
				// with the expression until a wild card is found or the end is reached.
				// When the end of the pattern is reached, &#39;finished&#39; is set to true.

				int i = 1;
				bool finished = (i &gt;= pattern.Length || expression.Length &lt; 1);
				bool lastWasEscape = false;
				int checkd = 0;
				while (!finished) {
					char c = pattern[i];
					if (!lastWasEscape &amp;&amp; c == escapeChar) {
						lastWasEscape = true;
						if (i &gt;= expression.Length) {
							return false;
						}
						++i;
					} else if (lastWasEscape || !IsWildCard(c)) {
						lastWasEscape = false;
						// If expression and pattern character doesn&#39;t match or end of
						// expression reached, search has failed.
						if (i &gt;= expression.Length || c != expression[i]) {
							return false;
						}
						++i;
						++checkd;
					} else {
						// found a wildcard, so recurse on this wildcard
						return PatternMatch(pattern.Substring(i), expression.Substring(i), escapeChar);
					}

					finished = (i &gt;= pattern.Length);
				}

				// The pattern length minus any escaped characters
				int realPatternLength = 0;
				int sz = pattern.Length;
				for (int n = 0; n &lt; sz; ++n) {
					if (pattern[n] != escapeChar) {
						++realPatternLength;
					} else {
						++n;
					}
				}

				// If pattern and expression lengths match then we have walked through
				// the expression and found a match, otherwise no match.

				return realPatternLength == expression.Length;
			}

			// Therefore we are doing a ZERO_OR_MORE_CHARS wildcard check.

			// If the pattern is &#39;%&#39; (ie. pattern.Length == 1 because it&#39;s only 1
			// character in length (the &#39;%&#39; character)) then it doesn&#39;t matter what the
			// expression is, we have found a match.

			if (pattern.Length == 1)
				return true;

			// Look at following character in pattern, and extract all the characters
			// before the next wild card.

			StringBuilder nextString = new StringBuilder();
			int i1 = 1;
			bool finished1 = (i1 &gt;= pattern.Length);
			bool lastWasEscape1 = false;
			while (!finished1) {
				char nextChar = pattern[i1];
				if (!lastWasEscape1 &amp;&amp; nextChar == escapeChar) {
					lastWasEscape1 = true;
					++i1;
					if (i1 &gt;= pattern.Length) {
						finished1 = true;
					}
				} else if (lastWasEscape1 || !IsWildCard(nextChar)) {
					lastWasEscape1 = false;
					nextString.Append(nextChar);
					++i1;
					if (i1 &gt;= pattern.Length) {
						finished1 = true;
					}
				} else {
					finished1 = true;
				}
			}

			string findString = nextString.ToString();

			// Special case optimisation if we have found the end of the pattern, all
			// we need to do is check if &#39;find_string&#39; is on the end of the expression.
			// eg. pattern = &quot;%er&quot;, will have a &#39;find_string&#39; of &quot;er&quot; and it is saying
			// &#39;does the expression end with &#39;er&#39;&#39;.

			if (i1 &gt;= pattern.Length)
				return (expression.EndsWith(findString));

			// Otherwise we must have finished with another wild card.
			// Try and find &#39;next_string&#39; in the expression.  If its found then
			// recurse over the next pattern.

			int findStrLength = findString.Length;
			int strIndex = expression.IndexOf(findString, 0);

			while (strIndex != -1) {
				bool matched = PatternMatch(
								pattern.Substring(1 + findStrLength),
								expression.Substring(strIndex + findStrLength),
								escapeChar);

				if (matched)
					return true;

				strIndex = expression.IndexOf(findString, strIndex + 1);
			}

			return false;
		}

		//// ---------- Matching against a regular expression ----------

		///// &lt;summary&gt;
		///// Matches a string against a regular expression pattern.
		///// &lt;/summary&gt;
		///// &lt;remarks&gt;
		///// We use the regex library as specified in the DatabaseSystem 
		///// configuration.
		///// &lt;/remarks&gt;
		//internal static bool RegexMatch(ISystemContext context, String pattern, String value) {
		//	// If the first character is a &#39;/&#39; then we assume it&#39;s a Perl style regular
		//	// expression (eg. &quot;/.*[0-9]+\/$/i&quot;)
		//	if (pattern.StartsWith(&quot;/&quot;)) {
		//		int end = pattern.LastIndexOf(&#39;/&#39;);
		//		String pat = pattern.Substring(1, end);
		//		String ops = pattern.Substring(end + 1);
		//		return context.RegexLibrary.RegexMatch(pat, ops, value);
		//	} else {
		//		// Otherwise it&#39;s a regular expression with no operators
		//		return context.RegexLibrary.RegexMatch(pattern, &quot;&quot;, value);
		//	}
		//}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[77,6,77,29,0],[78,6,78,22,0],[80,6,80,28,0],[140,5,140,15,0],[141,5,141,68,0],[142,5,142,32,0],[143,5,143,20,0],[145,6,145,26,0],[146,6,146,44,0],[147,7,147,28,0],[148,7,148,34,0],[149,8,149,21,0],[151,7,151,11,0],[152,13,152,49,0],[153,7,153,29,0],[156,7,156,56,0],[157,8,157,21,0],[159,7,159,11,0],[160,7,160,16,0],[163,7,163,86,0],[166,6,166,39,0],[144,5,144,22,0],[170,5,170,31,0],[171,5,171,29,0],[172,10,172,20,0],[173,6,173,35,0],[174,7,174,27,0],[176,7,176,11,0],[172,29,172,32,0],[172,21,172,27,0],[183,5,183,51,0],[198,4,198,51,0],[199,4,199,15,0],[200,4,200,44,0],[201,4,201,32,0],[203,5,203,33,0],[204,5,204,51,0],[205,6,205,28,0],[206,6,206,11,0],[207,6,207,31,0],[208,7,208,24,0],[210,12,210,56,0],[211,6,211,29,0],[212,6,212,34,0],[213,6,213,11,0],[214,6,214,31,0],[215,7,215,24,0],[218,6,218,23,0],[202,4,202,22,0],[222,4,222,46,0],[229,4,229,29,0],[230,5,230,46,0],[236,4,236,42,0],[237,4,237,53,0],[240,5,243,21,0],[245,5,245,17,0],[246,6,246,18,0],[248,5,248,61,0],[239,4,239,26,0],[251,4,251,17,0],[57,4,57,52,1],[69,4,69,46,1],[70,4,70,23,1],[71,4,71,29,1],[72,4,72,14,1],[73,4,73,32,1],[75,5,75,25,1],[76,5,76,24,1],[79,12,79,32,1],[81,12,81,30,1],[82,6,82,34,1],[84,6,84,22,1],[74,36,74,39,1],[74,11,74,34,1],[88,4,88,21,1],[89,5,89,15,1],[91,4,91,33,1],[93,4,93,27,1],[94,5,94,47,1],[96,5,96,92,1],[99,4,99,17,1],[134,4,134,30,1],[192,4,192,28,1],[193,5,193,17,1]]);
    </script>
  </body>
</html>