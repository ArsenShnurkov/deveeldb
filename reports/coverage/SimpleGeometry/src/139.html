<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.spatial\wktreader.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

using Deveel.Data.Util;

namespace Deveel.Data.Spatial {
	public sealed class WktReader : IGeometryReader {
		private readonly IPrecisionModel precisionModel;
		private readonly IGeometryFactory factory;
		private readonly ICoordinateFactory coordinateFactory;
		private StreamTokenizer tokenizer;

		private const string Empty = &quot;EMPTY&quot;;
		private const string Comma = &quot;,&quot;;
		private const string LParen = &quot;(&quot;;
		private const string RParen = &quot;)&quot;;

		public WktReader(IGeometryFactory factory) {
			this.factory = factory;
			coordinateFactory = factory.CoordinateFactory;
			precisionModel = factory.PrecisionModel;

			Srid = factory.Srid;
		}

		public int Srid { get; set; }

		GeometryFormat IGeometryReader.Format {
			get { return GeometryFormat.WellKnownText; }
		}

		IGeometry IGeometryReader.Read(object input) {
			if (input is TextReader)
				return Read((TextReader) input);
			if (input is Stream)
				return Read((Stream) input);
			if (input is string)
				return Read((string) input);

			throw new ArgumentException();
		}

		public IGeometry Read(string input) {
			using (var reader = new StringReader(input)) {
				return Read(reader);
			}
		}

		public IGeometry Read(Stream inputStream) {
			using (var streamReader = new StreamReader(inputStream)) {
				return Read(streamReader);
			}
		}

		public IGeometry Read(TextReader reader) {
			tokenizer = new StreamTokenizer(reader);
			// set tokenizer to NOT parse numbers
			tokenizer.ResetSyntax();
			tokenizer.SetWordChars(&#39;a&#39;, &#39;z&#39;);
			tokenizer.SetWordChars(&#39;A&#39;, &#39;Z&#39;);
			tokenizer.SetWordChars(128 + 32, 255);
			tokenizer.SetWordChars(&#39;0&#39;, &#39;9&#39;);
			tokenizer.SetWordChars(&#39;-&#39;, &#39;-&#39;);
			tokenizer.SetWordChars(&#39;+&#39;, &#39;+&#39;);
			tokenizer.SetWordChars(&#39;.&#39;, &#39;.&#39;);
			tokenizer.SetWhitespaceChars(0, &#39; &#39;);
			tokenizer.SetCommentChar(&#39;#&#39;);

			try {
				return ReadGeometry();
			} catch (IOException e) {
				throw new FormatException(&quot;The input text is not in a valid format.&quot;);
			}
		}

		private string GetNextWord() {
			int type = tokenizer.NextToken();
			switch (type) {
				case (int) StreamTokenizer.TokenType.Word:
					String word = tokenizer.SVal;
					if (word.Equals(Empty, StringComparison.OrdinalIgnoreCase))
						return Empty;
					return word;

				case &#39;(&#39;:
					return LParen;
				case &#39;)&#39;:
					return RParen;
				case &#39;,&#39;:
					return Comma;
			}

			ReadError(&quot;word&quot;);
			return null;
		}

		private bool IsNumberNext() {
			int type = tokenizer.NextToken();
			tokenizer.PushBackToken();
			return type == (int) StreamTokenizer.TokenType.Word;
		}

		private double GetNextNumber() {
			int type = tokenizer.NextToken();
			if (type == (int) StreamTokenizer.TokenType.Word) {
				double num;
				if (!Double.TryParse(tokenizer.SVal, out num))
					throw new FormatException(String.Format(&quot;The string &#39;{0}&#39; is not a valid number.&quot;, tokenizer.SVal));

				return num;
			}

			ReadError(&quot;number&quot;);

			return 0.0;
		}

		private String GetNextEmptyOrOpener() {
			String nextWord = GetNextWord();
			if (nextWord.Equals(Empty, StringComparison.OrdinalIgnoreCase) || 
				nextWord.Equals(LParen, StringComparison.OrdinalIgnoreCase)) {
				return nextWord;
			}

			ReadError(String.Format(&quot;{0} or {1}&quot;, Empty, LParen));

			return null;
		}

		private string GetNextCloserOrComma() {
			string nextWord = GetNextWord();
			if (nextWord.Equals(Comma) || 
				nextWord.Equals(RParen)) {
				return nextWord;
			}

			ReadError(String.Format(&quot;{0} or {1}&quot;, Comma, RParen));

			return null;
		}

		private String GetNextCloser() {
			String nextWord = GetNextWord();
			if (nextWord.Equals(RParen)) {
				return nextWord;
			}

			ReadError(RParen);
			return null;
		}

		private void ReadError(String expected) {
			if (tokenizer.Type == (int)StreamTokenizer.TokenType.Number)
				throw new FormatException(&quot;Unexpected NUMBER token&quot;);
			if (tokenizer.Type == (int) StreamTokenizer.TokenType.EOL)
				throw new FormatException(&quot;Unexpected EOL token&quot;);

			var tokenStr = TokenString();
			throw new FormatException(String.Format(&quot;Expected {0} but found {1}&quot;, expected, tokenStr));
		}

		private String TokenString() {
			switch (tokenizer.Type) {
				case (int)StreamTokenizer.TokenType.Number:
					return &quot;&lt;NUMBER&gt;&quot;;
				case (int)StreamTokenizer.TokenType.EOL:
					return &quot;End-of-Line&quot;;
				case (int)StreamTokenizer.TokenType.EOF: 
					return &quot;End-of-Stream&quot;;
				case (int)StreamTokenizer.TokenType.Word: 
					return &quot;&#39;&quot; + tokenizer.SVal + &quot;&#39;&quot;;
			}

			return &quot;&#39;&quot; + (char)tokenizer.Type + &quot;&#39;&quot;;
		}

		private IGeometry ReadGeometry() {
			String type;

			try {
				type = GetNextWord();
			} catch (IOException) {
				return null;
			} catch (FormatException) {
				return null;
			}

			if (type.Equals(&quot;POINT&quot;, StringComparison.OrdinalIgnoreCase))
				return ReadPoint();
			if (type.Equals(&quot;LINESTRING&quot;, StringComparison.OrdinalIgnoreCase))
				return ReadLineString();
			if (type.Equals(&quot;LINEARRING&quot;, StringComparison.OrdinalIgnoreCase))
				return ReadLinearRing();
			if (type.Equals(&quot;POLYGON&quot;, StringComparison.OrdinalIgnoreCase))
				return ReadPolygon();
			if (type.Equals(&quot;MULTIPOINT&quot;, StringComparison.OrdinalIgnoreCase))
				return ReadMultiPoint();
			if (type.Equals(&quot;MULTILINESTRING&quot;, StringComparison.OrdinalIgnoreCase))
				return ReadMultiLineString();
			if (type.Equals(&quot;MULTIPOLYGON&quot;, StringComparison.OrdinalIgnoreCase))
				return ReadMultiPolygon();
			if (type.Equals(&quot;GEOMETRYCOLLECTION&quot;, StringComparison.OrdinalIgnoreCase)) {
				return ReadGeometryCollection();
			}

			throw new FormatException(String.Format(&quot;Unknown geometry type {0} in input.&quot;, type));
		}

		private ICoordinate[] GetCoordinates() {
			String nextToken = GetNextEmptyOrOpener();
			if (nextToken.Equals(Empty)) {
				return new ICoordinate[] {};
			}

			var coordinates = new List&lt;ICoordinate&gt; {
				GetPreciseCoordinate()
			};

			nextToken = GetNextCloserOrComma();

			while (nextToken.Equals(Comma)) {
				coordinates.Add(GetPreciseCoordinate());
				nextToken = GetNextCloserOrComma();
			}

			return coordinates.ToArray();
		}

		private ICoordinate GetPreciseCoordinate() {
			var x = GetNextNumber();
			var y = GetNextNumber();
			double? z = null;
			if (IsNumberNext()) {
				z = GetNextNumber();
			}

			ICoordinate coord;
			if (z != null) {
				coord = coordinateFactory.CreateCoordinate(x, y, z.Value);
			} else {
				coord = coordinateFactory.CreateCoordinate(x, y);
			}

			return precisionModel.MakePrecise(coord);
		}

		private IPoint[] ToPoints(ICoordinate[] coordinates) {
			return coordinates.Select(t =&gt; factory.CreatePoint(t)).ToArray();
		}

		private IGeometryCollection ReadGeometryCollection() {
			var nextToken = GetNextEmptyOrOpener();
			if (nextToken.Equals(Empty, StringComparison.OrdinalIgnoreCase))
				return factory.CreateGeometryCollection(new IGeometry[0]);

			var geometrys = new List&lt;IGeometry&gt;();
			var geometry = ReadGeometry();
			geometrys.Add(geometry);

			nextToken = GetNextCloserOrComma();
			while (nextToken.Equals(Comma, StringComparison.OrdinalIgnoreCase)) {
				geometry = ReadGeometry();
				geometrys.Add(geometry);
				nextToken = GetNextCloserOrComma();
			}

			return factory.CreateGeometryCollection(geometrys.ToArray());
		}

		private IMultiPolygon ReadMultiPolygon() {
			var nextToken = GetNextEmptyOrOpener();
			if (nextToken.Equals(Empty, StringComparison.OrdinalIgnoreCase)) {
				return factory.CreateMultiPolygon(new IPolygon[0]);
			}

			var polygons = new List&lt;IPolygon&gt;();
			var polygon = ReadPolygon();
			polygons.Add(polygon);

			nextToken = GetNextCloserOrComma();
			while (nextToken.Equals(Comma, StringComparison.OrdinalIgnoreCase)) {
				polygon = ReadPolygon();
				polygons.Add(polygon);
				nextToken = GetNextCloserOrComma();
			}

			return factory.CreateMultiPolygon(polygons.ToArray());
		}

		private IMultiLineString ReadMultiLineString() {
			var nextToken = GetNextEmptyOrOpener();
			if (nextToken.Equals(Empty, StringComparison.OrdinalIgnoreCase)) {
				return factory.CreateMultiLineString(new ILineString[0]);
			}

			var lineStrings = new List&lt;ILineString&gt;();
			var lineString = ReadLineString();

			lineStrings.Add(lineString);

			nextToken = GetNextCloserOrComma();
			while (nextToken.Equals(Comma)) {
				lineString = ReadLineString();
				lineStrings.Add(lineString);
				nextToken = GetNextCloserOrComma();
			}

			return factory.CreateMultiLineString(lineStrings.ToArray());
		}

		private IMultiPoint ReadMultiPoint() {
			return factory.CreateMultiPoint(ToPoints(GetCoordinates()));
		}

		private IPolygon ReadPolygon() {
			String nextToken = GetNextEmptyOrOpener();
			if (nextToken.Equals(Empty, StringComparison.OrdinalIgnoreCase)) {
				return factory.CreatePolygon(factory.CreateLinearRing(new ICoordinate[0]), new ILinearRing[0]);
			}

			var holes = new List&lt;ILinearRing&gt;();
			var shell = ReadLinearRing();

			nextToken = GetNextCloserOrComma();
			while (nextToken.Equals(Comma)) {
				var hole = ReadLinearRing();
				holes.Add(hole);
				nextToken = GetNextCloserOrComma();
			}

			return factory.CreatePolygon(shell, holes.ToArray());
		}

		private ILinearRing ReadLinearRing() {
			return factory.CreateLinearRing(GetCoordinates());
		}

		private ILineString ReadLineString() {
			return factory.CreateLineString(GetCoordinates());
		}

		private IPoint ReadPoint() {
			var nextToken = GetNextEmptyOrOpener();
			if (nextToken.Equals(Empty, StringComparison.OrdinalIgnoreCase)) {
				return factory.CreatePoint((ICoordinate)null);
			}

			var coord = GetPreciseCoordinate();
			GetNextCloser();

			return factory.CreatePoint(coord);
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[36,3,36,45,0],[37,4,37,27,0],[38,4,38,50,0],[39,4,39,44,0],[41,4,41,24,0],[42,3,42,4,0],[47,10,47,46,0],[51,4,51,28,0],[52,5,52,37,0],[53,4,53,24,0],[54,5,54,33,0],[55,4,55,24,0],[56,5,56,33,0],[58,4,58,34,0],[62,11,62,47,0],[63,5,63,25,0],[65,3,65,4,0],[68,11,68,59,0],[69,5,69,31,0],[71,3,71,4,0],[74,4,74,44,0],[76,4,76,28,0],[77,4,77,37,0],[78,4,78,37,0],[79,4,79,42,0],[80,4,80,37,0],[81,4,81,37,0],[82,4,82,37,0],[83,4,83,37,0],[84,4,84,41,0],[85,4,85,34,0],[88,5,88,27,0],[89,6,89,27,0],[90,5,90,75,0],[92,3,92,4,0],[95,4,95,37,0],[96,4,96,17,0],[98,6,98,35,0],[99,6,99,65,0],[100,7,100,20,0],[101,6,101,18,0],[104,6,104,20,0],[106,6,106,20,0],[108,6,108,19,0],[111,4,111,22,0],[112,4,112,16,0],[116,4,116,37,0],[117,4,117,30,0],[118,4,118,56,0],[122,4,122,37,0],[123,4,123,53,0],[125,5,125,51,0],[126,6,126,106,0],[128,5,128,16,0],[131,4,131,24,0],[133,4,133,15,0],[137,4,137,36,0],[138,4,139,65,0],[140,5,140,21,0],[143,4,143,58,0],[145,4,145,16,0],[149,4,149,36,0],[150,4,151,29,0],[152,5,152,21,0],[155,4,155,58,0],[157,4,157,16,0],[161,4,161,36,0],[162,4,162,32,0],[163,5,163,21,0],[166,4,166,22,0],[167,4,167,16,0],[171,4,171,64,0],[172,5,172,58,0],[173,4,173,62,0],[174,5,174,55,0],[176,4,176,33,0],[177,4,177,95,0],[181,4,181,27,0],[183,6,183,24,0],[185,6,185,27,0],[187,6,187,29,0],[189,6,189,40,0],[192,4,192,44,0],[199,5,199,26,0],[200,6,200,25,0],[201,5,201,17,0],[202,6,202,29,0],[203,5,203,17,0],[206,4,206,65,0],[207,5,207,24,0],[208,4,208,70,0],[209,5,209,29,0],[210,4,210,70,0],[211,5,211,29,0],[212,4,212,67,0],[213,5,213,26,0],[214,4,214,70,0],[215,5,215,29,0],[216,4,216,75,0],[217,5,217,34,0],[218,4,218,72,0],[219,5,219,31,0],[220,4,220,78,0],[221,5,221,37,0],[224,4,224,90,0],[225,3,225,4,0],[228,4,228,46,0],[229,4,229,32,0],[230,5,230,33,0],[233,4,235,6,0],[237,4,237,39,0],[240,5,240,45,0],[241,5,241,40,0],[239,4,239,35,0],[244,4,244,33,0],[248,4,248,28,0],[249,4,249,28,0],[250,4,250,21,0],[251,4,251,23,0],[252,5,252,25,0],[256,4,256,18,0],[257,5,257,63,0],[259,5,259,54,0],[262,4,262,45,0],[266,4,266,35,0],[266,57,266,69,0],[270,4,270,43,0],[271,4,271,68,0],[272,5,272,63,0],[274,4,274,42,0],[275,4,275,34,0],[276,4,276,28,0],[278,4,278,39,0],[280,5,280,31,0],[281,5,281,29,0],[282,5,282,40,0],[279,4,279,71,0],[285,4,285,65,0],[289,4,289,43,0],[290,4,290,68,0],[291,5,291,56,0],[294,4,294,40,0],[295,4,295,32,0],[296,4,296,26,0],[298,4,298,39,0],[300,5,300,29,0],[301,5,301,27,0],[302,5,302,40,0],[299,4,299,71,0],[305,4,305,58,0],[309,4,309,43,0],[310,4,310,68,0],[311,5,311,62,0],[314,4,314,46,0],[315,4,315,38,0],[317,4,317,32,0],[319,4,319,39,0],[321,5,321,35,0],[322,5,322,33,0],[323,5,323,40,0],[320,4,320,35,0],[326,4,326,64,0],[330,4,330,64,0],[334,4,334,46,0],[335,4,335,68,0],[336,5,336,100,0],[339,4,339,40,0],[340,4,340,33,0],[342,4,342,39,0],[344,5,344,33,0],[345,5,345,21,0],[346,5,346,40,0],[343,4,343,35,0],[349,4,349,57,0],[353,4,353,54,0],[357,4,357,54,0],[361,4,361,43,0],[362,4,362,68,0],[363,5,363,51,0],[366,4,366,39,0],[367,4,367,20,0],[369,4,369,38,0],[266,35,266,57,0]]);
    </script>
  </body>
</html>