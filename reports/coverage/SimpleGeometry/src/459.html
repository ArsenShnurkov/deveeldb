<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.query\queryplanner.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.Linq;

using Deveel.Data.DbSystem;
using Deveel.Data.Sql.Expressions;
using Deveel.Data.Sql.Objects;
using Deveel.Data.Types;

namespace Deveel.Data.Sql.Query {
	public sealed class QueryPlanner : IQueryPlanner {
		private static readonly ObjectName FunctionTableName = new ObjectName(&quot;FUNCTIONTABLE&quot;);

		private SqlExpression PrepareSearchExpression(IQueryContext context, QueryExpressionFrom queryFrom, SqlExpression expression) {
			// first check the expression is not null
			if (expression == null)
				return null;

			// This is used to prepare sub-queries and qualify variables in a
			// search expression such as WHERE or HAVING.

			// Prepare the sub-queries first
			expression = expression.Prepare(new QueryExpressionPreparer(this, queryFrom, context));

			// Then qualify all the variables.  Note that this will not qualify
			// variables in the sub-queries.
			expression = expression.Prepare(queryFrom.ExpressionPreparer);

			return expression;
		}

		private QuerySelectColumns BuildSelectColumns(SqlQueryExpression expression, QueryExpressionFrom queryFrom) {
			var selectColumns = new QuerySelectColumns(queryFrom);

			foreach (var column in expression.SelectColumns) {
				// Is this a glob?  (eg. Part.* )
				if (column.IsGlob) {
					// Find the columns globbed and add to the &#39;selectedColumns&#39; result.
					if (column.IsAll) {
						selectColumns.SelectAllColumnsFromAllSources();
					} else {
						// Otherwise the glob must be of the form &#39;[table name].*&#39;
						selectColumns.SelectAllColumnsFromSource(column.TableName);
					}
				} else {
					// Otherwise must be a standard column reference.
					selectColumns.SelectSingleColumn(column);
				}
			}

			return selectColumns;
		}


		private static int MakeupFunctions(PreparedQuerySelectColumns columnSet, IList&lt;SqlExpression&gt; aggregateFunctions, out SqlExpression[] defFunList, out string[] defFunNames) {
			// Make up the functions list,
			var functionsList = columnSet.FunctionColumns.ToList();
			int fsz = functionsList.Count;
			var completeFunList = new List&lt;object&gt;();
			for (int i = 0; i &lt; fsz; ++i) {
				var scol = functionsList[i];
				completeFunList.Add(scol.Expression);
				completeFunList.Add(scol.InternalName.Name);
			}

			for (int i = 0; i &lt; aggregateFunctions.Count; ++i) {
				completeFunList.Add(aggregateFunctions[i]);
				completeFunList.Add(&quot;HAVINGAGG_&quot; + (i + 1));
			}

			int fsz2 = completeFunList.Count / 2;
			defFunList = new SqlExpression[fsz2];
			defFunNames = new string[fsz2];
			for (int i = 0; i &lt; fsz2; ++i) {
				defFunList[i] = (SqlExpression)completeFunList[i * 2];
				defFunNames[i] = (string)completeFunList[(i * 2) + 1];
			}

			return fsz;
		}

		private IQueryPlanNode PlanGroup(IQueryPlanNode node, GroupInfo groupInfo) {
			// If there is more than 1 aggregate function or there is a group by
			// clause, then we must add a grouping plan.
			if (groupInfo.Columns.AggregateCount &gt; 0 || 
				groupInfo.GroupByCount &gt; 0) {
				// If there is no GROUP BY clause then assume the entire result is the
				// group.
				if (groupInfo.GroupByCount == 0) {
					node = new GroupNode(node, groupInfo.GroupMax, groupInfo.FunctionExpressions, groupInfo.FunctionNames);
				} else {
					// Do we have any group by functions that need to be planned first?
					int gfsz = groupInfo.GroupByExpressions.Length;
					if (gfsz &gt; 0) {
						var groupFunList = new SqlExpression[gfsz];
						var groupFunName = new string[gfsz];
						for (int i = 0; i &lt; gfsz; ++i) {
							groupFunList[i] = groupInfo.GroupByExpressions[i];
							groupFunName[i] = &quot;#GROUPBY-&quot; + i;
						}

						node = new CreateFunctionsNode(node, groupFunList, groupFunName);
					}

					// Otherwise we provide the &#39;group_by_list&#39; argument
					node = new GroupNode(node, groupInfo.GroupByNames, groupInfo.GroupMax, groupInfo.FunctionExpressions, groupInfo.FunctionNames);
				}
			} else {
				// Otherwise no grouping is occurring.  We simply need create a function
				// node with any functions defined in the SELECT.
				// Plan a FunctionsNode with the functions defined in the SELECT.
				if (groupInfo.FunctionCount &gt; 0)
					node = new CreateFunctionsNode(node, groupInfo.FunctionExpressions, groupInfo.FunctionNames);
			}

			return node;
		}

		#region GroupInfo

		class GroupInfo {
			public PreparedQuerySelectColumns Columns { get; set; }

			public ObjectName GroupMax { get; set; }

			public int GroupByCount { get; set; }

			public ObjectName[] GroupByNames { get; set; }

			public SqlExpression[] GroupByExpressions { get; set; }

			public int FunctionCount { get; set; }

			public string[] FunctionNames { get; set; }

			public SqlExpression[] FunctionExpressions { get; set; }
		}

		#endregion

		private QueryTablePlanner CreateTablePlanner(IQueryContext context, QueryExpressionFrom queryFrom) {
			// Set up plans for each table in the from clause of the command.  For
			// sub-queries, we recurse.

			var tablePlanner = new QueryTablePlanner();

			for (int i = 0; i &lt; queryFrom.SourceCount; i++) {
				var tableSource = queryFrom.GetTableSource(i);
				IQueryPlanNode plan;

				if (tableSource is FromTableSubQuerySource) {
					var subQuerySource = (FromTableSubQuerySource) tableSource;

					var subQueryExpr = subQuerySource.QueryExpression;
					var subQueryFrom = subQuerySource.QueryFrom;

					plan = PlanQuery(context, subQueryExpr, subQueryFrom, null);

					if (!(plan is SubsetNode))
						throw new InvalidOperationException(&quot;The root node of a sub-query plan must be a subset.&quot;);

					var subsetNode = (SubsetNode) plan;
					subsetNode.SetName(subQuerySource.AliasName);
				} else if (tableSource is FromTableDirectSource) {
					var directSource = (FromTableDirectSource) tableSource;
					plan = directSource.QueryPlan;
				} else {
					throw new InvalidOperationException(String.Format(&quot;The type of FROM source &#39;{0}&#39; is not supported.&quot;, tableSource.GetType()));
				}

				tablePlanner.AddPlan(plan, tableSource);
			}

			return tablePlanner;
		}

		private void PrepareJoins(QueryTablePlanner tablePlanner, SqlQueryExpression queryExpression, QueryExpressionFrom queryFrom, ref SqlExpression searchExpression) {
			var fromClause = queryExpression.FromClause;

			bool allInner = true;
			for (int i = 0; i &lt; fromClause.JoinPartCount; i++) {
				var joinPart = fromClause.GetJoinPart(i);
				if (joinPart.JoinType != JoinType.Inner)
					allInner = false;
			}

			for (int i = 0; i &lt; fromClause.JoinPartCount; i++) {
				var joinPart = fromClause.GetJoinPart(i);

				var joinType = joinPart.JoinType;
				var onExpression = joinPart.OnExpression;

				if (allInner) {
					// If the whole join set is inner joins then simply move the on
					// expression (if there is one) to the WHERE clause.
					if (searchExpression != null &amp;&amp; onExpression != null)
						searchExpression = SqlExpression.And(searchExpression, onExpression);
				} else {
					// Not all inner joins,
					if (joinType == JoinType.Inner &amp;&amp; onExpression == null) {
						// Regular join with no ON expression, so no preparation necessary
					} else {
						// Either an inner join with an ON expression, or an outer join with
						// ON expression
						if (onExpression == null)
							throw new InvalidOperationException(String.Format(&quot;Join of type {0} requires ON expression.&quot;, joinType));

						// Resolve the on_expression
						onExpression = onExpression.Prepare(queryFrom.ExpressionPreparer);
						// And set it in the planner
						tablePlanner.JoinAt(i, joinType, onExpression);
					}
				}
			}
		}

		private SqlExpression FilterHaving(SqlExpression havingExpression, IList&lt;SqlExpression&gt; aggregates,
			IQueryContext context) {
			if (havingExpression is SqlBinaryExpression) {
				var binary = (SqlBinaryExpression) havingExpression;
				var expType = binary.ExpressionType;
				var newLeft = FilterHaving(binary.Left, aggregates, context);
				var newRight = FilterHaving(binary.Right, aggregates, context);
				return SqlExpression.Binary(newLeft, expType, newRight);
			}

			// Not logical so determine if the expression is an aggregate or not
			if (havingExpression.HasAggregate(context)) {
				// Has aggregate functions so we must WriteByte this expression on the
				// aggregate list.

				aggregates.Add(havingExpression);

				var name = new ObjectName(FunctionTableName, String.Format(&quot;HAVINGAGG_{0}&quot;, aggregates.Count));
				return SqlExpression.Reference(name);
			}

			return havingExpression;
		}

		private int ResolveGroupBy(SqlQueryExpression queryExpression, QueryExpressionFrom queryFrom, IQueryContext context, out ObjectName[] columnNames, out IList&lt;SqlExpression&gt; expressions) {
			var groupBy = queryExpression.GroupBy == null
				? new List&lt;SqlExpression&gt;(0)
				: queryExpression.GroupBy.ToList();
			var groupBySize = groupBy.Count;

			expressions = new List&lt;SqlExpression&gt;();
			columnNames = new ObjectName[groupBySize];

			for (int i = 0; i &lt; groupBySize; i++) {
				var expression = groupBy[i];

				// Prepare the group by expression
				expression = expression.Prepare(queryFrom.ExpressionPreparer);

				var columnName = expression.AsReferenceName();
				if (columnName != null)
					expression = queryFrom.FindExpression(columnName);

				if (expression != null) {
					if (expression.HasAggregate(context))
						throw new InvalidOperationException(String.Format(&quot;Aggregate expression &#39;{0}&#39; is not allowed in a GROUP BY clause&quot;, expression));

					expressions.Add(expression);
					columnName = new ObjectName(FunctionTableName, String.Format(&quot;#GROUPBY-{0}&quot;, expressions.Count -1));
				}

				columnNames[i] = columnName;
			}

			return groupBySize;
		}

		private ObjectName ResolveGroupMax(SqlQueryExpression queryExpression, QueryExpressionFrom queryFrom) {
			var groupMax = queryExpression.GroupMax;
			if (groupMax != null) {
				var variable = queryFrom.ResolveReference(groupMax);
				if (variable == null)
					throw new InvalidOperationException(String.Format(&quot;The GROUP MAX column &#39;{0}&#39; was not found.&quot;, groupMax));

				groupMax = variable;
			}

			return groupMax;
		}

		private IQueryPlanNode EvaluateToSingle(PreparedQuerySelectColumns columns) {
			if (columns.AggregateCount &gt; 0)
				throw new InvalidOperationException(&quot;Invalid use of aggregate function in select with no FROM clause&quot;);

			// Make up the lists
			var selectedColumns = columns.SelectedColumns.ToList();
			int colCount = selectedColumns.Count;
			var colNames = new string[colCount];
			var expList = new SqlExpression[colCount];
			var subsetVars = new ObjectName[colCount];
			var aliases1 = new ObjectName[colCount];
			for (int i = 0; i &lt; colCount; ++i) {
				SelectColumn scol = selectedColumns[i];
				expList[i] = scol.Expression;
				colNames[i] = scol.InternalName.Name;
				subsetVars[i] = scol.InternalName;
				aliases1[i] = scol.ResolvedName;
			}

			return new SubsetNode(new CreateFunctionsNode(new SingleRowTableNode(), expList, colNames), subsetVars, aliases1);
		}

		private static IList&lt;SortColumn&gt; ResolveOrderByRefs(PreparedQuerySelectColumns columnSet,
			IEnumerable&lt;SortColumn&gt; orderBy) {
			// Resolve any numerical references in the ORDER BY list (eg.
			// &#39;1&#39; will be a reference to column 1.
			if (orderBy == null)
				return null;

			var columnCount = columnSet.SelectedColumns.Count();

			var resolvedColumns = new List&lt;SortColumn&gt;();
			foreach (var column in orderBy) {
				var resolved = column;

				var expression = column.Expression;
				if (expression.ExpressionType == SqlExpressionType.Constant) {
					var value = ((SqlConstantExpression) expression).Value;
					if (value.Type is NumericType &amp;&amp;
					    !value.IsNull) {
						var colRef = ((SqlNumber) value.Value).ToInt32() - 1;
						if (colRef &gt;= 0 &amp;&amp; colRef &lt; columnCount) {
							var funArray = columnSet.FunctionColumns.ToArray();
							var refExp = funArray[colRef];

							resolved = new SortColumn(refExp.Expression, column.Ascending);
						}
					}
				}

				resolvedColumns.Add(resolved);
			}

			return resolvedColumns.AsReadOnly();
		}

		public IQueryPlanNode PlanQuery(IQueryContext context, SqlQueryExpression queryExpression, IEnumerable&lt;SortColumn&gt; sortColumns) {
			var queryFrom = QueryExpressionFrom.Create(context, queryExpression);
			var orderBy = new List&lt;SortColumn&gt;();
			if (sortColumns != null)
				orderBy.AddRange(sortColumns);

			return PlanQuery(context, queryExpression, queryFrom, orderBy);
		}

		private IQueryPlanNode PlanQuery(IQueryContext context, SqlQueryExpression queryExpression,
			QueryExpressionFrom queryFrom, IList&lt;SortColumn&gt; sortColumns) {

			// ----- Resolve the SELECT list
			// If there are 0 columns selected, then we assume the result should
			// show all of the columns in the result.
			bool doSubsetColumn = (queryExpression.SelectColumns.Any());

			// What we are selecting
			var columns = BuildSelectColumns(queryExpression, queryFrom);

			// Prepare the column_set,
			var preparedColumns = columns.Prepare(context);

			sortColumns = ResolveOrderByRefs(preparedColumns, sortColumns);

			// -----

			// Set up plans for each table in the from clause of the command.  For
			// sub-queries, we recurse.

			var tablePlanner = CreateTablePlanner(context, queryFrom);

			// -----

			// The WHERE and HAVING clauses
			var whereClause = queryExpression.WhereExpression;
			var havingClause = queryExpression.HavingExpression;

			PrepareJoins(tablePlanner, queryExpression, queryFrom, ref whereClause);

			// Prepare the WHERE and HAVING clause, qualifies all variables and
			// prepares sub-queries.
			whereClause = PrepareSearchExpression(context, queryFrom, whereClause);
			havingClause = PrepareSearchExpression(context, queryFrom, havingClause);

			// Any extra Aggregate functions that are part of the HAVING clause that
			// we need to add.  This is a list of a name followed by the expression
			// that contains the aggregate function.
			var extraAggregateFunctions = new List&lt;SqlExpression&gt;();
			if (havingClause != null)
				havingClause = FilterHaving(havingClause, extraAggregateFunctions, context);

			// Any GROUP BY functions,
			ObjectName[] groupByList;
			IList&lt;SqlExpression&gt; groupByFunctions;
			var gsz = ResolveGroupBy(queryExpression, queryFrom, context, out groupByList, out groupByFunctions);

			// Resolve GROUP MAX variable to a reference in this from set
			var groupmaxColumn = ResolveGroupMax(queryExpression, queryFrom);

			// -----

			// Now all the variables should be resolved and correlated variables set
			// up as appropriate.

			// If nothing in the FROM clause then simply evaluate the result of the
			// select
			if (queryFrom.SourceCount == 0)
				return EvaluateToSingle(preparedColumns);

			// Plan the where clause.  The returned node is the plan to evaluate the
			// WHERE clause.
			var node = tablePlanner.PlanSearchExpression(whereClause);

			SqlExpression[] defFunList;
			string[] defFunNames;
			var fsz = MakeupFunctions(preparedColumns, extraAggregateFunctions, out defFunList, out defFunNames);

			var groupInfo = new GroupInfo {
				Columns = preparedColumns,
				FunctionCount = fsz,
				FunctionNames = defFunNames,
				FunctionExpressions = defFunList,
				GroupByCount = gsz,
				GroupByNames = groupByList,
				GroupByExpressions = groupByFunctions.ToArray(),
				GroupMax = groupmaxColumn
			};

			node = PlanGroup(node, groupInfo);

			// The result column list
			var selectColumns = preparedColumns.SelectedColumns.ToList();
			int sz = selectColumns.Count;

			// Evaluate the having clause if necessary
			if (havingClause != null) {
				// Before we evaluate the having expression we must substitute all the
				// aliased variables.
				var havingExpr = havingClause;

				// TODO: this requires a visitor to modify the having expression
				havingExpr = ReplaceAliasedVariables(havingExpr, selectColumns);

				var source = tablePlanner.SinglePlan;
				source.UpdatePlan(node);
				node = tablePlanner.PlanSearchExpression(havingExpr);
			}

			// Do we have a composite select expression to process?
			IQueryPlanNode rightComposite = null;
			if (queryExpression.NextComposite != null) {
				var compositeExpr = queryExpression.NextComposite;
				var compositeFrom = QueryExpressionFrom.Create(context, compositeExpr);

				// Form the right plan
				rightComposite = PlanQuery(context, compositeExpr, compositeFrom, null);
			}

			// Do we do a final subset column?
			ObjectName[] aliases = null;
			if (doSubsetColumn) {
				// Make up the lists
				var subsetVars = new ObjectName[sz];
				aliases = new ObjectName[sz];
				for (int i = 0; i &lt; sz; ++i) {
					SelectColumn scol = selectColumns[i];
					subsetVars[i] = scol.InternalName;
					aliases[i] = scol.ResolvedName;
				}

				// If we are distinct then add the DistinctNode here
				if (queryExpression.Distinct)
					node = new DistinctNode(node, subsetVars);

				// Process the ORDER BY?
				// Note that the ORDER BY has to occur before the subset call, but
				// after the distinct because distinct can affect the ordering of the
				// result.
				if (rightComposite == null &amp;&amp; sortColumns != null)
					node = PlanForOrderBy(node, sortColumns, queryFrom, selectColumns);

				// Rename the columns as specified in the SELECT
				node = new SubsetNode(node, subsetVars, aliases);
			} else {
				// Process the ORDER BY?
				if (rightComposite == null &amp;&amp; sortColumns != null)
					node = PlanForOrderBy(node, sortColumns, queryFrom, selectColumns);
			}

			// Do we have a composite to merge in?
			if (rightComposite != null) {
				// For the composite
				node = new CompositeNode(node, rightComposite, queryExpression.CompositeFunction, queryExpression.IsCompositeAll);

				// Final order by?
				if (sortColumns != null)
					node = PlanForOrderBy(node, sortColumns, queryFrom, selectColumns);

				// Ensure a final subset node
				if (!(node is SubsetNode) &amp;&amp; aliases != null) {
					node = new SubsetNode(node, aliases, aliases);
				}
			}

			return node;
		}

		private static IQueryPlanNode PlanForOrderBy(IQueryPlanNode plan, IList&lt;SortColumn&gt; orderBy, QueryExpressionFrom queryFrom, IList&lt;SelectColumn&gt; selectedColumns) {
			// Sort on the ORDER BY clause
			if (orderBy.Count &gt; 0) {
				int sz = orderBy.Count;
				var orderList = new ObjectName[sz];
				var ascendingList = new bool[sz];

				var functionOrders = new List&lt;SqlExpression&gt;();

				for (int i = 0; i &lt; sz; ++i) {
					var column = orderBy[i];
					SqlExpression exp = column.Expression;
					ascendingList[i] = column.Ascending;
					var v = exp.AsReferenceName();

					if (v != null) {
						var newV = queryFrom.ResolveReference(v);
						if (newV == null)
							throw new InvalidOperationException(String.Format(&quot;Could not resolve ORDER BY column &#39;{0}&#39; in expression&quot;, v));

						newV = ReplaceAliasedVariable(newV, selectedColumns);
						orderList[i] = newV;
					} else {
						// Otherwise we must be ordering by an expression such as
						// &#39;0 - a&#39;.

						// Resolve the expression,
						exp = exp.Prepare(queryFrom.ExpressionPreparer);

						// Make sure we substitute any aliased columns in the order by
						// columns.
						exp = ReplaceAliasedVariables(exp, selectedColumns);

						// The new ordering functions are called &#39;FUNCTIONTABLE.#ORDER-n&#39;
						// where n is the number of the ordering expression.
						orderList[i] = new ObjectName(FunctionTableName, &quot;#ORDER-&quot; + functionOrders.Count);
						functionOrders.Add(exp);
					}
				}

				// If there are functional orderings,
				// For this we must define a new FunctionTable with the expressions,
				// then order by those columns, and then use another SubsetNode
				// command node.
				int fsz = functionOrders.Count;
				if (fsz &gt; 0) {
					var funs = new SqlExpression[fsz];
					var fnames = new String[fsz];
					for (int n = 0; n &lt; fsz; ++n) {
						funs[n] = functionOrders[n];
						fnames[n] = &quot;#ORDER-&quot; + n;
					}

					if (plan is SubsetNode) {
						// If the top plan is a SubsetNode then we use the
						//   information from it to create a new SubsetNode that
						//   doesn&#39;t include the functional orders we have attached here.
						var topSubsetNode = (SubsetNode)plan;
						var mappedNames = topSubsetNode.AliasColumnNames;

						// Defines the sort functions
						plan = new CreateFunctionsNode(plan, funs, fnames);
						// Then plan the sort
						plan = new SortNode(plan, orderList, ascendingList);
						// Then plan the subset
						plan = new SubsetNode(plan, mappedNames, mappedNames);
					} else {
						// Defines the sort functions
						plan = new CreateFunctionsNode(plan, funs, fnames);
						// Plan the sort
						plan = new SortNode(plan, orderList, ascendingList);
					}

				} else {
					// No functional orders so we only need to sort by the columns
					// defined.
					plan = new SortNode(plan, orderList, ascendingList);
				}
			}

			return plan;
		}

		private static SqlExpression ReplaceAliasedVariables(SqlExpression expression, IList&lt;SelectColumn&gt; selectedColumns) {
			var replacer = new VariableReplacer(selectedColumns);
			return replacer.Visit(expression);
		}

		private static ObjectName ReplaceAliasedVariable(ObjectName variableName, IEnumerable&lt;SelectColumn&gt; selectColumns) {
			foreach (var column in selectColumns) {
				if (column.ResolvedName.Equals(variableName))
					return column.InternalName;
			}

			return variableName;
		}

		#region QueryExpressionPreparer

		class QueryExpressionPreparer : IExpressionPreparer {
			private readonly QueryPlanner planner;
			private readonly QueryExpressionFrom parent;
			private readonly IQueryContext context;

			public QueryExpressionPreparer(QueryPlanner planner, QueryExpressionFrom parent, IQueryContext context) {
				this.planner = planner;
				this.parent = parent;
				this.context = context;
			}

			public bool CanPrepare(SqlExpression expression) {
				return expression is SqlQueryExpression;
			}

			public SqlExpression Prepare(SqlExpression expression) {
				var queryExpression = (SqlQueryExpression) expression;
				var queryFrom = QueryExpressionFrom.Create(context, queryExpression);
				queryFrom.Parent = parent;
				var plan = planner.PlanQuery(context, queryExpression, queryFrom, null);
				return SqlExpression.Constant(new DataObject(new QueryType(), new SqlQueryObject(new CachePointNode(plan))));
			}
		}

		#endregion

		#region VariableReplacer

		class VariableReplacer : SqlExpressionVisitor {
			private readonly IEnumerable&lt;SelectColumn&gt; selectColumns;

			public VariableReplacer(IEnumerable&lt;SelectColumn&gt; selectColumns) {
				this.selectColumns = selectColumns;
			}

			public override SqlExpression VisitVariableReference(SqlVariableReferenceExpression reference) {
				// TODO: should we also resolve variables?
				return base.VisitVariableReference(reference);
			}

			public override SqlExpression VisitReference(SqlReferenceExpression reference) {
				var refName = reference.ReferenceName;
				foreach (var column in selectColumns) {
					if (refName.Equals(column.ResolvedName))
						return SqlExpression.Reference(column.InternalName);
				}

				return base.VisitReference(reference);
			}
		}

		#endregion
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[39,4,39,91,0],[43,4,43,66,0],[45,4,45,22,0],[59,7,59,66,0],[77,5,77,33,0],[78,5,78,42,0],[79,5,79,49,0],[76,29,76,32,0],[83,5,83,48,0],[84,5,84,49,0],[82,50,82,53,0],[91,5,91,59,0],[92,5,92,59,0],[90,30,90,33,0],[105,5,105,37,0],[106,6,106,109,0],[109,6,109,53,0],[110,6,110,19,0],[111,7,111,50,0],[112,7,112,43,0],[113,12,113,22,0],[114,8,114,58,0],[115,8,115,42,0],[113,33,113,36,0],[113,23,113,31,0],[118,7,118,72,0],[122,6,122,133,0],[129,6,129,99,0],[168,6,168,65,0],[170,6,170,56,0],[171,6,171,50,0],[173,6,173,66,0],[175,6,175,32,0],[176,7,176,98,0],[178,6,178,41,0],[179,6,179,51,0],[184,6,184,131,0],[200,6,200,23,0],[213,7,213,76,0],[216,6,216,61,0],[221,7,221,32,0],[222,8,222,113,0],[225,7,225,73,0],[227,7,227,54,0],[235,4,235,48,0],[236,5,236,57,0],[237,5,237,41,0],[238,5,238,66,0],[239,5,239,68,0],[240,5,240,61,0],[244,4,244,47,0],[248,5,248,38,0],[250,5,250,100,0],[251,5,251,42,0],[254,4,254,28,0],[267,5,267,33,0],[270,5,270,67,0],[272,5,272,51,0],[273,5,273,28,0],[274,6,274,56,0],[276,5,276,28,0],[277,6,277,43,0],[278,7,278,136,0],[280,6,280,34,0],[281,6,281,106,0],[284,5,284,33,0],[266,37,266,40,0],[293,5,293,57,0],[294,5,294,26,0],[295,6,295,112,0],[297,5,297,25,0],[304,4,304,35,0],[305,5,305,108,0],[308,4,308,59,0],[309,4,309,41,0],[310,4,310,40,0],[311,4,311,46,0],[312,4,312,46,0],[313,4,313,44,0],[314,9,314,19,0],[315,5,315,44,0],[316,5,316,34,0],[317,5,317,42,0],[318,5,318,39,0],[319,5,319,37,0],[314,34,314,37,0],[314,20,314,32,0],[322,4,322,118,0],[330,5,330,17,0],[335,13,335,23,0],[336,5,336,27,0],[338,5,338,40,0],[339,5,339,65,0],[340,6,340,61,0],[341,6,342,24,0],[343,7,343,60,0],[344,7,344,47,0],[345,8,345,59,0],[346,8,346,38,0],[348,8,348,71,0],[353,5,353,35,0],[363,5,363,35,0],[409,5,409,81,0],[427,5,427,46,0],[458,5,458,35,0],[461,5,461,69,0],[463,5,463,42,0],[464,5,464,29,0],[465,5,465,58,0],[471,5,471,55,0],[472,5,472,76,0],[475,5,475,77,0],[492,6,492,48,0],[505,5,505,55,0],[506,6,506,73,0],[512,5,512,119,0],[515,5,515,29,0],[516,6,516,73,0],[519,5,519,50,0],[520,6,520,52,0],[530,5,530,28,0],[531,5,531,40,0],[532,5,532,38,0],[534,5,534,52,0],[536,10,536,20,0],[537,6,537,30,0],[538,6,538,44,0],[539,6,539,42,0],[540,6,540,36,0],[542,6,542,20,0],[543,7,543,48,0],[544,7,544,24,0],[545,8,545,119,0],[547,7,547,60,0],[548,7,548,27,0],[554,7,554,55,0],[558,7,558,59,0],[562,7,562,90,0],[563,7,563,31,0],[536,29,536,32,0],[536,21,536,27,0],[571,5,571,36,0],[572,5,572,17,0],[573,6,573,40,0],[574,6,574,35,0],[575,11,575,21,0],[576,7,576,35,0],[577,7,577,33,0],[575,31,575,34,0],[575,22,575,29,0],[580,6,580,29,0],[584,7,584,44,0],[585,7,585,56,0],[588,7,588,58,0],[590,7,590,59,0],[592,7,592,61,0],[595,7,595,58,0],[597,7,597,59,0],[603,6,603,58,0],[611,4,611,57,0],[612,4,612,38,0],[616,27,616,40,0],[616,13,616,23,0],[617,5,617,50,0],[618,6,618,33,0],[616,24,616,26,0],[621,4,621,24,0],[622,3,622,4,0],[631,4,631,107,0],[632,5,632,28,0],[633,5,633,26,0],[634,5,634,28,0],[635,4,635,5,0],[638,5,638,45,0],[642,5,642,59,0],[643,5,643,74,0],[644,5,644,31,0],[645,5,645,77,0],[646,5,646,114,0],[657,4,657,68,0],[658,5,658,40,0],[659,4,659,5,0],[663,5,663,51,0],[667,5,667,43,0],[668,28,668,41,0],[668,14,668,24,0],[669,6,669,46,0],[670,7,670,59,0],[668,25,668,27,0],[673,5,673,43,0],[674,4,674,5,0],[32,4,32,27,1],[33,5,33,17,1],[49,4,49,58,1],[51,27,51,51,1],[51,13,51,23,1],[53,5,53,23,1],[55,6,55,23,1],[56,7,56,54,1],[63,6,63,47,1],[51,24,51,26,1],[67,4,67,25,1],[73,4,73,59,1],[74,4,74,34,1],[75,4,75,45,1],[76,9,76,19,1],[76,20,76,27,1],[82,9,82,19,1],[82,20,82,48,1],[87,4,87,41,1],[88,4,88,41,1],[89,4,89,35,1],[90,9,90,19,1],[90,20,90,28,1],[95,4,95,15,1],[101,4,102,32,1],[128,5,128,37,1],[132,4,132,16,1],[161,4,161,47,1],[163,9,163,19,1],[164,5,164,51,1],[167,5,167,48,1],[180,12,180,53,1],[181,6,181,61,1],[182,6,182,36,1],[187,5,187,45,1],[163,47,163,50,1],[163,20,163,45,1],[190,4,190,24,1],[194,4,194,48,1],[196,4,196,25,1],[197,9,197,19,1],[198,5,198,46,1],[199,5,199,45,1],[197,50,197,53,1],[197,20,197,48,1],[203,9,203,19,1],[204,5,204,46,1],[206,5,206,38,1],[207,5,207,46,1],[209,5,209,18,1],[212,6,212,59,1],[203,50,203,53,1],[203,20,203,48,1],[231,3,231,4,1],[258,4,260,40,1],[261,4,261,36,1],[263,4,263,44,1],[264,4,264,46,1],[266,9,266,19,1],[266,20,266,35,1],[287,4,287,23,1],[291,4,291,44,1],[292,4,292,25,1],[300,4,300,20,1],[329,4,329,24,1],[332,4,332,56,1],[334,4,334,49,1],[335,27,335,34,1],[335,24,335,26,1],[356,4,356,40,1],[360,4,360,73,1],[361,4,361,41,1],[362,4,362,28,1],[365,4,365,67,1],[374,4,374,64,1],[377,4,377,65,1],[380,4,380,51,1],[382,4,382,67,1],[389,4,389,62,1],[394,4,394,54,1],[395,4,395,56,1],[397,4,397,76,1],[401,4,401,75,1],[402,4,402,77,1],[407,4,407,60,1],[408,4,408,29,1],[414,4,414,105,1],[417,4,417,69,1],[426,4,426,35,1],[431,4,431,62,1],[435,4,435,105,1],[437,4,446,6,1],[448,4,448,38,1],[451,4,451,65,1],[452,4,452,33,1],[455,4,455,29,1],[469,4,469,41,1],[470,4,470,46,1],[479,4,479,32,1],[480,4,480,23,1],[482,5,482,41,1],[483,5,483,34,1],[484,10,484,20,1],[485,6,485,43,1],[486,6,486,40,1],[487,6,487,37,1],[484,29,484,32,1],[484,21,484,27,1],[491,5,491,34,1],[498,5,498,55,1],[499,6,499,73,1],[502,5,502,54,1],[510,4,510,31,1],[524,4,524,16,1],[529,4,529,26,1],[607,4,607,16,1],[28,3,28,90,1]]);
    </script>
  </body>
</html>