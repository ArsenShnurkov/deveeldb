<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.dbsystem\tablemanager.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;

using Deveel.Data.Index;
using Deveel.Data.Sql;
using Deveel.Data.Sql.Objects;
using Deveel.Data.Transactions;

namespace Deveel.Data.DbSystem {
	public sealed class TableManager : IObjectManager {
		private readonly List&lt;TableSource&gt; visibleTables;
		private List&lt;IMutableTable&gt; accessedTables;
		private List&lt;TableSource&gt; selectedTables; 
		private readonly List&lt;IIndexSet&gt; tableIndices;
		private List&lt;ITableContainer&gt; internalTables;

		private readonly Dictionary&lt;ObjectName, IMutableTable&gt; tableCache;

		private List&lt;object&gt; cleanupQueue;

		internal TableManager(ITransaction transaction, TableSourceComposite composite) {
			if (transaction == null)
				throw new ArgumentNullException(&quot;transaction&quot;);

			Transaction = transaction;

			Composite = composite;

			visibleTables = new List&lt;TableSource&gt;();
			tableIndices = new List&lt;IIndexSet&gt;();
			accessedTables = new List&lt;IMutableTable&gt;();
			tableCache = new Dictionary&lt;ObjectName, IMutableTable&gt;();
			selectedTables = new List&lt;TableSource&gt;();
		}

		~TableManager() {
			Dispose(true);
		}

		public ITransaction Transaction { get; private set; }

		private TableSourceComposite Composite { get; set; }

		internal IEnumerable&lt;IMutableTable&gt; AccessedTables {
			get { return accessedTables; }
		}

		internal IEnumerable&lt;TableSource&gt; SelectedTables {
			get {
				lock (selectedTables) {
					return selectedTables.AsReadOnly();
				}
			}
		} 

		private bool IgnoreIdentifiersCase {
			get { return Transaction.IgnoreIdentifiersCase(); }
		}

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		private void DisposeAllIndices() {
			// Dispose all the IIndexSet for each table
			try {
				foreach (var tableIndex in tableIndices) {
					tableIndex.Dispose();
				}
			} catch (Exception e) {
				// TODO: Report the error ...
			}

			// Dispose all tables we dropped (they will be in the cleanup_queue.
			try {
				if (cleanupQueue != null) {
					for (int i = 0; i &lt; cleanupQueue.Count; i += 2) {
						var tableSource = (TableSource) cleanupQueue[i];
						IIndexSet indexSet = (IIndexSet) cleanupQueue[i + 1];
						indexSet.Dispose();
					}
				}
			} catch (Exception e) {
				// TODO: Report the error
			} finally {
				cleanupQueue = null;
			}
		}

		private void DisposeTouchedTables() {
			try {
				foreach (var table in accessedTables) {
					table.Dispose();
				}

				accessedTables.Clear();
			} catch (Exception ex) {
				// TODO: Report the error
			} finally {
				accessedTables = null;
			}
		}

		private void Dispose(bool disposing) {
			if (disposing) {
				DisposeAllIndices();
				DisposeTouchedTables();
			}

			Transaction = null;
		}

		DbObjectType IObjectManager.ObjectType {
			get { return DbObjectType.Table; }
		}

		void IObjectManager.CreateObject(IObjectInfo objInfo) {
			var tableInfo = objInfo as TableInfo;
			if (tableInfo == null)
				throw new ArgumentException();

			CreateTable(tableInfo);
		}

		public void CreateTable(TableInfo tableInfo) {
			CreateTable(tableInfo, false);
		}

		public void CreateTable(TableInfo tableInfo, bool temporary) {
			var tableName = tableInfo.TableName;
			var source = FindVisibleTable(tableName, false);
			if (source != null)
				throw new InvalidOperationException(String.Format(&quot;Table &#39;{0}&#39; already exists.&quot;, tableName));

			tableInfo = tableInfo.AsReadOnly();

			source = Composite.CreateTableSource(tableInfo, temporary);

			// Add this table (and an index set) for this table.
			AddVisibleTable(source, source.CreateIndexSet());

			int tableId = source.TableId;
			Transaction.Registry.RegisterEvent(new TableCreatedEvent(tableId, tableName));

			Transaction.CreateNativeSequence(tableName);
		}

		public void CreateTemporaryTable(TableInfo tableInfo) {
			CreateTable(tableInfo, true);
		}

		public void SelectTable(ObjectName tableName) {
			// Special handling of internal tables,
			if (IsDynamicTable(tableName))
				return;

			var source = FindVisibleTable(tableName, false);
			if (source == null)
				throw new ObjectNotFoundException(tableName);

			lock (selectedTables) {
				if (!selectedTables.Contains(source))
					selectedTables.Add(source);
			}
		}

		public void CompactTable(ObjectName tableName) {
			// Find the master table.
			var currentTable = FindVisibleTable(tableName, false);
			if (currentTable == null)
				throw new ObjectNotFoundException(tableName);

			// If the table is worth compacting
			if (currentTable.CanCompact) {
				// The view of this table within this transaction.
				var indexSet = GetIndexSetForTable(currentTable);

				// Drop the current table
				DropTable(tableName);
				// And copy to the new table
				CopyTable(currentTable, indexSet);
			}
		}

		private void CopyTable(TableSource tableSource, IIndexSet indexSet) {
			var tableInfo = tableSource.TableInfo;
			var tableName = tableInfo.TableName;
			var source = FindVisibleTable(tableName, false);
			if (source != null)
				throw new ObjectNotFoundException(tableName);

			// Copy the table and add to the list of visible tables.
			source = Composite.CopySourceTable(tableSource, indexSet);

			AddVisibleTable(source, source.CreateIndexSet());

			// Log in the journal that this transaction touched the table_id.
			int tableId = source.TableId;
			Transaction.Registry.RegisterEvent(new TableCreatedEvent(tableId, tableName));

			Transaction.CreateNativeSequence(tableName);
		}

		internal IIndexSet GetIndexSetForTable(TableSource tableSource) {
			int sz = tableIndices.Count;
			for (int i = 0; i &lt; sz; ++i) {
				if (visibleTables[i].TableId == tableSource.TableId) {
					return tableIndices[i];
				}
			}

			throw new Exception(&quot;Table source not found in this transaction.&quot;);
		}

		private void AddVisibleTable(TableSource table, IIndexSet indexSet) {
			if (Transaction.ReadOnly())
				throw new Exception(&quot;Transaction is Read-only.&quot;);

			visibleTables.Add(table);
			tableIndices.Add(indexSet);
		}

		internal void RemoveVisibleTable(TableSource table) {
			if (Transaction.ReadOnly())
				throw new Exception(&quot;Transaction is Read-only.&quot;);

			int i = visibleTables.FindIndex(x =&gt; x.TableId == table.TableId);
			if (i != -1) {
				visibleTables.RemoveAt(i);
				IIndexSet indexSet = tableIndices[i];
				tableIndices.RemoveAt(i);
				if (cleanupQueue == null)
					cleanupQueue = new List&lt;object&gt;();

				cleanupQueue.Add(table);
				cleanupQueue.Add(indexSet);

				// Remove from the table cache
				var tableName = table.TableInfo.TableName;
				tableCache.Remove(tableName);
			}
		}

		internal void UpdateVisibleTable(TableSource table, IIndexSet indexSet) {
			if (Transaction.ReadOnly())
				throw new Exception(&quot;Transaction is Read-only.&quot;);

			RemoveVisibleTable(table);
			AddVisibleTable(table, indexSet);
		}

		private TableSource FindVisibleTable(ObjectName tableName) {
			return FindVisibleTable(tableName, IgnoreIdentifiersCase);
		}

		private TableSource FindVisibleTable(ObjectName tableName, bool ignoreCase) {
			return visibleTables
				.FirstOrDefault(source =&gt; source != null &amp;&amp;
				                          source.TableInfo.TableName.Equals(tableName, ignoreCase));
		}

		public SqlNumber SetUniqueId(ObjectName tableName, SqlNumber value) {
			var tableSource = FindVisibleTable(tableName, false);
			if (tableSource == null)
				throw new ObjectNotFoundException(tableName, String.Format(&quot;Table with name &#39;{0}&#39; could not be found to set the unique id.&quot;, tableName));

			tableSource.SetUniqueId(value.ToInt64());
			return value;
		}

		public SqlNumber NextUniqueId(ObjectName tableName) {
			var tableSource = FindVisibleTable(tableName, false);
			if (tableSource == null)
				throw new ObjectNotFoundException(tableName, String.Format(&quot;Table with name &#39;{0}&#39; could not be found to retrieve unique id.&quot;, tableName));

			var value = tableSource.GetNextUniqueId();
			return new SqlNumber(value);
		}

		private bool IsDynamicTable(ObjectName tableName) {
			if (internalTables == null)
				return false;

			return internalTables.Any(info =&gt; info != null &amp;&amp; info.ContainsTable(tableName));
		}

		private ITable GetDynamicTable(ObjectName tableName) {
			foreach (var info in internalTables) {
				if (info != null) {
					int index = info.FindByName(tableName);
					if (index != -1)
						return info.GetTable(index);
				}
			}

			throw new ArgumentException(String.Format(&quot;Table &#39;{0}&#39; is not a dynamic table.&quot;, tableName));
		}

		private string GetDynamicTableType(ObjectName tableName) {
			// Otherwise we need to look up the table in the internal table list,
			foreach (var info in internalTables) {
				if (info != null) {
					int index = info.FindByName(tableName);
					if (index != -1)
						return info.GetTableType(index);
				}
			}

			throw new ArgumentException(String.Format(&quot;Table &#39;{0}&#39; is not a dynamic table.&quot;, tableName));
		}

		bool IObjectManager.RealObjectExists(ObjectName objName) {
			return RealTableExists(objName);
		}

		public bool RealTableExists(ObjectName tableName) {
			return FindVisibleTable(tableName, false) != null;
		}

		bool IObjectManager.ObjectExists(ObjectName objName) {
			return TableExists(objName);
		}

		public bool TableExists(ObjectName tableName) {
			return IsDynamicTable(tableName) ||
			       RealTableExists(tableName);
		}

		IDbObject IObjectManager.GetObject(ObjectName objName) {
			return GetTable(objName);
		}

		public ITable GetTable(ObjectName tableName) {
			// If table is in the cache, return it
			IMutableTable table;
			if (tableCache.TryGetValue(tableName, out table))
				return table;

			var source = FindVisibleTable(tableName, false);

			if (source == null) {
				if (IsDynamicTable(tableName))
					return GetDynamicTable(tableName);
			} else {
				// Otherwise make a view of tha master table data source and write it in
				// the cache.
				table = CreateTableAtCommit(source);

				// Put table name in the cache
				tableCache[tableName] = table;
			}

			return table;
		}

		public String GetTableType(ObjectName tableName) {
			if (tableName == null)
				throw new ArgumentNullException(&quot;tableName&quot;);

			if (IsDynamicTable(tableName))
				return GetDynamicTableType(tableName);
			if (FindVisibleTable(tableName, false) != null)
				return TableTypes.Table;

			// No table found so report the error.
			throw new ObjectNotFoundException(tableName);
		}

		private ObjectName[] GetDynamicTables() {
			int sz = internalTables.Where(container =&gt; container != null).Sum(container =&gt; container.TableCount);

			var list = new ObjectName[sz];
			int index = -1;

			foreach (var container in internalTables) {
				if (container != null) {
					int tableCount = container.TableCount;
					for (int i = 0; i &lt; tableCount; ++i) {
						list[++index] = container.GetTableName(i);
					}
				}
			}

			return list;
		}

		public ObjectName TryResolveCase(ObjectName tableName) {
			// Is it a visable table (match case insensitive)
			var table = FindVisibleTable(tableName, true);
			if (table != null)
				return table.TableName;

			var comparison = IgnoreIdentifiersCase
				? StringComparison.OrdinalIgnoreCase
				: StringComparison.Ordinal;

			// Is it an internal table?
			string tschema = tableName.ParentName;
			string tname = tableName.Name;
			var list = GetDynamicTables();
			foreach (var ctable in list) {
				if (String.Equals(ctable.ParentName, tschema, comparison) &amp;&amp;
					String.Equals(ctable.Name, tname, comparison)) {
					return ctable;
				}
			}

			// No matches so return the original object.
			return tableName;
		}

		public IMutableTable GetMutableTable(ObjectName tableName) {
			var table = GetTable(tableName);
			if (table == null)
				return null;

			if (!(table is IMutableTable))
				throw new InvalidOperationException();

			return (IMutableTable) table;
		}

		private TableInfo GetDynamicTableInfo(ObjectName tableName) {
			foreach (var info in internalTables) {
				if (info != null) {
					int index = info.FindByName(tableName);
					if (index != -1)
						return info.GetTableInfo(index);
				}
			}

			throw new Exception(&quot;Not an internal table: &quot; + tableName);
		}

		public TableInfo GetTableInfo(ObjectName tableName) {
			// If this is a dynamic table then handle specially
			if (IsDynamicTable(tableName))
				return GetDynamicTableInfo(tableName);

			// Otherwise return from the pool of visible tables
			return visibleTables
					.Select(table =&gt; table.TableInfo)
					.FirstOrDefault(tableInfo =&gt; tableInfo.TableName.Equals(tableName));
		}

		private IMutableTable CreateTableAtCommit(TableSource source) {
			// Create the table for this transaction.
			var table = source.CreateTableAtCommit(Transaction);

			accessedTables.Add(table);

			Transaction.Registry.RegisterEvent(new TableAccessEvent(source.TableId, source.TableInfo.TableName));

			return table;
		}

		bool IObjectManager.AlterObject(IObjectInfo objInfo) {
			var tableInfo = objInfo as TableInfo;
			if (tableInfo == null)
				throw new ArgumentException();

			return AlterTable(tableInfo);
		}

		public bool AlterTable(TableInfo tableInfo) {
			tableInfo = tableInfo.AsReadOnly();

			var tableName = tableInfo.TableName;

			// The current schema context is the schema of the table name
			string currentSchema = tableName.Parent.Name;
			var context = new SystemQueryContext(Transaction, currentSchema);

			// Get the next unique id of the unaltered table.
			var nextId = NextUniqueId(tableName);

			// Drop the current table
			var cTable = GetTable(tableName);
			var droppedTableId = cTable.TableInfo.Id;

			DropTable(tableName);

			// And create the table table
			CreateTable(tableInfo);

			var alteredTable = GetMutableTable(tableName);
			var source = FindVisibleTable(tableName, false);
			int alteredTableId = source.TableId;

			// Set the sequence id of the table
			source.SetUniqueId(nextId.ToInt64());

			// Work out which columns we have to copy to where
			int[] colMap = new int[tableInfo.ColumnCount];
			var origTd = cTable.TableInfo;
			for (int i = 0; i &lt; colMap.Length; ++i) {
				string colName = tableInfo[i].ColumnName;
				colMap[i] = origTd.IndexOfColumn(colName);
			}

			// First move all the rows from the old table to the new table,
			// This does NOT update the indexes.
			var e = cTable.GetEnumerator();
			while (e.MoveNext()) {
				int rowIndex = e.Current.RowId.RowNumber;
				var dataRow = alteredTable.NewRow();
				for (int i = 0; i &lt; colMap.Length; ++i) {
					int col = colMap[i];
					if (col != -1) {
						dataRow.SetValue(i, cTable.GetValue(rowIndex, col));
					}
				}

				dataRow.SetDefault(context);

				// Note we use a low level &#39;AddRow&#39; method on the master table
				// here.  This does not touch the table indexes.  The indexes are
				// built later.
				int newRowNumber = source.AddRow(dataRow);

				// Set the record as committed added
				source.WriteRecordState(newRowNumber, RecordState.CommittedAdded);
			}

			// TODO: We need to copy any existing index definitions that might
			//   have been set on the table being altered.

			// Rebuild the indexes in the new master table,
			source.BuildIndexes();

			// Get the snapshot index set on the new table and set it here
			SetIndexSetForTable(source, source.CreateIndexSet());

			// Flush this out of the table cache
			FlushTableCache(tableName);

			// Ensure the native sequence generator exists...
			Transaction.RemoveNativeSequence(tableName);
			Transaction.CreateNativeSequence(tableName);

			// Notify that this database object has been successfully dropped and
			// created.
			Transaction.Registry.RegisterEvent(new TableDroppedEvent(droppedTableId, tableName));
			Transaction.Registry.RegisterEvent(new TableCreatedEvent(alteredTableId, tableName));

			return true;
		}

		private void FlushTableCache(ObjectName tableName) {
			tableCache.Remove(tableName);
		}

		private void SetIndexSetForTable(TableSource source, IIndexSet indexSet) {
			int sz = tableIndices.Count;
			for (int i = 0; i &lt; sz; ++i) {
				if (visibleTables[i].TableId == source.TableId) {
					tableIndices[i] = indexSet;
					return;
				}
			}

			throw new Exception(&quot;Table source not found in this transaction.&quot;);
		}

		bool IObjectManager.DropObject(ObjectName objName) {
			return DropTable(objName);
		}

		public ObjectName ResolveName(ObjectName objName, bool ignoreCase) {
			// Is it a visible table (match case insensitive)
			var table = FindVisibleTable(objName, ignoreCase);
			if (table != null)
				return table.TableName;

			// Is it an internal table?
			string tschema = objName.ParentName;
			string tname = objName.Name;
			var list = GetDynamicTables();

			var comparison = ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal;
			foreach (var ctable in list) {
				if (String.Equals(ctable.ParentName, tschema, comparison) &amp;&amp;
					String.Equals(ctable.Name, tname, comparison)) {
					return ctable;
				}
			}

			// No matches so return the original object.
			return objName;
		}

		public bool DropTable(ObjectName tableName) {
			var source = FindVisibleTable(tableName, false);
			if (source == null)
				return false;

			// Removes this table from the visible table list of this transaction
			RemoveVisibleTable(source);

			// Log in the journal that this transaction touched the table_id.
			int tableId = source.TableId;
			Transaction.Registry.RegisterEvent(new TableDroppedEvent(tableId, tableName));

			Transaction.RemoveNativeSequence(tableName);

			return true;
		}

		public void AssertConstraints(ObjectName tableName) {
			throw new NotImplementedException();
		}

		public void AddInternalTable(ITableContainer container) {
			if (internalTables == null)
				internalTables = new List&lt;ITableContainer&gt;();

			internalTables.Add(container);
		}

		internal IEnumerable&lt;TableSource&gt; GetVisibleTables() {
			return visibleTables.AsReadOnly();
		}

		internal void AddVisibleTables(IEnumerable&lt;TableSource&gt; tableSources, IEnumerable&lt;IIndexSet&gt; indexSets) {
			var tableList = tableSources.ToList();
			var indexSetList = indexSets.ToList();
			for (int i = 0; i &lt; tableList.Count; i++) {
				AddVisibleTable(tableList[i], indexSetList[i]);
			}
		}

		public IEnumerable&lt;ObjectName&gt; GetTableNames() {
			var result = (visibleTables
				.Where(tableSource =&gt; tableSource != null)
				.Select(tableSource =&gt; tableSource.TableName)).ToList();

			var dynamicTables = GetDynamicTables();
			if (dynamicTables != null)
				result.AddRange(dynamicTables);

			return result.AsReadOnly();
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[41,5,41,52,0],[75,10,75,53,0],[89,6,89,25,0],[102,6,102,25,0],[133,10,133,36,0],[137,4,137,41,0],[138,4,138,26,0],[139,5,139,35,0],[141,4,141,27,0],[142,3,142,4,0],[152,5,152,98,0],[168,4,168,33,0],[169,3,169,4,0],[174,5,174,12,0],[178,5,178,50,0],[188,4,188,58,0],[189,4,189,29,0],[190,5,190,50,0],[193,4,193,32,0],[195,5,195,54,0],[198,5,198,26,0],[200,5,200,39,0],[202,3,202,4,0],[205,4,205,42,0],[206,4,206,40,0],[207,4,207,52,0],[208,4,208,23,0],[209,5,209,50,0],[212,4,212,62,0],[214,4,214,53,0],[217,4,217,33,0],[218,4,218,82,0],[220,4,220,48,0],[221,3,221,4,0],[231,4,231,71,0],[236,5,236,54,0],[244,5,244,54,0],[265,5,265,54,0],[272,4,272,62,0],[282,4,282,57,0],[283,4,283,28,0],[284,5,284,142,0],[286,4,286,45,0],[287,4,287,17,0],[293,5,293,143,0],[301,5,301,18,0],[307,25,307,39,0],[307,13,307,21,0],[308,5,308,22,0],[309,6,309,45,0],[310,6,310,22,0],[311,7,311,35,0],[307,22,307,24,0],[315,4,315,97,0],[316,3,316,4,0],[320,25,320,39,0],[320,13,320,21,0],[321,5,321,22,0],[322,6,322,45,0],[323,6,323,22,0],[324,7,324,39,0],[320,22,320,24,0],[328,4,328,97,0],[329,3,329,4,0],[361,5,361,35,0],[362,6,362,40,0],[377,5,377,50,0],[380,5,380,43,0],[385,4,385,49,0],[408,4,408,50,0],[409,4,409,22,0],[410,5,410,28,0],[412,4,414,32,0],[417,4,417,42,0],[418,4,418,34,0],[419,4,419,34,0],[420,27,420,31,0],[420,13,420,23,0],[421,5,422,52,0],[423,6,423,20,0],[420,24,420,26,0],[428,4,428,21,0],[429,3,429,4,0],[432,4,432,36,0],[433,4,433,22,0],[434,5,434,17,0],[436,4,436,34,0],[437,5,437,43,0],[439,4,439,33,0],[443,25,443,39,0],[443,13,443,21,0],[444,5,444,22,0],[445,6,445,45,0],[446,6,446,22,0],[447,7,447,39,0],[443,22,443,24,0],[451,4,451,63,0],[452,3,452,4,0],[457,5,457,43,0],[477,4,477,41,0],[478,4,478,26,0],[479,5,479,35,0],[481,4,481,33,0],[485,4,485,39,0],[487,4,487,40,0],[490,4,490,49,0],[491,4,491,69,0],[494,4,494,41,0],[497,4,497,37,0],[498,4,498,45,0],[500,4,500,25,0],[503,4,503,27,0],[505,4,505,50,0],[506,4,506,52,0],[507,4,507,40,0],[510,4,510,41,0],[513,4,513,50,0],[514,4,514,34,0],[515,9,515,19,0],[516,5,516,46,0],[517,5,517,47,0],[515,39,515,42,0],[515,20,515,37,0],[522,4,522,35,0],[524,5,524,46,0],[525,5,525,41,0],[526,10,526,20,0],[527,6,527,26,0],[528,6,528,20,0],[529,7,529,59,0],[526,40,526,43,0],[526,21,526,38,0],[533,5,533,33,0],[538,5,538,47,0],[541,5,541,71,0],[523,4,523,24,0],[548,4,548,26,0],[551,4,551,57,0],[554,4,554,31,0],[557,4,557,48,0],[558,4,558,48,0],[562,4,562,89,0],[563,4,563,89,0],[565,4,565,16,0],[569,4,569,33,0],[570,3,570,4,0],[573,4,573,32,0],[574,9,574,19,0],[575,5,575,52,0],[576,6,576,33,0],[577,6,577,13,0],[574,28,574,31,0],[574,20,574,26,0],[581,4,581,71,0],[585,4,585,30,0],[603,6,603,20,0],[609,3,609,4,0],[612,4,612,52,0],[613,4,613,23,0],[614,5,614,18,0],[617,4,617,31,0],[620,4,620,33,0],[621,4,621,82,0],[623,4,623,48,0],[625,4,625,16,0],[629,4,629,40,0],[652,4,653,27,0],[654,49,654,61,0],[656,4,656,43,0],[657,4,657,30,0],[658,5,658,36,0],[660,4,660,31,0],[653,27,653,46,0],[654,28,654,49,0],[39,3,39,82,1],[40,4,40,28,1],[43,4,43,30,1],[45,4,45,26,1],[47,4,47,44,1],[48,4,48,41,1],[49,4,49,47,1],[50,4,50,61,1],[51,4,51,45,1],[52,3,52,4,1],[55,4,55,18,1],[56,3,56,4,1],[63,10,63,32,1],[68,5,68,26,1],[69,6,69,41,1],[71,4,71,5,1],[79,4,79,18,1],[80,4,80,30,1],[81,3,81,4,1],[86,32,86,44,1],[86,14,86,28,1],[87,6,87,27,1],[86,29,86,31,1],[95,5,95,30,1],[96,11,96,21,1],[97,7,97,55,1],[98,7,98,60,1],[99,7,99,26,1],[96,46,96,52,1],[96,22,96,44,1],[105,5,105,25,1],[107,3,107,4,1],[111,27,111,41,1],[111,14,111,23,1],[112,6,112,22,1],[111,24,111,26,1],[115,5,115,28,1],[116,6,116,26,1],[119,5,119,27,1],[121,3,121,4,1],[124,4,124,18,1],[125,5,125,25,1],[126,5,126,28,1],[129,4,129,23,1],[130,3,130,4,1],[145,4,145,34,1],[146,3,146,4,1],[149,4,149,40,1],[150,4,150,52,1],[151,4,151,23,1],[154,4,154,39,1],[156,4,156,63,1],[159,4,159,53,1],[161,4,161,33,1],[162,4,162,82,1],[164,4,164,48,1],[165,3,165,4,1],[173,4,173,34,1],[176,4,176,52,1],[177,4,177,23,1],[180,4,180,25,1],[181,5,181,42,1],[182,6,182,33,1],[184,3,184,4,1],[224,4,224,32,1],[225,9,225,19,1],[226,5,226,57,1],[227,6,227,29,1],[225,28,225,31,1],[225,20,225,26,1],[235,4,235,31,1],[238,4,238,29,1],[239,4,239,31,1],[240,3,240,4,1],[243,4,243,31,1],[246,4,246,41,1],[246,67,246,69,1],[247,4,247,16,1],[248,5,248,31,1],[249,5,249,42,1],[250,5,250,30,1],[251,5,251,30,1],[252,6,252,40,1],[254,5,254,29,1],[255,5,255,32,1],[258,5,258,47,1],[259,5,259,34,1],[261,3,261,4,1],[264,4,264,31,1],[267,4,267,30,1],[268,4,268,37,1],[269,3,269,4,1],[276,4,277,31,1],[278,87,278,89,1],[291,4,291,57,1],[292,4,292,28,1],[295,4,295,46,1],[296,4,296,32,1],[300,4,300,31,1],[303,4,303,38,1],[303,83,303,85,1],[332,4,332,36,1],[336,4,336,54,1],[340,4,340,32,1],[344,4,345,38,1],[349,4,349,29,1],[355,4,355,53,1],[356,5,356,18,1],[358,4,358,52,1],[360,4,360,23,1],[366,5,366,41,1],[369,5,369,35,1],[372,4,372,17,1],[376,4,376,26,1],[379,4,379,34,1],[381,4,381,51,1],[382,5,382,29,1],[389,4,389,47,1],[389,103,389,105,1],[391,4,391,34,1],[392,4,392,19,1],[394,30,394,44,1],[394,13,394,26,1],[395,5,395,27,1],[396,6,396,44,1],[397,11,397,21,1],[398,7,398,49,1],[397,38,397,41,1],[397,22,397,36,1],[394,27,394,29,1],[403,4,403,16,1],[456,4,456,34,1],[460,4,461,23,1],[462,72,462,74,1],[467,4,467,56,1],[469,4,469,30,1],[471,4,471,105,1],[473,4,473,17,1],[590,4,590,54,1],[591,4,591,22,1],[592,5,592,28,1],[595,4,595,40,1],[596,4,596,32,1],[597,4,597,34,1],[599,4,599,96,1],[600,27,600,31,1],[600,13,600,23,1],[601,5,602,52,1],[600,24,600,26,1],[608,4,608,19,1],[633,4,633,31,1],[634,5,634,50,1],[636,4,636,34,1],[637,3,637,4,1],[640,4,640,38,1],[644,4,644,42,1],[645,4,645,42,1],[646,9,646,19,1],[647,5,647,52,1],[646,41,646,44,1],[646,20,646,39,1],[649,3,649,4,1],[389,47,389,64,1],[389,83,389,103,1],[461,23,461,38,1],[246,41,246,67,1],[277,31,278,87,1],[303,38,303,83,1],[462,35,462,72,1]]);
    </script>
  </body>
</html>