<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.expressions\expressionevaluatorvisitor.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;

using Deveel.Data.DbSystem;
using Deveel.Data.Routines;
using Deveel.Data.Sql.Objects;
using Deveel.Data.Types;

namespace Deveel.Data.Sql.Expressions {
	class ExpressionEvaluatorVisitor : SqlExpressionVisitor {
		private readonly EvaluateContext context;

		public ExpressionEvaluatorVisitor(EvaluateContext context) {
			this.context = context;
		}

		public override SqlExpression Visit(SqlExpression expression) {
			if (expression is QueryReferenceExpression)
				return VisitQueryReference((QueryReferenceExpression) expression);

			return base.Visit(expression);
		}

		private SqlExpression VisitQueryReference(QueryReferenceExpression expression) {
			var reference = expression.Reference;
			var value = reference.Evaluate(context.VariableResolver);
			return SqlExpression.Constant(value);
		}

		private SqlExpression[] EvaluateSides(SqlBinaryExpression binary) {
			var info = new List&lt;BinaryEvaluateInfo&gt; {
				new BinaryEvaluateInfo {Expression = binary.Left, Offset = 0},
				new BinaryEvaluateInfo {Expression = binary.Right, Offset = 1}
			}.OrderByDescending(x =&gt; x.Precedence);

			foreach (var evaluateInfo in info) {
				evaluateInfo.Expression = Visit(evaluateInfo.Expression);
			}

			return info.OrderBy(x =&gt; x.Offset)
				.Select(x =&gt; x.Expression)
				.ToArray();
		}

		private SqlExpression EvaluateBinary(SqlExpression left, SqlExpressionType binaryType, SqlExpression right) {
			if (left.ExpressionType != SqlExpressionType.Constant)
				throw new ExpressionEvaluateException(&quot;The evaluated left side of a binary expression is not constant&quot;);
			if (right.ExpressionType != SqlExpressionType.Constant)
				throw new ExpressionEvaluateException(&quot;The evaluated right side of a binary expression is not constant.&quot;);

			var value1 = ((SqlConstantExpression) left).Value;
			var value2 = ((SqlConstantExpression) right).Value;

			var result = EvaluateBinary(value1, binaryType, value2);

			return SqlExpression.Constant(result);
		}

		private DataObject EvaluateBinary(DataObject left, SqlExpressionType binaryType, DataObject right) {
			switch (binaryType) {
				case SqlExpressionType.Add:
					return left.Add(right);
				case SqlExpressionType.Subtract:
					return left.Subtract(right);
				case SqlExpressionType.Multiply:
					return left.Multiply(right);
				case SqlExpressionType.Divide:
					return left.Divide(right);
				case SqlExpressionType.Modulo:
					return left.Modulus(right);
				case SqlExpressionType.GreaterThan:
					return left.IsGreaterThan(right);
				case SqlExpressionType.GreaterOrEqualThan:
					return left.IsGreterOrEqualThan(right);
				case SqlExpressionType.SmallerThan:
					return left.IsSmallerThan(right);
				case SqlExpressionType.SmallerOrEqualThan:
					return left.IsSmallerOrEqualThan(right);
				case SqlExpressionType.Equal:
					return left.IsEqualTo(right);
				case SqlExpressionType.NotEqual:
					return left.IsNotEqualTo(right);
				case SqlExpressionType.Is:
					return left.Is(right);
				case SqlExpressionType.IsNot:
					return left.IsNot(right);
				case SqlExpressionType.Like:
					return left.IsLike(right);
				case SqlExpressionType.NotLike:
					return left.IsNotLike(right);
				case SqlExpressionType.And:
					return left.And(right);
				case SqlExpressionType.Or:
					return left.Or(right);
				case SqlExpressionType.XOr:
					return left.XOr(right);
				// TODO: ANY and ALL
				default:
					throw new ExpressionEvaluateException(String.Format(&quot;The type {0} is not a binary expression or is not supported.&quot;, binaryType));
			}
		}

		public override SqlExpression VisitBinary(SqlBinaryExpression binaryEpression) {
			var sides = EvaluateSides(binaryEpression);

			var newLeft = sides[0];
			var newRight = sides[1];

			return EvaluateBinary(newLeft, binaryEpression.ExpressionType, newRight);
		}

		public override SqlExpression VisitCast(SqlCastExpression castExpression) {
			var valueExp = Visit(castExpression.Value);
			if (valueExp.ExpressionType != SqlExpressionType.Constant)
				throw new ExpressionEvaluateException(String.Format(&quot;Cannot CAST an expression of type {0}.&quot;, valueExp.ExpressionType));

			var value = ((SqlConstantExpression) valueExp).Value;
			var casted = value.CastTo(castExpression.DataType);
			return SqlExpression.Constant(casted);
		}

		public override SqlExpression VisitConstant(SqlConstantExpression constant) {
			var value = constant.Value;
			if (value.IsNull)
				return constant;

			var obj = value.Value;
			if (obj is SqlQueryObject) {
				return EvaluateQueryPlan((SqlQueryObject) obj);
			}

			return base.VisitConstant(constant);
		}

		private SqlConstantExpression EvaluateQueryPlan(SqlQueryObject obj) {
			if (context.QueryContext == null)
				throw new ExpressionEvaluateException(&quot;A query context is required to evaluate a query.&quot;);

			try {
				var plan = obj.QueryPlan;
				var result = plan.Evaluate(context.QueryContext);

				return SqlExpression.Constant(new DataObject(new TabularType(), SqlTabular.From(result)));
			} catch (ExpressionEvaluateException) {
				throw;
			} catch (Exception ex) {
				throw new ExpressionEvaluateException(&quot;Could not evaluate a query.&quot;, ex);
			}
		}

		public override SqlExpression VisitFunctionCall(SqlFunctionCallExpression expression) {
			try {
				var invoke = new Invoke(expression.FunctioName, expression.Arguments);
				var result = invoke.Execute(context.QueryContext, context.VariableResolver, context.GroupResolver);
				return SqlExpression.Constant(result);
			} catch (ExpressionEvaluateException) {
				throw;
			} catch (Exception ex) {
				throw new ExpressionEvaluateException(&quot;Could not evaluate a FUNCTION because of an error.&quot;, ex);
			}
		}

		public override SqlExpression VisitQuery(SqlQueryExpression query) {
			if (context.DatabaseContext == null)
				throw new ExpressionEvaluateException(&quot;A database context is required to evaluate a query.&quot;);
			if (context.QueryContext == null)
				throw new ExpressionEvaluateException(&quot;A query expression is required to evaluate a query.&quot;);

			try {
				var planner = context.DatabaseContext.QueryPlanner();
				var plan = planner.PlanQuery(context.QueryContext, query, null);
				return SqlExpression.Constant(new DataObject(new QueryType(), new SqlQueryObject(plan)));
			} catch (ExpressionEvaluateException) {
				throw;
			} catch (Exception ex) {
				throw new ExpressionEvaluateException(&quot;Evaluation of a QUERY expression could not generate a plan.&quot;, ex);
			}
		}

		public override SqlExpression VisitReference(SqlReferenceExpression reference) {
			var refName = reference.ReferenceName;

			if (context.VariableResolver == null)
				throw new ExpressionEvaluateException(String.Format(&quot;A resolver is required to dereference variable &#39;{0}&#39;.&quot;, refName));

			try {
				var value = context.VariableResolver.Resolve(refName);
				return SqlExpression.Constant(value);
			} catch (ExpressionEvaluateException) {
				throw;
			} catch (Exception ex) {
				throw new ExpressionEvaluateException(String.Format(&quot;An error occurred while trying to dereference &#39;{0}&#39; to a constant value&quot;, refName), ex);
			}
		}

		public override SqlExpression VisitUnary(SqlUnaryExpression unary) {
			var operand = Visit(unary.Operand);
			if (operand.ExpressionType != SqlExpressionType.Constant)
				throw new ExpressionEvaluateException(&quot;Operand of a unary operator could not be evaluated to a constant.&quot;);

			var result = EvaluateUnary(((SqlConstantExpression)operand).Value, unary.ExpressionType);
			return SqlExpression.Constant(result);
		}

		private DataObject EvaluateUnary(DataObject operand, SqlExpressionType unaryType) {
			switch (unaryType) {
				case SqlExpressionType.UnaryPlus:
					return operand.Reverse();
				case SqlExpressionType.Not:
					return operand.Negate();
				default:
					throw new ExpressionEvaluateException(String.Format(&quot;Expression of type &#39;{0}&#39; is not unary.&quot;, unaryType));
			}
		}

		public override SqlExpression VisitAssign(SqlAssignExpression assign) {
			if (context.QueryContext == null)
				throw new ExpressionEvaluateException(&quot;Cannot assign a variable outside a query context.&quot;);

			var valueExpression = Visit(assign.ValueExpression);

			if (valueExpression.ExpressionType != SqlExpressionType.Constant)
				throw new ExpressionEvaluateException(&quot;Cannot assign a variable from a non constant value.&quot;);

			var variableName = assign.Reference;
			var value = ((SqlConstantExpression)valueExpression).Value;

			try {
				context.QueryContext.SetVariable(variableName, value);
			} catch (Exception ex) {
				throw new ExpressionEvaluateException(String.Format(&quot;Could not assign value to variable &#39;{0}&#39;&quot;, variableName), ex);
			}

			return SqlExpression.Constant(value);
		}

		public override SqlExpression VisitTuple(SqlTupleExpression expression) {
			var list = expression.Expressions;
			if (list != null) {
				list = VisitExpressionList(list);
			}

			if (list == null)
				return SqlExpression.Constant(new DataObject(new ArrayType(-1), SqlArray.Null));
				
			return SqlExpression.Constant(new DataObject(new ArrayType(list.Length), new SqlArray(list)));
		}

		public override SqlExpression VisitVariableReference(SqlVariableReferenceExpression reference) {
			var refName = reference.VariableName;

			if (context.QueryContext == null)
				throw new ExpressionEvaluateException(String.Format(&quot;Cannot dereference variable {0} outside a query context&quot;, refName));
			if (context.VariableResolver == null)
				throw new ExpressionEvaluateException(&quot;The query context does not handle variables.&quot;);

			
			var variable = context.QueryContext.GetVariable(refName);
			if (variable == null)
				return SqlExpression.Constant(DataObject.Null());

			return base.VisitVariableReference(reference);
		}

		public override SqlExpression VisitConditional(SqlConditionalExpression conditional) {
			var evalTest = Visit(conditional.TestExpression);
			if (evalTest.ExpressionType != SqlExpressionType.Constant)
				throw new ExpressionEvaluateException(&quot;The test expression of a conditional must evaluate to a constant value.&quot;);

			var evalTestValue = ((SqlConstantExpression) evalTest).Value;
			if (!(evalTestValue.Type is BooleanType))
				throw new ExpressionEvaluateException(&quot;The test expression of a conditional must be a boolean value.&quot;);

			if (evalTestValue)
				return Visit(conditional.TrueExpression);

			if (conditional.FalseExpression != null)
				return Visit(conditional.FalseExpression);

			return SqlExpression.Constant(PrimitiveTypes.Null());
		}

		#region BinaryEvaluateInfo

		class BinaryEvaluateInfo {
			public SqlExpression Expression { get; set; }
			public int Offset { get; set; }

			public int Precedence {
				get { return Expression.EvaluatePrecedence; }
			}
		}

		#endregion
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[20,5,20,71,0],[26,4,26,41,0],[27,4,27,61,0],[28,4,28,41,0],[48,5,48,109,0],[50,5,50,111,0],[69,6,69,32,0],[71,6,71,33,0],[73,6,73,39,0],[75,6,75,45,0],[77,6,77,39,0],[79,6,79,46,0],[81,6,81,35,0],[83,6,83,38,0],[85,6,85,28,0],[87,6,87,31,0],[91,6,91,35,0],[93,6,93,29,0],[95,6,95,28,0],[97,6,97,29,0],[100,6,100,135,0],[114,4,114,47,0],[115,4,115,62,0],[116,5,116,125,0],[118,4,118,57,0],[119,4,119,55,0],[120,4,120,42,0],[126,5,126,21,0],[138,5,138,95,0],[145,6,145,41,0],[146,5,146,11,0],[147,6,147,26,0],[148,5,148,78,0],[154,5,154,75,0],[155,5,155,104,0],[156,5,156,43,0],[157,6,157,41,0],[158,5,158,11,0],[159,6,159,26,0],[160,5,160,101,0],[162,3,162,4,0],[166,5,166,98,0],[168,5,168,98,0],[174,6,174,41,0],[175,5,175,11,0],[176,6,176,26,0],[177,5,177,110,0],[185,5,185,124,0],[190,6,190,41,0],[191,5,191,11,0],[192,6,192,26,0],[193,5,193,146,0],[198,4,198,39,0],[199,4,199,61,0],[200,5,200,112,0],[202,4,202,93,0],[203,4,203,42,0],[207,4,207,22,0],[209,6,209,31,0],[211,6,211,30,0],[213,6,213,112,0],[218,4,218,37,0],[219,5,219,96,0],[221,4,221,56,0],[223,4,223,69,0],[224,5,224,98,0],[226,4,226,40,0],[227,4,227,63,0],[230,5,230,59,0],[231,6,231,26,0],[232,5,232,120,0],[235,4,235,41,0],[239,4,239,38,0],[240,4,240,21,0],[241,5,241,38,0],[244,4,244,21,0],[245,5,245,85,0],[247,4,247,98,0],[251,4,251,41,0],[253,4,253,37,0],[254,5,254,126,0],[255,4,255,41,0],[256,5,256,91,0],[259,4,259,61,0],[260,4,260,25,0],[261,5,261,54,0],[263,4,263,50,0],[267,4,267,53,0],[268,4,268,62,0],[269,5,269,118,0],[271,4,271,65,0],[272,4,272,45,0],[273,5,273,108,0],[275,4,275,22,0],[276,5,276,46,0],[278,4,278,44,0],[279,5,279,47,0],[281,4,281,57,0],[14,3,14,61,1],[15,4,15,27,1],[16,3,16,4,1],[19,4,19,47,1],[22,4,22,34,1],[32,4,35,29,1],[35,41,35,43,1],[37,33,37,37,1],[37,13,37,29,1],[38,5,38,62,1],[37,30,37,32,1],[41,4,41,29,1],[42,30,43,16,1],[47,4,47,58,1],[49,4,49,59,1],[52,4,52,54,1],[53,4,53,55,1],[55,4,55,60,1],[57,4,57,42,1],[61,4,61,23,1],[63,6,63,29,1],[65,6,65,34,1],[67,6,67,34,1],[89,6,89,32,1],[105,4,105,47,1],[107,4,107,27,1],[108,4,108,28,1],[110,4,110,77,1],[124,4,124,31,1],[125,4,125,21,1],[128,4,128,26,1],[129,4,129,30,1],[130,5,130,52,1],[133,4,133,40,1],[137,4,137,37,1],[141,5,141,30,1],[142,5,142,54,1],[144,5,144,95,1],[150,3,150,4,1],[165,4,165,40,1],[167,4,167,37,1],[171,5,171,58,1],[172,5,172,69,1],[173,5,173,94,1],[179,3,179,4,1],[182,4,182,42,1],[184,4,184,41,1],[188,5,188,59,1],[189,5,189,42,1],[195,3,195,4,1],[35,29,35,41,1],[41,29,41,37,1],[42,18,42,30,1],[291,11,291,48,1]]);
    </script>
  </body>
</html>