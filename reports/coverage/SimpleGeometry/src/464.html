<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.routines\invoke.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Linq;
using System.Text;

using Deveel.Data.DbSystem;
using Deveel.Data.Sql;
using Deveel.Data.Sql.Expressions;

namespace Deveel.Data.Routines {
	/// &lt;summary&gt;
	/// The information about the invocation of a routine, including
	/// the full name and arguments (as &lt;see cref=&quot;SqlExpression&quot;/&gt;).
	/// &lt;/summary&gt;
	public sealed class Invoke {
		private IFunction cached;

		/// &lt;summary&gt;
		/// Constructs a new &lt;see cref=&quot;Invoke&quot;/&gt; with the given
		/// name of the routine and no arguments.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;routineName&quot;&gt;The fully qualified name of the routine
		/// to be invoked.&lt;/param&gt;
		public Invoke(ObjectName routineName)
			: this(routineName, new SqlExpression[0]) {
		}

		/// &lt;summary&gt;
		/// Constructs a new &lt;see cref=&quot;Invoke&quot;/&gt; with the given
		/// name of the routine and the arguments.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;routineName&quot;&gt;The fully qualified name of the routine
		/// to be invoked.&lt;/param&gt;
		/// &lt;param name=&quot;arguments&quot;&gt;The arguments to pass to the routine.&lt;/param&gt;
		public Invoke(ObjectName routineName, SqlExpression[] arguments) {
			RoutineName = routineName;
			Arguments = arguments;
		}

		/// &lt;summary&gt;
		/// Gets the fully qualified name of the routine to invoke.
		/// &lt;/summary&gt;
		public ObjectName RoutineName { get; private set; }

		/// &lt;summary&gt;
		/// Gets an array of arguments to be passed to the invoked routine.
		/// &lt;/summary&gt;
		public SqlExpression[] Arguments { get; private set; }

		/// &lt;summary&gt;
		/// Gets a boolean value indicating if the arguments of the invocation represent
		/// a single &lt;c&gt;glob&lt;/c&gt; (*).
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// The &lt;c&gt;glob&lt;/c&gt; argument is a special one and it is used for functions
		/// like &lt;c&gt;COUNT&lt;/c&gt;.
		/// &lt;/remarks&gt;
		public bool IsGlobArgument {
			get {
				return Arguments != null &amp;&amp;
				       Arguments.Length == 1 &amp;&amp;
				       Arguments[0] is SqlConstantExpression &amp;&amp;
				       ((SqlConstantExpression) Arguments[0]).Value.Value.ToString() == &quot;*&quot;;
			}
		}

		/// &lt;summary&gt;
		/// Checks if the target of the invocation is an aggregate function.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;context&quot;&gt;The query context used to resolve the routine.&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns &lt;c&gt;true&lt;/c&gt; if the target routine of the invocation is a &lt;see cref=&quot;IFunction&quot;/&gt;
		/// and the &lt;see cref=&quot;IFunction.FunctionType&quot;/&gt; is &lt;see cref=&quot;FunctionType.Aggregate&quot;/&gt;,
		/// otherwise it returns &lt;c&gt;false&lt;/c&gt;.
		/// &lt;/returns&gt;
		public bool IsAggregate(IQueryContext context) {
			var resolver = context.DatabaseContext.RoutineResolver;
			if (resolver.IsAggregateFunction(this, context))
				return true;

			// Look at parameterss
			return Arguments.Any(x =&gt; x.HasAggregate(context));
		}

		/// &lt;summary&gt;
		/// Resolves the routine target of the invocation within the give context.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;context&quot;&gt;The query context used to resolve the routine.&lt;/param&gt;
		/// &lt;remarks&gt;
		/// &lt;para&gt;
		/// If the given &lt;paramref name=&quot;context&quot;/&gt; is &lt;c&gt;null&lt;/c&gt; this method will
		/// try to resolve the routine towards the 
		/// &lt;/para&gt;
		/// &lt;/remarks&gt;
		/// &lt;returns&gt;
		/// Returns an instance of &lt;see cref=&quot;IRoutine&quot;/&gt; that is the target of the invocation.
		/// &lt;/returns&gt;
		/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;
		/// If the routine could not be resolved for this call.
		/// &lt;/exception&gt;
		public IRoutine ResolveRoutine(IQueryContext context) {
			if (cached != null)
				return cached;

			IRoutineResolver resolver;
			if (context == null) {
				resolver = SystemFunctions.Factory;
			} else {
				resolver = context.DatabaseContext.RoutineResolver;
			}

			cached = resolver.ResolveRoutine(this, context) as IFunction;
			if (cached == null)
				throw new InvalidOperationException(String.Format(&quot;Unable to resolve the call {0} to a function&quot;, this));

			return cached;
		}

		public IFunction ResolveFunction(IQueryContext context) {
			return ResolveRoutine(context) as IFunction;
		}

		public IProcedure ResolveProcedure(IQueryContext context) {
			return ResolveRoutine(context) as IProcedure;
		}
		
		/// &lt;summary&gt;
		/// Resolves this routine invocation to a system function.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;
		/// Returns an instance of &lt;see cref=&quot;IFunction&quot;/&gt; that is defined in
		/// the &lt;see cref=&quot;SystemFunctions&quot;/&gt; domain.
		/// &lt;/returns&gt;
		/// &lt;seealso cref=&quot;ResolveRoutine&quot;/&gt;
		public IFunction ResolveSystemFunction() {
			return ResolveRoutine(null) as IFunction;
		}

		public ExecuteResult Execute() {
			return Execute(null);
		}

		public ExecuteResult Execute(IQueryContext context) {
			return Execute(context, null);
		}

		public ExecuteResult Execute(IQueryContext context, IVariableResolver resolver) {
			return Execute(context, resolver, null);
		}

		public ExecuteResult Execute(IQueryContext context, IVariableResolver resolver, IGroupResolver group) {
			var routine = ResolveRoutine(context);
			var executeContext = new ExecuteContext(this, routine, resolver, group, context);
			return routine.Execute(executeContext);
		}

		public override String ToString() {
			var buf = new StringBuilder();
			buf.Append(RoutineName);
			buf.Append(&#39;(&#39;);
			for (int i = 0; i &lt; Arguments.Length; ++i) {
				buf.Append(Arguments[i]);
				if (i &lt; Arguments.Length - 1) {
					buf.Append(&#39;,&#39;);
				}
			}
			buf.Append(&#39;)&#39;);
			return buf.ToString();
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[39,3,40,45,0],[41,3,41,4,0],[75,5,78,81,0],[92,4,92,59,0],[93,4,93,52,0],[94,5,94,17,0],[97,4,97,30,0],[97,53,97,55,0],[117,4,117,23,0],[118,5,118,19,0],[121,4,121,24,0],[122,5,122,40,0],[124,5,124,56,0],[127,4,127,65,0],[128,4,128,23,0],[129,5,129,110,0],[131,4,131,18,0],[135,4,135,48,0],[139,4,139,49,0],[151,4,151,45,0],[155,4,155,25,0],[159,4,159,34,0],[163,4,163,44,0],[167,4,167,42,0],[168,4,168,85,0],[169,4,169,43,0],[173,4,173,34,0],[174,4,174,28,0],[175,4,175,20,0],[176,9,176,19,0],[177,5,177,30,0],[178,5,178,34,0],[179,6,179,22,0],[176,42,176,45,0],[176,20,176,40,0],[182,4,182,20,0],[183,4,183,26,0],[97,30,97,53,0],[50,3,50,67,1],[51,4,51,30,1],[52,4,52,26,1],[53,3,53,4,1]]);
    </script>
  </body>
</html>