<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.index\storeindex.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.IO;

using Deveel.Data.Store;
using Deveel.Data.Util;

namespace Deveel.Data.Index {
	class StoreIndex : BlockIndex&lt;int&gt;, IIndex, IDisposable {
		private List&lt;IMappedBlock&gt; deletedBlocks;

		private bool disposed;

		public StoreIndex(IndexSetStore indexSetStore, int indexNumber, int maxBlockSize, IEnumerable&lt;IIndexBlock&lt;int&gt;&gt; blocks)
			: base(blocks) {
			IndexSetStore = indexSetStore;
			IndexNumber = indexNumber;
			MaxBlockSize = maxBlockSize;

			deletedBlocks = new List&lt;IMappedBlock&gt;();
		}


		public int IndexNumber { get; private set; }

		public int MaxBlockSize { get; private set; }

		public IndexSetStore IndexSetStore { get; private set; }

		public IEnumerable&lt;IIndexBlock&lt;int&gt;&gt; AllBlocks {
			get { return Blocks.AsReadOnly(); }
		}

		public IEnumerable&lt;IMappedBlock&gt; DeletedBlocks {
			get { return deletedBlocks.AsReadOnly(); }
		}

		private void AssertNotDisposed() {
			if (disposed)
				throw new ObjectDisposedException(GetType().FullName);
		}

		protected override IIndexBlock&lt;int&gt; NewBlock() {
			AssertNotDisposed();

			return new MappedBlock(this);
		}

		protected override void OnDeleteBlock(IIndexBlock&lt;int&gt; block) {
			deletedBlocks.Add((IMappedBlock) block);
		}

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing) {
			if (!disposed) {
				if (disposing) {
					if (deletedBlocks != null)
						deletedBlocks.Clear();
				}

				IndexSetStore = null;
				deletedBlocks = null;
				disposed = true;
			}
		}

		public static IMappedBlock NewMappedBlock(IndexSetStore indexSetStore, long firstEntry, long lastEntry, long blockPointer,
			int size, byte compactType, int blockSize) {
			return new MappedBlock(indexSetStore, firstEntry, lastEntry, blockPointer, size, compactType, blockSize);
		}

		#region MappedBlock

		class MappedBlock : Block, IMappedBlock, IDisposable {
			private readonly int maxBlockSize;

			private object blockLock = new object();
			private bool mutableBlock;


			public IndexSetStore IndexSetStore { get; private set; }

			private IStore Store {
				get { return IndexSetStore.Store; }
			}

			public MappedBlock(StoreIndex index)
				: base(index.MaxBlockSize) {
				IndexSetStore = index.IndexSetStore;
				maxBlockSize = index.MaxBlockSize;
				BlockPointer = -1;
			}

			public MappedBlock(IndexSetStore indexSetStore, long firstEntry, long lastEntry, long blockPointer, int size, byte compactType, int maxBlockSize) {
				IndexSetStore = indexSetStore;
				FirstEntry = firstEntry;
				LastEntry = lastEntry;
				BlockPointer = blockPointer;
				CompactType = compactType;

				this.maxBlockSize = maxBlockSize;
				Count = size;
				BaseArray = null;
			}

			public long FirstEntry { get; private set; }

			public long LastEntry { get; private set; }

			public long BlockPointer { get; private set; }

			public byte CompactType { get; private set; }

			public override int Top {
				get {
					if (Count == 0)
						throw new ApplicationException(&quot;No first int in block.&quot;);

					lock (blockLock) {
						return BaseArray == null ? (int)LastEntry : BaseArray[Count - 1];
					}
				}
			}

			public override int Bottom {
				get {
					if (Count == 0)
						throw new ApplicationException(&quot;No first int in block.&quot;);

					lock (blockLock) {
						return BaseArray == null ? (int)FirstEntry : BaseArray[0];
					}
				}
			}

			protected override int ArrayLength {
				get { return maxBlockSize; }
			}

			private void PrepareMutate(bool readOnly) {
				// If list is to be mutable
				if (!readOnly &amp;&amp; !mutableBlock) {
					BaseArray = (int[])BaseArray.Clone();
					mutableBlock = true;
				}
			}

			public long CopyTo(IStore destStore) {
				// The number of bytes per entry
				int entrySize = CompactType;
				// The total size of the entry.
				int areaSize = (Count * entrySize);

				// Allocate the destination area
				var dest = destStore.CreateArea(areaSize);
				long destOffset = dest.Id;
				Store.GetArea(BlockPointer).CopyTo(dest, areaSize);
				dest.Flush();

				return destOffset;
			}

			public long Flush() {
				// Convert the int[] array to a byte[] array.

				// First determine how we compact this int array into a byte array.  If
				// all the values are &lt; 32768 then we store as shorts
				long largestVal = 0;
				for (int i = 0; i &lt; Count; ++i) {
					long v = BaseArray[i];
					if (System.Math.Abs(v) &gt; System.Math.Abs(largestVal)) {
						largestVal = v;
					}
				}

				long lv = largestVal;
				if (lv &gt;&gt; 7 == 0 || lv &gt;&gt; 7 == -1) {
					CompactType = 1;
				} else if (lv &gt;&gt; 15 == 0 || lv &gt;&gt; 15 == -1) {
					CompactType = 2;
				} else if (lv &gt;&gt; 23 == 0 || lv &gt;&gt; 23 == -1) {
					CompactType = 3;
				}
					// NOTE: in the future we&#39;ll want to determine if we are going to store
					//   as an int or long array.
				  else {
					CompactType = 4;
				}

				// The number of bytes per entry
				int entrySize = CompactType;
				// The total size of the entry.
				int areaSize = (Count * entrySize);

				// Allocate an array to buffer the block to
				byte[] arr = new byte[areaSize];
				// Fill the array
				int p = 0;
				for (int i = 0; i &lt; Count; ++i) {
					int v = BaseArray[i];
					for (int n = entrySize - 1; n &gt;= 0; --n) {
						//TODO: check this...
						arr[p] = (byte)(ByteBuffer.URShift(v, (n * 8)) &amp; 0x0FF);
						++p;
					}
				}

				// Create an area to store this
				var a = Store.CreateArea(areaSize);
				BlockPointer = a.Id;

				a.Write(arr, 0, areaSize);
				a.Flush();

				// Once written, the block is invalidated
				blockLock = null;

				return BlockPointer;
			}

			protected override int[] GetArray(bool readOnly) {
				// We must synchronize this entire block because otherwise we could
				// return a partially loaded array.
				lock (blockLock) {
					if (BaseArray != null) {
						PrepareMutate(readOnly);
						return BaseArray;
					}

					// Create the int array
					BaseArray = new int[maxBlockSize];

					// The number of bytes per entry
					int entrySize = CompactType;
					// The total size of the entry.
					int areaSize = (Count * entrySize);

					// Read in the byte array
					byte[] buf = new byte[areaSize];
					try {
						Store.GetArea(BlockPointer).Read(buf, 0, areaSize);
					} catch (IOException e) {
						throw new ApplicationException(&quot;IO Error: &quot; + e.Message);
					}

					// Uncompact it into the int array
					int p = 0;
					for (int i = 0; i &lt; Count; ++i) {
						int v = (((int)buf[p]) &lt;&lt; ((entrySize - 1) * 8));
						++p;
						for (int n = entrySize - 2; n &gt;= 0; --n) {
							v = v | ((((int)buf[p]) &amp; 0x0FF) &lt;&lt; (n * 8));
							++p;
						}
						BaseArray[i] = v;
					}

					mutableBlock = false;
					PrepareMutate(readOnly);
					return BaseArray;
				}
			}

			public void Dispose() {
				IndexSetStore = null;
			}
		}

		#endregion
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[56,5,56,59,0],[66,4,66,44,0],[67,3,67,4,0],[137,7,137,64,0],[148,7,148,64,0],[170,5,170,33,0],[172,5,172,40,0],[175,5,175,47,0],[176,5,176,31,0],[177,5,177,56,0],[178,5,178,18,0],[180,5,180,23,0],[199,12,199,48,0],[200,6,200,22,0],[201,12,201,48,0],[202,6,202,22,0],[207,6,207,22,0],[262,8,262,29,0],[263,7,263,64,0],[272,8,272,53,0],[273,8,273,12,0],[271,43,271,46,0],[285,5,285,26,0],[286,4,286,5,0],[30,3,31,18,1],[32,4,32,34,1],[33,4,33,30,1],[34,4,34,32,1],[36,4,36,45,1],[37,3,37,4,1],[47,10,47,37,1],[51,10,51,44,1],[55,4,55,17,1],[57,3,57,4,1],[60,4,60,24,1],[62,4,62,33,1],[70,4,70,18,1],[71,4,71,30,1],[72,3,72,4,1],[75,4,75,18,1],[76,5,76,19,1],[77,6,77,32,1],[78,7,78,29,1],[81,5,81,26,1],[82,5,82,26,1],[83,5,83,21,1],[85,3,85,4,1],[89,4,89,109,1],[104,11,104,38,1],[97,4,97,44,1],[107,4,108,31,1],[109,5,109,41,1],[110,5,110,39,1],[111,5,111,23,1],[112,4,112,5,1],[114,4,114,149,1],[115,5,115,35,1],[116,5,116,29,1],[117,5,117,27,1],[118,5,118,33,1],[119,5,119,31,1],[121,5,121,38,1],[122,5,122,18,1],[123,5,123,22,1],[124,4,124,5,1],[136,6,136,21,1],[139,6,139,22,1],[140,7,140,72,1],[142,5,142,6,1],[147,6,147,21,1],[150,6,150,22,1],[151,7,151,65,1],[153,5,153,6,1],[157,11,157,31,1],[162,5,162,36,1],[163,6,163,43,1],[164,6,164,26,1],[166,4,166,5,1],[188,5,188,25,1],[189,10,189,20,1],[190,6,190,28,1],[191,6,191,59,1],[192,7,192,22,1],[189,32,189,35,1],[189,21,189,30,1],[196,5,196,26,1],[197,5,197,39,1],[198,6,198,22,1],[211,5,211,33,1],[213,5,213,40,1],[216,5,216,37,1],[218,5,218,15,1],[219,10,219,20,1],[220,6,220,27,1],[221,11,221,33,1],[223,7,223,63,1],[224,7,224,11,1],[221,42,221,45,1],[221,34,221,40,1],[219,32,219,35,1],[219,21,219,30,1],[229,5,229,40,1],[230,5,230,25,1],[232,5,232,31,1],[233,5,233,15,1],[236,5,236,22,1],[238,5,238,25,1],[244,5,244,21,1],[245,6,245,28,1],[246,7,246,31,1],[247,7,247,24,1],[251,6,251,40,1],[254,6,254,34,1],[256,6,256,41,1],[259,6,259,38,1],[261,7,261,58,1],[267,6,267,16,1],[268,11,268,21,1],[269,7,269,56,1],[270,7,270,11,1],[271,12,271,34,1],[271,35,271,41,1],[275,7,275,24,1],[268,33,268,36,1],[268,22,268,31,1],[278,6,278,27,1],[279,6,279,30,1],[280,6,280,23,1],[282,4,282,5,1]]);
    </script>
  </body>
</html>