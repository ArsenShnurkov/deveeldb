<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.query\querytableplanner.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;

using Deveel.Data.Sql.Expressions;

namespace Deveel.Data.Sql.Query {
	class QueryTablePlanner {
		private List&lt;TablePlan&gt; tablePlans;

		public QueryTablePlanner() {
			tablePlans = new List&lt;TablePlan&gt;();
			HasJoin = false;
		}

		public bool HasJoin { get; private set; }

		public TablePlan SinglePlan {
			get {
				if (tablePlans.Count != 1)
					throw new InvalidOperationException(&quot;The planner has more than one table.&quot;);

				return tablePlans[0];
			}
		}

		private int IndexOfPlan(TablePlan plan) {
			int sz = tablePlans.Count;
			for (int i = 0; i &lt; sz; ++i) {
				if (tablePlans[i] == plan)
					return i;
			}

			return -1;
		}

		private static TablePlan ConcatPlans(TablePlan left, TablePlan right, IQueryPlanNode plan) {
			// Merge the variable list
			var newVarList = new ObjectName[left.ColumnNames.Length + right.ColumnNames.Length];
			Array.Copy(left.ColumnNames, 0, newVarList, 0, left.ColumnNames.Length);
			Array.Copy(right.ColumnNames, 0, newVarList, left.ColumnNames.Length - 1, right.ColumnNames.Length);

			// Merge the unique table names list
			var newUniqueList = new string[left.UniqueNames.Length + right.UniqueNames.Length];
			Array.Copy(left.UniqueNames, 0, newUniqueList, 0, left.UniqueNames.Length);
			Array.Copy(right.UniqueNames, 0, newUniqueList, left.UniqueNames.Length - 1, right.UniqueNames.Length);

			// Return the new table source plan.
			return new TablePlan(plan, newVarList, newUniqueList);
		}

		private TablePlan MergePlans(TablePlan left, TablePlan right, IQueryPlanNode mergePlan) {
			// Remove the sources from the table list.
			tablePlans.Remove(left);
			tablePlans.Remove(right);

			// Add the concatenation of the left and right tables.
			var newPlan = ConcatPlans(left, right, mergePlan);
			newPlan.MergeJoin(left, right);
			newPlan.SetUpdated();

			AddPlan(newPlan);

			return newPlan;
		}

		private TablePlan FindPlan(ObjectName reference) {
			// If there is only 1 plan then assume the variable is in there.
			if (tablePlans.Count == 1)
				return tablePlans[0];

			foreach (var source in tablePlans) {
				if (source.ContainsColumn(reference))
					return source;
			}

			throw new ArgumentException(&quot;Unable to find table with variable reference: &quot; + reference);
		}

		private TablePlan FindCommonPlan(IList&lt;ObjectName&gt; columnNames) {
			if (columnNames.Count == 0)
				return null;

			TablePlan pivotPlan = null;
			foreach (var columnName in columnNames) {
				var plan = FindPlan(columnName);
				if (pivotPlan == null) {
					pivotPlan = plan;
				} else if (plan != pivotPlan) {
					return null;
				}
			}

			return pivotPlan;
		}

		private void SetCachePoints() {
			foreach (var plan in tablePlans) {
				plan.SetCachePoint();
			}
		}

		private TablePlan JoinPlansForColumns(IEnumerable&lt;ObjectName&gt; columnNames) {
			// Collect all the plans that encapsulate these variables.
			var touchedPlans = new List&lt;TablePlan&gt;();

			foreach (var name in columnNames) {
				var plan = FindPlan(name);

				if (!touchedPlans.Contains(plan))
					touchedPlans.Add(plan);
			}

			return JoinToSingle(touchedPlans);
		}

		private TablePlan NaturalJoinAll() {
			int sz = tablePlans.Count;
			if (sz == 1)
				return tablePlans[0];

			// Produce a plan that naturally joins all tables.
			return JoinToSingle(tablePlans);
		}

		private static int AssertBeNaturalJoin(TablePlan plan1, TablePlan plan2) {
			if (plan1.LeftPlan == plan2 || plan1.RightPlan == plan2)
				return 0;
			if (plan1.LeftPlan != null &amp;&amp; plan2.LeftPlan != null)
				// This is a left clash
				return 2;
			if (plan1.RightPlan != null &amp;&amp; plan2.RightPlan != null)
				// This is a right clash
				return 1;
			if ((plan1.LeftPlan == null &amp;&amp; plan2.RightPlan == null) ||
				(plan1.RightPlan == null &amp;&amp; plan2.LeftPlan == null))
				// This means a merge between the plans is fine
				return 0;

			// Must be a left and right clash
			return 2;
		}

		private TablePlan NaturallyJoinPlans(TablePlan plan1, TablePlan plan2) {
			JoinType joinType;
			SqlExpression onExpr;
			TablePlan leftPlan, rightPlan;

			// Are the plans linked by common join information?
			if (plan1.RightPlan == plan2) {
				joinType = plan1.RightJoinType;
				onExpr = plan1.RightOnExpression;
				leftPlan = plan1;
				rightPlan = plan2;
			} else if (plan1.LeftPlan == plan2) {
				joinType = plan1.LeftJoinType;
				onExpr = plan1.LeftOnExpression;
				leftPlan = plan2;
				rightPlan = plan1;
			} else {
				// Assertion - make sure no join clashes!
				if ((plan1.LeftPlan != null &amp;&amp; plan2.LeftPlan != null) ||
					(plan1.RightPlan != null &amp;&amp; plan2.RightPlan != null)) {
					throw new InvalidOperationException(&quot;Plans can not be naturally join because &quot; +
					                                    &quot;the left/right join plans clash.&quot;);
				}

				// Else we must assume a non-dependent join (not an outer join).
				// Perform a natural join
				IQueryPlanNode node1 = new NaturalJoinNode(plan1.Plan, plan2.Plan);
				return MergePlans(plan1, plan2, node1);
			}

			// This means plan1 and plan2 are linked by a common join and ON
			// expression which we evaluate now.
			bool outerJoin;
			if (joinType == JoinType.Left) {
				// Mark the left plan
				leftPlan.UpdatePlan(new MarkerNode(leftPlan.Plan, &quot;OUTER_JOIN&quot;));
				outerJoin = true;
			} else if (joinType == JoinType.Right) {
				// Mark the right plan
				rightPlan.UpdatePlan(new MarkerNode(rightPlan.Plan, &quot;OUTER_JOIN&quot;));
				outerJoin = true;
			} else if (joinType == JoinType.Inner) {
				// Inner join with ON expression
				outerJoin = false;
			} else {
				throw new InvalidOperationException(String.Format(&quot;Join type ({0}) is not supported.&quot;, joinType));
			}

			// Make a Planner object for joining these plans.
			var planner = new QueryTablePlanner();
			planner.AddPlan(leftPlan.Clone());
			planner.AddPlan(rightPlan.Clone());

			// Evaluate the on expression
			var node = planner.LogicalEvaluate(onExpr);

			// If outer join add the left outer join node
			if (outerJoin)
				node = new LeftOuterJoinNode(node, &quot;OUTER_JOIN&quot;);

			// And merge the plans in this set with the new node.
			return MergePlans(plan1, plan2, node);
		}

		private TablePlan JoinToSingle(IList&lt;TablePlan&gt; allPlans) {
			// If there are no plans then return null
			if (allPlans.Count == 0)
				return null;

			if (allPlans.Count == 1)
				// Return early if there is only 1 table.
				return allPlans[0];

			// Make a working copy of the plan list.
			var workingPlanList = new List&lt;TablePlan&gt;(allPlans);

			// We go through each plan in turn.
			while (workingPlanList.Count &gt; 1) {
				var leftPlan = workingPlanList[0];
				var rightPlan = workingPlanList[1];

				// First we need to determine if the left and right plan can be
				// naturally joined.
				int status = AssertBeNaturalJoin(leftPlan, rightPlan);
				if (status == 0) {
					// Yes they can so join them
					var newPlan = NaturallyJoinPlans(leftPlan, rightPlan);

					// Remove the left and right plan from the list and add the new plan
					workingPlanList.Remove(leftPlan);
					workingPlanList.Remove(rightPlan);
					workingPlanList.Insert(0, newPlan);
				} else if (status == 1) {
					// No we can&#39;t because of a right join clash, so we join the left
					// plan right in hopes of resolving the clash.
					var newPlan = NaturallyJoinPlans(leftPlan, leftPlan.RightPlan);
					workingPlanList.Remove(leftPlan);
					workingPlanList.Remove(leftPlan.RightPlan);
					workingPlanList.Insert(0, newPlan);
				} else if (status == 2) {
					// No we can&#39;t because of a left join clash, so we join the left
					// plan left in hopes of resolving the clash.
					var newPlan = NaturallyJoinPlans(leftPlan, leftPlan.LeftPlan);
					workingPlanList.Remove(leftPlan);
					workingPlanList.Remove(leftPlan.LeftPlan);
					workingPlanList.Insert(0, newPlan);
				} else {
					throw new InvalidOperationException(String.Format(&quot;Natural join assessed status {0} is unknown.&quot;, status));
				}
			}

			// Return the working plan of the merged tables.
			return workingPlanList[0];
		}

		private IQueryPlanNode LogicalEvaluate(SqlExpression expression) {
			if (expression == null) {
				// Naturally join everything and return the plan.
				NaturalJoinAll();
				return SinglePlan.Plan;
			}

			// Plan the expression
			PlanExpression(expression);

			// Naturally join any straggling tables
			NaturalJoinAll();

			// Return the plan
			return SinglePlan.Plan;
		}

		private static void AddSingleColumnPlan(IList&lt;SingleColumnPlan&gt; list, TablePlan table, ObjectName columnName, ObjectName uniqueName, SqlExpression[] expParts, SqlExpressionType op) {
			var exp = SqlExpression.Binary(expParts[0], op, expParts[1]);

			// Is this source in the list already?
			foreach (var existingPlan in list) {
				if (existingPlan.TablePlan == table &amp;&amp;
					(columnName == null || existingPlan.ColumnName.Equals(columnName))) {
					// Append to end of current expression
					existingPlan.SetSource(columnName, SqlExpression.And(existingPlan.Expression, exp));
					return;
				}
			}

			// Didn&#39;t find so make a new entry in the list.
			list.Add(new SingleColumnPlan(table, columnName, uniqueName, exp));
		}

		private QueryTablePlanner Clone() {
			var copy = new QueryTablePlanner();

			int sz = tablePlans.Count;
			for (int i = 0; i &lt; sz; ++i) {
				copy.tablePlans.Add(tablePlans[i].Clone());
			}

			// Copy the left and right links in the PlanTableSource
			for (int i = 0; i &lt; sz; ++i) {
				var src = tablePlans[i];
				var mod = copy.tablePlans[i];

				// See how the left plan links to which index,
				if (src.LeftPlan != null) {
					int n = IndexOfPlan(src.LeftPlan);
					mod.LeftJoin(copy.tablePlans[n], src.LeftJoinType, src.LeftOnExpression);
				}

				// See how the right plan links to which index,
				if (src.RightPlan != null) {
					int n = IndexOfPlan(src.RightPlan);
					mod.RightJoin(copy.tablePlans[n], src.RightJoinType, src.RightOnExpression);
				}
			}

			return copy;
		}

		private void PlanAllOuterJoins() {
			int sz = tablePlans.Count;
			if (sz &lt;= 1)
				return;

			// Make a working copy of the plan list.
			var workingPlanList = new List&lt;TablePlan&gt;(tablePlans);

			var plan1 = workingPlanList[0];
			for (int i = 1; i &lt; sz; ++i) {
				var plan2 = workingPlanList[i];

				if (plan1.RightPlan == plan2) {
					plan1 = NaturallyJoinPlans(plan1, plan2);
				} else {
					plan1 = plan2;
				}
			}
		}

		private void PlanExpressionList(IEnumerable&lt;SqlExpression&gt; expressions) {
			var subLogicExpressions = new List&lt;SqlBinaryExpression&gt;();
			// The list of expressions that have a sub-select in them.
			var subQueryExpressions = new List&lt;SqlBinaryExpression&gt;();
			// The list of all constant expressions ( true = true )
			var constants = new List&lt;SqlExpression&gt;();
			// The list of pattern matching expressions (eg. &#39;t LIKE &#39;a%&#39;)
			var patternExpressions = new List&lt;SqlBinaryExpression&gt;();
			// The list of all expressions that are a single variable on one
			// side, a conditional operator, and a constant on the other side.
			var singleVars = new List&lt;SqlBinaryExpression&gt;();
			// The list of multi variable expressions (possible joins)
			var multiVars = new List&lt;SqlBinaryExpression&gt;();

			foreach (var expression in expressions) {
				SqlBinaryExpression exp;

				if (!(expression is SqlBinaryExpression)) {
					// If this is not a binary expression we imply
					// [expression] = &#39;true&#39;
					exp = SqlExpression.Equal(expression, SqlExpression.Constant(true));
				} else {
					exp = (SqlBinaryExpression) expression;
				}

				if (exp.ExpressionType.IsLogical()) {
					subLogicExpressions.Add(exp);
				} else if (exp.HasSubQuery()) {
					subQueryExpressions.Add(exp);
				} else if (exp.ExpressionType.IsPattern()) {
					patternExpressions.Add(exp);
				} else {
					// The list of variables in the expression.
					var columnNames = exp.DiscoverColumnNames().ToList();
					if (columnNames.Count == 0) {
						// These are ( 54 + 9 = 9 ), ( &quot;z&quot; &gt; &quot;a&quot; ), ( 9.01 - 2 ), etc
						constants.Add(exp);
					} else if (columnNames.Count == 1) {
						// These are ( id = 90 ), ( &#39;a&#39; &lt; number ), etc
						singleVars.Add(exp);
					} else if (columnNames.Count &gt; 1) {
						// These are ( id = part_id ),
						// ( cost_of + value_of &lt; sold_at ), ( id = part_id - 10 )
						multiVars.Add(exp);
					} else {
						throw new ApplicationException(&quot;Invalid number of column names&quot;);
					}
				}
			}

			// The order in which expression are evaluated,
			// (ExpressionPlan)
			var evaluateOrder = new List&lt;ExpressionPlan&gt;();

			// Evaluate the constants.  These should always be evaluated first
			// because they always evaluate to either true or false or null.
			EvaluateConstants(constants, evaluateOrder);

			// Evaluate the singles.  If formed well these can be evaluated
			// using fast indices.  eg. (a &gt; 9 - 3) is more optimal than
			// (a + 3 &gt; 9).
			EvaluateSingles(singleVars, evaluateOrder);

			// Evaluate the pattern operators.  Note that some patterns can be
			// optimized better than others, but currently we keep this near the
			// middle of our evaluation sequence.
			EvaluatePatterns(patternExpressions, evaluateOrder);

			// Evaluate the sub-queries.  These are queries of the form,
			// (a IN ( SELECT ... )), (a = ( SELECT ... ) = ( SELECT ... )), etc.
			EvaluateSubQueries(subQueryExpressions, evaluateOrder);

			// Evaluate multiple variable expressions.  It&#39;s possible these are
			// joins.
			EvaluateMultiples(multiVars, evaluateOrder);

			// Lastly evaluate the sub-logic expressions.  These expressions are
			// OR type expressions.
			EvaluateSubLogic(subLogicExpressions, evaluateOrder);

			evaluateOrder.Sort();

			// And add each expression to the plan
			foreach (ExpressionPlan plan in evaluateOrder) {
				plan.AddToPlanTree();
			}
		}

		private void EvaluateSubLogic(List&lt;SqlBinaryExpression&gt; list, List&lt;ExpressionPlan&gt; plans) {
			foreach (var expression in list) {
				var orExprs = new[] {expression.Left, expression.Right};

				// An optimizations here;

				// If all the expressions we are ORing together are in the same table
				// then we should execute them before the joins, otherwise they
				// should go after the joins.

				// The reason for this is because if we can lesson the amount of work a
				// join has to do then we should.  The actual time it takes to perform
				// an OR search shouldn&#39;t change if it is before or after the joins.

				TablePlan common = null;

				foreach (var orExpr in orExprs) {
					var vars = orExpr.DiscoverColumnNames().ToArray();

					bool breakRule = false;

					// If there are no variables then don&#39;t bother with this expression
					if (vars.Any()) {
						// Find the common table source (if any)
						var ts = FindCommonPlan(vars);
						bool orAfterJoins = false;
						if (ts == null) {
							// No common table, so OR after the joins
							orAfterJoins = true;
						} else if (common == null) {
							common = ts;
						} else if (common != ts) {
							// No common table with the vars in this OR list so do this OR
							// after the joins.
							orAfterJoins = true;
						}

						if (orAfterJoins) {
							plans.Add(new SubLogicPlan(this, expression, 0.70f));

							// Continue to the next logic expression
							breakRule = true;
						}
					}

					if (!breakRule) {
						// Either we found a common table or there are no variables in the OR.
						// Either way we should evaluate this after the join.
						plans.Add(new SubLogicPlan(this, expression, 0.58f));
					}
				}
			}
		}

		private void EvaluateMultiples(List&lt;SqlBinaryExpression&gt; list, List&lt;ExpressionPlan&gt; plans) {
			// FUTURE OPTIMIZATION:
			//   This join order planner is a little primitive in design.  It orders
			//   optimizable joins first and least optimizable last, but does not
			//   take into account other factors that we could use to optimize
			//   joins in the future.

			foreach (var expression in list) {
				// Get the list of variables in the left hand and right hand side
				var lhsVar = expression.Left.AsReferenceName();
				var rhsVar = expression.Right.AsReferenceName();

				// Work out how optimizable the join is.
				// The calculation is as follows;
				// a) If both the lhs and rhs are a single variable then the
				//    optimizable value is set to 0.6f.
				// b) If only one of lhs or rhs is a single variable then the
				//    optimizable value is set to 0.64f.
				// c) Otherwise it is set to 0.68f (exhaustive select guarenteed).

				if (lhsVar == null &amp;&amp; rhsVar == null) {
					// Neither lhs or rhs are single vars
					plans.Add(new ExhaustiveJoinPlan(this, expression));
				} else if (lhsVar != null &amp;&amp; rhsVar != null) {
					// Both lhs and rhs are a single var (most optimizable type of
					// join).
					plans.Add(new StandardJoinPlan(this, expression, 0.60f));
				} else {
					// Either lhs or rhs is a single var
					plans.Add(new StandardJoinPlan(this, expression, 064f));
				}
			}
		}

		private void EvaluateSubQueries(List&lt;SqlBinaryExpression&gt; list, List&lt;ExpressionPlan&gt; plans) {
			foreach (var expression in list) {
				bool exhaustive;

				var op = expression.ExpressionType;
				if (op.IsSubQuery()) {
					// Must be an exhaustive sub-command
					exhaustive = true;
				} else {
					// Check that the left is a simple enough variable reference
					var leftColumn = expression.Left.AsReferenceName();
					if (leftColumn == null) {
						exhaustive = true;
					} else {
						// Check that the right is a sub-command plan.
						IQueryPlanNode rightPlan = expression.Right.AsQueryPlan();
						if (rightPlan == null)
							exhaustive = true;
						else {
							// Finally, check if the plan is correlated or not
							var cv = rightPlan.DiscoverQueryReferences(1);
							exhaustive = cv.Count != 0;
						}
					}
				}

				if (exhaustive) {
					// This expression could involve multiple variables, so we may need
					// to join.
					var columnNames = expression.DiscoverColumnNames().ToList();

					// Also find all correlated variables.
					int level = 0;
					var allCorrelated = expression.DiscoverQueryReferences(ref level);
					int sz = allCorrelated.Count;

					// If there are no variables (and no correlated variables) then this
					// must be a constant select, For example, 3 in ( select ... )
					if (!columnNames.Any() &amp;&amp; sz == 0) {
						plans.Add(new ConstantPlan(this, expression));
					} else {
						columnNames.AddRange(allCorrelated.Select(cv =&gt; cv.Name));

						// An exhaustive expression plan which might require a join or a
						// slow correlated search.  This should be evaluated after the
						// multiple variables are processed.
						plans.Add(new ExhaustiveSubQueryPlan(this, columnNames.ToArray(), expression));
					}
				} else {
					plans.Add(new SimpleSubQueryPlan(this, expression));
				}
			}
		}

		private void EvaluatePatterns(List&lt;SqlBinaryExpression&gt; list, List&lt;ExpressionPlan&gt; plans) {
			foreach (var expression in list) {
				// If the LHS is a single column and the RHS is a constant then
				// the conditions are right for a simple pattern search.
				var leftColumnName = expression.Left.AsReferenceName();

				if (expression.IsConstant()) {
					plans.Add(new ConstantPlan(this, expression));
				} else if (leftColumnName != null &amp;&amp;
				           expression.Right.IsConstant()) {
					plans.Add(new SimplePatternPlan(this, leftColumnName, expression));
				} else {
					// Otherwise we must assume a complex pattern search which may
					// require a join.  For example, &#39;a + b LIKE &#39;a%&#39;&#39; or
					// &#39;a LIKE b&#39;.  At the very least, this will be an exhaustive
					// search and at the worst it will be a join + exhaustive search.
					// So we should evaluate these at the end of the evaluation order.
					plans.Add(new ExhaustiveSelectPlan(this, expression));
				}
			}
		}

		private void EvaluateSingles(List&lt;SqlBinaryExpression&gt; list, List&lt;ExpressionPlan&gt; plans) {
			// The list of simple expression plans (lhs = single)
			var simplePlanList = new List&lt;SingleColumnPlan&gt;();
			// The list of complex function expression plans (lhs = expression)
			var complexPlanList = new List&lt;SingleColumnPlan&gt;();

			foreach (var expression in list) {
				// The single var
				ObjectName singleVar;
				SqlExpressionType op = expression.ExpressionType;
				SqlExpression left = expression.Left, right = expression.Right;

				if (op.IsSubQuery()) {
					singleVar = expression.Left.AsReferenceName();

					if (singleVar != null) {
						plans.Add(new SimpleSelectPlan(this, singleVar, op, expression.Right));
					} else {
						singleVar = expression.Left.DiscoverColumnNames().First();
						plans.Add(new ComplexSinglePlan(this, singleVar, expression));
					}
				} else {
					singleVar = expression.Left.DiscoverColumnNames().FirstOrDefault();
					if (singleVar == null) {
						// Reverse the expressions and the operator
						var tempExp = left;
						left = right;
						right = tempExp;
						op = op.Reverse();
						singleVar = left.DiscoverColumnNames().First();
					}

					var tableSource = FindPlan(singleVar);

					// Simple LHS?
					var v = left.AsReferenceName();
					if (v != null) {
						AddSingleColumnPlan(simplePlanList, tableSource, v, singleVar, new []{left, right}, op);
					} else {
						// No, complex lhs
						AddSingleColumnPlan(complexPlanList, tableSource, null, singleVar, new []{left, right}, op);
					}
				}
			}

			plans.AddRange(simplePlanList.Select(plan =&gt; new SimpleSinglePlan(this, plan.UniqueName, plan.Expression)).Cast&lt;ExpressionPlan&gt;());
			plans.AddRange(complexPlanList.Select(plan =&gt; new ComplexSinglePlan(this, plan.UniqueName, plan.Expression)).Cast&lt;ExpressionPlan&gt;());
		}

		private void EvaluateConstants(List&lt;SqlExpression&gt; list, List&lt;ExpressionPlan&gt; plans) {
			// For each constant variable
			plans.AddRange(list.Select(expr =&gt; new ConstantPlan(this, expr)).Cast&lt;ExpressionPlan&gt;());
		}

		private void PlanExpression(SqlExpression expression) {
			if (expression is SqlBinaryExpression &amp;&amp;
				expression.ExpressionType.IsLogical()) {
				var binary = (SqlBinaryExpression) expression;

				if (expression.ExpressionType == SqlExpressionType.Or) {
					// parsing an OR block
					// Split left and right of logical operator.
					var exps = new[]{binary.Left, binary.Right};

					// If we are an &#39;or&#39; then evaluate left and right and union the
					// result.

					// Before we branch set cache points.
					SetCachePoints();

					// Make copies of the left and right planner
					var leftPlanner = Clone();
					var rightPlanner = Clone();

					// Plan the left and right side of the OR
					leftPlanner.PlanExpression(exps[0]);
					rightPlanner.PlanExpression(exps[1]);

					// Fix the left and right planner so that they represent the same
					// &#39;group&#39;.
					// The current implementation naturally joins all sources if the
					// number of sources is different than the original size.
					int leftSz = leftPlanner.tablePlans.Count;
					int rightSz = rightPlanner.tablePlans.Count;
					if (leftSz != rightSz || leftPlanner.HasJoin || rightPlanner.HasJoin) {
						// Naturally join all in the left and right plan
						leftPlanner.NaturalJoinAll();
						rightPlanner.NaturalJoinAll();
					}

					// Union all table sources, but only if they have changed.
					var leftTableList = leftPlanner.tablePlans;
					var rightTableList = rightPlanner.tablePlans;
					int sz = leftTableList.Count;

					// First we must determine the plans that need to be joined in the
					// left and right plan.
					var leftJoinList = new List&lt;TablePlan&gt;();
					var rightJoinList = new List&lt;TablePlan&gt;();
					for (int i = 0; i &lt; sz; ++i) {
						var leftPlan = leftTableList[i];
						var rightPlan = rightTableList[i];
						if (leftPlan.IsUpdated || rightPlan.IsUpdated) {
							leftJoinList.Add(leftPlan);
							rightJoinList.Add(rightPlan);
						}
					}

					// Make sure the plans are joined in the left and right planners
					leftPlanner.JoinToSingle(leftJoinList);
					rightPlanner.JoinToSingle(rightJoinList);

					// Since the planner lists may have changed we update them here.
					leftTableList = leftPlanner.tablePlans;
					rightTableList = rightPlanner.tablePlans;
					sz = leftTableList.Count;

					var newTableList = new List&lt;TablePlan&gt;(sz);

					for (int i = 0; i &lt; sz; ++i) {
						var leftPlan = leftTableList[i];
						var rightPlan = rightTableList[i];

						TablePlan newPlan;

						// If left and right plan updated so we need to union them
						if (leftPlan.IsUpdated || rightPlan.IsUpdated) {
							// In many causes, the left and right branches will contain
							//   identical branches that would best be optimized out.

							// Take the left plan, add the logical union to it, and make it
							// the plan for this.
							var node = new LogicalUnionNode(leftPlan.Plan, rightPlan.Plan);

							// Update the plan in this table list
							leftPlan.UpdatePlan(node);

							newPlan = leftPlan;
						} else {
							// If the left and right plan didn&#39;t update, then use the
							// left plan (it doesn&#39;t matter if we use left or right because
							// they are the same).
							newPlan = leftPlan;
						}

						// Add the left plan to the new table list we are creating
						newTableList.Add(newPlan);

					}

					// Set the new table list
					tablePlans = newTableList;
				} else if (expression.ExpressionType == SqlExpressionType.And) {
					PlanExpressionList(new[]{binary.Left, binary.Right});
				} else {
					throw new InvalidOperationException();
				}
			} else {
				PlanExpressionList(new []{expression});
			}
		}

		public void AddPlan(TablePlan tablePlan) {
			tablePlans.Add(tablePlan);
			HasJoin = true;
		}

		public void AddPlan(IQueryPlanNode plan, IFromTableSource tableSource) {
			var columns = tableSource.ColumnNames;
			var uniqueNames = new[] {tableSource.UniqueName};
			AddPlan(new TablePlan(plan, columns, uniqueNames));
		}

		public void JoinAt(int betweenIndex, JoinType joinType, SqlExpression onExpression) {
			var planLeft = tablePlans[betweenIndex];
			var planRight = tablePlans[betweenIndex + 1];
			planLeft.RightJoin(planRight, joinType, onExpression);
			planRight.LeftJoin(planLeft, joinType, onExpression);
		}

		public IQueryPlanNode PlanSearchExpression(SqlExpression searchExpression) {
			// First perform all outer tables.
			PlanAllOuterJoins();

			return LogicalEvaluate(searchExpression);
		}

		#region SingleColumnPlan

		class SingleColumnPlan {
			public SingleColumnPlan(TablePlan tablePlan, ObjectName columnName, ObjectName uniqueName, SqlExpression expression) {
				TablePlan = tablePlan;
				ColumnName = columnName;
				UniqueName = uniqueName;
				Expression = expression;
			}

			public TablePlan TablePlan { get; private set; }

			public ObjectName ColumnName { get; private set; }

			public ObjectName UniqueName { get; private set; }

			public SqlExpression Expression { get; private set; }

			public void SetSource(ObjectName columnName, SqlExpression expression) {
				ColumnName = columnName;
				Expression = expression;
			}
		}

		#endregion

		#region ExpressionPlan

		abstract class ExpressionPlan : IExpressionPlan {
			protected ExpressionPlan(float optimizeFactor) {
				OptimizeFactor = optimizeFactor;
			}

			public float OptimizeFactor { get; private set; }

			public abstract void AddToPlanTree();

			public int CompareTo(IExpressionPlan other) {
				return OptimizeFactor.CompareTo(other.OptimizeFactor);
			}

			int IComparable.CompareTo(object obj) {
				var other = (ExpressionPlan) obj;
				return CompareTo(other);
			}
		}

		#endregion

		#region ConstantPlan

		class ConstantPlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly SqlExpression expression;

			public ConstantPlan(QueryTablePlanner planner, SqlExpression expression) 
				: base(0f) {
				this.planner = planner;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				foreach (var tablePlan in planner.tablePlans) {
					tablePlan.UpdatePlan(new ConstantSelectNode(tablePlan.Plan, expression));
				}
			}
		}

		#endregion

		#region SimpleSelectPlan

		class SimpleSelectPlan : ExpressionPlan {
			private readonly ObjectName columnName;
			private readonly SqlExpressionType op;
			private readonly SqlExpression expression;
			private readonly QueryTablePlanner planner;

			public SimpleSelectPlan(QueryTablePlanner planner, ObjectName columnName, SqlExpressionType op, SqlExpression expression)
				: base(0.2f){
				this.planner = planner;
				this.columnName = columnName;
				this.op = op;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				var tablePlan = planner.FindPlan(columnName);
				tablePlan.UpdatePlan(new SimpleSelectNode(tablePlan.Plan, columnName, op, expression));
			}
		}

		#endregion

		#region SimpleSinglePlan

		class SimpleSinglePlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly ObjectName columnName;
			private readonly SqlExpression expression;

			public SimpleSinglePlan(QueryTablePlanner planner, ObjectName columnName, SqlExpression expression)
				: base(0.2f){
				this.planner = planner;
				this.columnName = columnName;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				var tablePlan = planner.FindPlan(columnName);
				tablePlan.UpdatePlan(new RangeSelectNode(tablePlan.Plan, expression));
			}
		}

		#endregion

		#region ComplexSinglePlan

		class ComplexSinglePlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly ObjectName columnName;
			private readonly SqlExpression expression;

			public ComplexSinglePlan(QueryTablePlanner planner, ObjectName columnName, SqlExpression expression)
				: base(0.8f) {
				this.planner = planner;
				this.columnName = columnName;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				var tablePlan = planner.FindPlan(columnName);
				tablePlan.UpdatePlan(new ExhaustiveSelectNode(tablePlan.Plan, expression));
			}
		}

		#endregion

		#region SimplePatternPlan

		class SimplePatternPlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly ObjectName columnName;
			private readonly SqlExpression expression;

			public SimplePatternPlan(QueryTablePlanner planner, ObjectName columnName, SqlExpression expression)
				: base(0.25f) {
				this.planner = planner;
				this.columnName = columnName;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				var tablePlan = planner.FindPlan(columnName);
				tablePlan.UpdatePlan(new SimplePatternSelectNode(tablePlan.Plan, expression));
			}
		}

		#endregion

		#region ExhaustiveSelectPlan

		class ExhaustiveSelectPlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly SqlExpression expression;

			public ExhaustiveSelectPlan(QueryTablePlanner planner, SqlExpression expression)
				: base(0.82f) {
				this.planner = planner;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				var columnNames = expression.DiscoverColumnNames();
				var tablePlan = planner.JoinPlansForColumns(columnNames);
				tablePlan.UpdatePlan(new ExhaustiveSelectNode(tablePlan.Plan, expression));
			}
		}

		#endregion

		#region ExhaustiveSubQueryPlan

		class ExhaustiveSubQueryPlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly ObjectName[] columnNames;
			private readonly SqlExpression expression;

			public ExhaustiveSubQueryPlan(QueryTablePlanner planner, ObjectName[] columnNames, SqlExpression expression)
				: base(0.85f) {
				this.planner = planner;
				this.columnNames = columnNames;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				var tablePlan = planner.JoinPlansForColumns(columnNames);
				tablePlan.UpdatePlan(new ExhaustiveSelectNode(tablePlan.Plan, expression));
			}
		}

		#endregion

		#region SimpleSubQueryPlan

		class SimpleSubQueryPlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly SqlBinaryExpression expression;

			public SimpleSubQueryPlan(QueryTablePlanner planner, SqlBinaryExpression expression)
				: base(0.3f) {
				this.planner = planner;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				var op = expression.ExpressionType;
				var columnName = expression.Left.AsReferenceName();
				var queryPlan = expression.Right.AsQueryPlan();

				var tablePlan = planner.FindPlan(columnName);
				var leftPlan = tablePlan.Plan;

				tablePlan.UpdatePlan(new NonCorrelatedAnyAllNode(leftPlan, queryPlan, new []{columnName}, op));
			}
		}

		#endregion

		#region ExhaustiveJoinPlan

		class ExhaustiveJoinPlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly SqlExpression expression;

			public ExhaustiveJoinPlan(QueryTablePlanner planner, SqlExpression expression)
				: base(0.68f) {
				this.planner = planner;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				var columnNames = expression.DiscoverColumnNames();
				var tablePlan = planner.JoinPlansForColumns(columnNames);
				tablePlan.UpdatePlan(new ExhaustiveSelectNode(tablePlan.Plan, expression));
			}
		}

		#endregion

		#region StandardJoinPlan

		class StandardJoinPlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly SqlBinaryExpression expression;

			public StandardJoinPlan(QueryTablePlanner planner, SqlBinaryExpression expression, float optimizeFactor)
				: base(optimizeFactor) {
				this.planner = planner;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				var op = expression.ExpressionType;
				var lhsVar = expression.Left.AsReferenceName();
				var rhsVar = expression.Right.AsReferenceName();
				var lhsVars = expression.Left.DiscoverColumnNames();
				var rhsVars = expression.Right.DiscoverColumnNames();

				var lhsPlan = planner.JoinPlansForColumns(lhsVars);
				var rhsPlan = planner.JoinPlansForColumns(rhsVars);

				if (lhsPlan != rhsPlan) {
					// If either the LHS or the RHS is a single column then we can
					// optimize the join.

					if (lhsVar != null || rhsVar != null) {
						// If right column is a single and left column is not then we must
						// reverse the expression.
						JoinNode joinNode;
						if (lhsVar == null) {
							// Reverse the expressions and the operator
							joinNode = new JoinNode(rhsPlan.Plan, lhsPlan.Plan, rhsVar, op.Reverse(), expression.Left);
							planner.MergePlans(rhsPlan, lhsPlan, joinNode);
						} else {
							// Otherwise, use it as it is.
							joinNode = new JoinNode(lhsPlan.Plan, rhsPlan.Plan, lhsVar, op, expression.Right);
							planner.MergePlans(lhsPlan, rhsPlan, joinNode);
						}

						// Return because we are done
						return;
					}
				}

				// If we get here either both the lhs and rhs are complex expressions
				// or the lhs and rhs of the variable are not different plans, or
				// the operator is not a conditional.  Either way, we must evaluate
				// this via a natural join of the variables involved coupled with an
				// exhaustive select.  These types of queries are poor performing.

				var columnNames = expression.DiscoverColumnNames();
				var tablePlan = planner.JoinPlansForColumns(columnNames);
				tablePlan.UpdatePlan(new ExhaustiveSelectNode(tablePlan.Plan, expression));
			}
		}

		#endregion

		#region SubLogicPlan

		class SubLogicPlan : ExpressionPlan {
			private readonly QueryTablePlanner planner;
			private readonly SqlExpression expression;

			public SubLogicPlan(QueryTablePlanner planner, SqlExpression expression, float optimizeFactor)
				: base(optimizeFactor) {
				this.planner = planner;
				this.expression = expression;
			}

			public override void AddToPlanTree() {
				planner.PlanExpression(expression);
			}
		}

		#endregion
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[21,6,21,82,0],[28,4,28,30,0],[29,9,29,19,0],[30,5,30,31,0],[31,6,31,15,0],[29,28,29,31,0],[29,20,29,26,0],[34,4,34,14,0],[69,4,69,30,0],[70,5,70,26,0],[72,27,72,37,0],[72,13,72,23,0],[73,5,73,42,0],[74,6,74,20,0],[72,24,72,26,0],[77,4,77,94,0],[78,3,78,4,0],[81,4,81,31,0],[82,5,82,17,0],[84,4,84,31,0],[85,31,85,42,0],[85,13,85,27,0],[86,5,86,37,0],[87,5,87,27,0],[88,6,88,23,0],[89,12,89,34,0],[90,6,90,18,0],[85,28,85,30,0],[94,4,94,21,0],[95,3,95,4,0],[98,25,98,35,0],[98,13,98,21,0],[99,5,99,26,0],[98,22,98,24,0],[101,3,101,4,0],[105,4,105,45,0],[107,25,107,36,0],[107,13,107,21,0],[108,5,108,31,0],[110,5,110,38,0],[111,6,111,29,0],[107,22,107,24,0],[114,4,114,38,0],[128,5,128,14,0],[131,5,131,14,0],[134,5,134,14,0],[141,4,141,13,0],[151,5,151,36,0],[152,5,152,38,0],[153,5,153,22,0],[154,5,154,23,0],[156,5,156,35,0],[157,5,157,37,0],[158,5,158,22,0],[159,5,159,23,0],[164,6,165,78,0],[177,4,177,34,0],[179,5,179,70,0],[180,5,180,22,0],[181,11,181,42,0],[183,5,183,72,0],[184,5,184,22,0],[185,11,185,42,0],[187,5,187,23,0],[189,5,189,103,0],[193,4,193,42,0],[194,4,194,38,0],[195,4,195,39,0],[198,4,198,47,0],[201,4,201,18,0],[202,5,202,54,0],[205,4,205,42,0],[211,5,211,17,0],[215,5,215,24,0],[236,12,236,28,0],[239,6,239,69,0],[240,6,240,39,0],[241,6,241,49,0],[242,6,242,41,0],[243,12,243,28,0],[246,6,246,68,0],[247,6,247,39,0],[248,6,248,48,0],[249,6,249,41,0],[251,6,251,113,0],[267,4,267,31,0],[270,4,270,21,0],[273,4,273,27,0],[277,4,277,65,0],[280,33,280,37,0],[280,13,280,29,0],[281,5,282,73,0],[284,6,284,90,0],[285,6,285,13,0],[280,30,280,32,0],[290,4,290,71,0],[291,3,291,4,0],[294,4,294,39,0],[296,4,296,30,0],[297,9,297,19,0],[298,5,298,48,0],[297,28,297,31,0],[297,20,297,26,0],[302,9,302,19,0],[303,5,303,29,0],[304,5,304,34,0],[307,5,307,30,0],[308,6,308,40,0],[309,6,309,79,0],[313,5,313,31,0],[314,6,314,41,0],[315,6,315,82,0],[302,28,302,31,0],[302,20,302,26,0],[319,4,319,16,0],[335,6,335,47,0],[343,4,343,62,0],[345,4,345,62,0],[347,4,347,46,0],[349,4,349,61,0],[352,4,352,53,0],[354,4,354,52,0],[356,31,356,42,0],[356,13,356,27,0],[359,5,359,46,0],[362,6,362,74,0],[364,6,364,45,0],[367,5,367,40,0],[368,6,368,35,0],[369,12,369,34,0],[370,6,370,35,0],[371,12,371,47,0],[372,6,372,34,0],[375,6,375,59,0],[376,6,376,33,0],[378,7,378,26,0],[379,13,379,40,0],[381,7,381,27,0],[382,13,382,39,0],[385,7,385,26,0],[387,7,387,72,0],[356,28,356,30,0],[394,4,394,51,0],[398,4,398,48,0],[403,4,403,47,0],[408,4,408,56,0],[412,4,412,59,0],[416,4,416,48,0],[420,4,420,57,0],[422,4,422,25,0],[425,36,425,49,0],[425,13,425,32,0],[426,5,426,26,0],[425,33,425,35,0],[428,3,428,4,0],[431,31,431,35,0],[431,13,431,27,0],[432,5,432,61,0],[444,5,444,29,0],[446,28,446,35,0],[446,14,446,24,0],[447,6,447,56,0],[449,6,449,29,0],[452,6,452,21,0],[454,7,454,37,0],[455,7,455,33,0],[456,7,456,22,0],[458,8,458,28,0],[459,14,459,33,0],[460,8,460,20,0],[461,14,461,31,0],[464,8,464,28,0],[467,7,467,24,0],[468,8,468,61,0],[471,8,471,25,0],[475,6,475,21,0],[478,7,478,60,0],[446,25,446,27,0],[431,28,431,30,0],[482,3,482,4,0],[491,31,491,35,0],[491,13,491,27,0],[493,5,493,52,0],[494,5,494,53,0],[504,5,504,42,0],[506,6,506,58,0],[507,12,507,49,0],[510,6,510,63,0],[513,6,513,62,0],[491,28,491,30,0],[516,3,516,4,0],[519,31,519,35,0],[519,13,519,27,0],[522,5,522,40,0],[523,5,523,25,0],[525,6,525,24,0],[528,6,528,57,0],[529,6,529,29,0],[530,7,530,25,0],[533,7,533,65,0],[534,7,534,29,0],[535,8,535,26,0],[538,8,538,54,0],[539,8,539,35,0],[544,5,544,20,0],[547,6,547,66,0],[550,6,550,20,0],[551,6,551,72,0],[552,6,552,35,0],[556,6,556,40,0],[557,7,557,53,0],[559,7,559,55,0],[559,62,559,65,0],[564,7,564,86,0],[567,6,567,58,0],[519,28,519,30,0],[570,3,570,4,0],[573,31,573,35,0],[573,13,573,27,0],[576,5,576,60,0],[578,5,578,33,0],[579,6,579,52,0],[580,12,581,46,0],[582,6,582,73,0],[589,6,589,60,0],[573,28,573,30,0],[592,3,592,4,0],[596,4,596,54,0],[598,4,598,55,0],[600,31,600,35,0],[600,13,600,27,0],[603,5,603,54,0],[604,5,604,42,0],[604,43,604,68,0],[606,5,606,25,0],[607,6,607,52,0],[609,6,609,28,0],[610,7,610,78,0],[612,7,612,65,0],[613,7,613,69,0],[616,6,616,73,0],[617,6,617,28,0],[619,7,619,26,0],[620,7,620,20,0],[621,7,621,23,0],[622,7,622,25,0],[623,7,623,54,0],[626,6,626,44,0],[629,6,629,37,0],[630,6,630,20,0],[631,7,631,95,0],[634,7,634,99,0],[600,28,600,30,0],[639,4,639,49,0],[639,109,639,135,0],[640,4,640,50,0],[640,111,640,137,0],[641,3,641,4,0],[645,4,645,39,0],[645,67,645,93,0],[646,3,646,4,0],[649,4,650,43,0],[651,5,651,51,0],[653,5,653,59,0],[656,6,656,50,0],[662,6,662,23,0],[665,6,665,32,0],[666,6,666,33,0],[669,6,669,42,0],[670,6,670,43,0],[676,6,676,48,0],[677,6,677,50,0],[678,6,678,75,0],[680,7,680,36,0],[681,7,681,37,0],[685,6,685,49,0],[686,6,686,51,0],[687,6,687,35,0],[691,6,691,47,0],[692,6,692,48,0],[693,11,693,21,0],[694,7,694,39,0],[695,7,695,41,0],[696,7,696,53,0],[697,8,697,35,0],[698,8,698,37,0],[693,30,693,33,0],[693,22,693,28,0],[703,6,703,45,0],[704,6,704,47,0],[707,6,707,45,0],[708,6,708,47,0],[709,6,709,31,0],[711,6,711,49,0],[713,11,713,21,0],[714,7,714,39,0],[715,7,715,41,0],[720,7,720,53,0],[726,8,726,71,0],[729,8,729,34,0],[731,8,731,27,0],[736,8,736,27,0],[740,7,740,33,0],[713,30,713,33,0],[713,22,713,28,0],[745,6,745,32,0],[746,12,746,67,0],[747,6,747,59,0],[749,6,749,44,0],[752,5,752,44,0],[754,3,754,4,0],[768,4,768,44,0],[769,4,769,49,0],[770,4,770,58,0],[771,4,771,57,0],[772,3,772,4,0],[559,55,559,62,0],[639,49,639,109,0],[640,50,640,111,0],[645,39,645,67,0],[784,4,784,120,0],[785,5,785,27,0],[786,5,786,29,0],[787,5,787,29,0],[788,5,788,29,0],[789,4,789,5,0],[800,5,800,29,0],[801,5,801,29,0],[802,4,802,5,0],[810,4,810,50,0],[811,5,811,37,0],[812,4,812,5,0],[819,5,819,59,0],[823,5,823,38,0],[824,5,824,29,0],[836,4,837,15,0],[838,5,838,28,0],[839,5,839,34,0],[840,4,840,5,0],[843,31,843,49,0],[843,14,843,27,0],[844,6,844,79,0],[843,28,843,30,0],[846,4,846,5,0],[859,4,860,17,0],[861,5,861,28,0],[862,5,862,34,0],[863,5,863,18,0],[864,5,864,34,0],[865,4,865,5,0],[868,5,868,50,0],[869,5,869,92,0],[870,4,870,5,0],[882,4,883,17,0],[884,5,884,28,0],[885,5,885,34,0],[886,5,886,34,0],[887,4,887,5,0],[890,5,890,50,0],[891,5,891,75,0],[892,4,892,5,0],[904,4,905,17,0],[906,5,906,28,0],[907,5,907,34,0],[908,5,908,34,0],[909,4,909,5,0],[912,5,912,50,0],[913,5,913,80,0],[914,4,914,5,0],[926,4,927,18,0],[928,5,928,28,0],[929,5,929,34,0],[930,5,930,34,0],[931,4,931,5,0],[934,5,934,50,0],[935,5,935,83,0],[936,4,936,5,0],[947,4,948,18,0],[949,5,949,28,0],[950,5,950,34,0],[951,4,951,5,0],[954,5,954,56,0],[955,5,955,62,0],[956,5,956,80,0],[957,4,957,5,0],[969,4,970,18,0],[971,5,971,28,0],[972,5,972,36,0],[973,5,973,34,0],[974,4,974,5,0],[977,5,977,62,0],[978,5,978,80,0],[979,4,979,5,0],[990,4,991,17,0],[992,5,992,28,0],[993,5,993,34,0],[994,4,994,5,0],[997,5,997,40,0],[998,5,998,56,0],[999,5,999,52,0],[1001,5,1001,50,0],[1002,5,1002,35,0],[1004,5,1004,100,0],[1005,4,1005,5,0],[1016,4,1017,18,0],[1018,5,1018,28,0],[1019,5,1019,34,0],[1020,4,1020,5,0],[1023,5,1023,56,0],[1024,5,1024,62,0],[1025,5,1025,80,0],[1026,4,1026,5,0],[1037,4,1038,27,0],[1039,5,1039,28,0],[1040,5,1040,34,0],[1041,4,1041,5,0],[1044,5,1044,40,0],[1045,5,1045,52,0],[1046,5,1046,53,0],[1047,5,1047,57,0],[1048,5,1048,58,0],[1050,5,1050,56,0],[1051,5,1051,56,0],[1053,5,1053,28,0],[1057,6,1057,43,0],[1061,7,1061,26,0],[1063,8,1063,99,0],[1064,8,1064,55,0],[1067,8,1067,90,0],[1068,8,1068,55,0],[1072,7,1072,14,0],[1082,5,1082,56,0],[1083,5,1083,62,0],[1084,5,1084,80,0],[1085,4,1085,5,0],[1096,4,1097,27,0],[1098,5,1098,28,0],[1099,5,1099,34,0],[1100,4,1100,5,0],[1103,5,1103,40,0],[1104,4,1104,5,0],[11,3,11,29,1],[12,4,12,39,1],[13,4,13,20,1],[14,3,14,4,1],[20,5,20,31,1],[23,5,23,26,1],[39,4,39,88,1],[40,4,40,76,1],[41,4,41,104,1],[44,4,44,87,1],[45,4,45,79,1],[46,4,46,107,1],[49,4,49,58,1],[54,4,54,28,1],[55,4,55,29,1],[58,4,58,54,1],[59,4,59,35,1],[60,4,60,25,1],[62,4,62,21,1],[64,4,64,19,1],[118,4,118,30,1],[119,4,119,16,1],[120,5,120,26,1],[123,4,123,36,1],[127,4,127,60,1],[129,4,129,57,1],[132,4,132,59,1],[135,4,136,57,1],[138,5,138,14,1],[150,4,150,33,1],[155,11,155,39,1],[162,5,163,59,1],[170,5,170,72,1],[171,5,171,44,1],[210,4,210,28,1],[213,4,213,28,1],[218,4,218,56,1],[222,5,222,39,1],[223,5,223,40,1],[227,5,227,59,1],[228,5,228,21,1],[230,6,230,60,1],[233,6,233,39,1],[234,6,234,40,1],[235,6,235,41,1],[221,4,221,37,1],[256,4,256,30,1],[260,4,260,27,1],[262,5,262,22,1],[263,5,263,28,1],[323,4,323,30,1],[324,4,324,16,1],[325,5,325,12,1],[328,4,328,58,1],[330,4,330,35,1],[331,9,331,19,1],[332,5,332,36,1],[334,5,334,34,1],[337,6,337,20,1],[331,28,331,31,1],[331,20,331,26,1],[340,3,340,4,1],[757,4,757,30,1],[758,4,758,19,1],[759,3,759,4,1],[762,4,762,42,1],[763,4,763,53,1],[764,4,764,55,1],[765,3,765,4,1],[776,4,776,24,1],[778,4,778,45,1]]);
    </script>
  </body>
</html>