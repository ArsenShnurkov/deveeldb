<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.spatial\wktwriter.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Globalization;
using System.IO;
using System.Text;

namespace Deveel.Data.Spatial {
	public sealed class WktWriter : IGeometryWriter {
		private readonly int dimensions;

		private const string MaxPrecisionFormat = &quot;{0:R}&quot;;
		private NumberFormatInfo formatter;
		private string format;
		private string indentTabStr = &quot;  &quot;;

		public WktWriter() 
			: this(2) {
		}

		public WktWriter(int dimensions) {
			if (dimensions &lt; 2 || dimensions &gt; 3)
				throw new ArgumentException();

			this.dimensions = dimensions;
		}

		GeometryFormat IGeometryWriter.Format {
			get { return GeometryFormat.WellKnownText; }
		}

		object IGeometryWriter.Write(IGeometry geometry) {
			return Write(geometry);
		}

		public bool UseFormatting { get; set; }

		public bool UseMaxPrecision { get; set; }

		public int MaxCoordinatesPerLine { get; set; }

		private static NumberFormatInfo CreateFormatter(IPrecisionModel precisionModel) {
			var digits = precisionModel.MaximumSignificantDigits;
			var decimalPlaces = System.Math.Max(0, digits); // negative values not allowed

			// specify decimal separator explicitly to avoid problems in other locales
			var nfi = new NumberFormatInfo {
				NumberDecimalSeparator = &quot;.&quot;,
				NumberDecimalDigits = decimalPlaces,
				NumberGroupSeparator = String.Empty,
				NumberGroupSizes = new int[] { }
			};
			return nfi;
		}

		public static string StringOfChar(char ch, int count) {
			var buf = new StringBuilder();
			for (var i = 0; i &lt; count; i++)
				buf.Append(ch);

			return buf.ToString();
		}

		public string Write(IGeometry geometry) {
			var sb = new StringBuilder();

			using (var writer = new StringWriter(sb)) {
				WriteFormatted(geometry, writer);
			}

			return sb.ToString();
		}

		private void WriteFormatted(IGeometry geometry, TextWriter writer) {
			var precisionModel = geometry.Factory.PrecisionModel;
			UseMaxPrecision = precisionModel.PrecisionModelType == PrecisionModelType.Floating;

			formatter = CreateFormatter(geometry.PrecisionModel);
			format = &quot;0.&quot; + StringOfChar(&#39;#&#39;, formatter.NumberDecimalDigits);
			WriteGeometry(geometry, 0, writer);

			UseMaxPrecision = false;
		}

		private void WriteGeometry(IGeometry geometry, int level, TextWriter writer) {
			Indent(level, writer);

			if (geometry is IPoint) {
				var point = (IPoint)geometry;
				WritePoint(point.Coordinate, level, writer);
			} else if (geometry is ILinearRing)
				WriteLinearRing((ILinearRing)geometry, level, writer);
			else if (geometry is ILineString)
				WriteLineString((ILineString)geometry, level, writer);
			else if (geometry is IPolygon)
				WritePolygon((IPolygon)geometry, level, writer);
			else if (geometry is IMultiPoint)
				WriteMultiPoint((IMultiPoint)geometry, level, writer);
			else if (geometry is IMultiLineString)
				WriteMultiLineString((IMultiLineString)geometry, level, writer);
			else if (geometry is IMultiPolygon)
				WriteMultiPolygon((IMultiPolygon)geometry, level, writer);
			else if (geometry is IGeometryCollection)
				WriteGeometryCollection((IGeometryCollection)geometry, level, writer);
			else
				throw new ArgumentException(String.Format(&quot;The geometry type {0} is not supported.&quot;, geometry.GetType()));
		}

		private void WritePoint(ICoordinate coordinate, int level, TextWriter writer) {
			writer.Write(&quot;POINT &quot;);
			WritePointText(coordinate, level, writer);
		}

		private void WriteLineString(ILineString lineString, int level, TextWriter writer) {
			writer.Write(&quot;LINESTRING &quot;);
			WriteLineStringText(lineString, level, false, writer);
		}

		private void WriteLinearRing(ILinearRing linearRing, int level, TextWriter writer) {
			writer.Write(&quot;LINEARRING &quot;);
			WriteLineStringText(linearRing, level, false, writer);
		}

		private void WritePolygon(IPolygon polygon, int level, TextWriter writer) {
			writer.Write(&quot;POLYGON &quot;);
			WritePolygonText(polygon, level, false, writer);
		}

		private void WriteMultiPoint(IMultiPoint multipoint, int level, TextWriter writer) {
			writer.Write(&quot;MULTIPOINT &quot;);
			WriteMultiPointText(multipoint, level, writer);
		}

		private void WriteMultiLineString(IMultiLineString multiLineString, int level, TextWriter writer) {
			writer.Write(&quot;MULTILINESTRING &quot;);
			WriteMultiLineStringText(multiLineString, level, false, writer);
		}

		private void WriteMultiPolygon(IMultiPolygon multiPolygon, int level, TextWriter writer) {
			writer.Write(&quot;MULTIPOLYGON &quot;);
			WriteMultiPolygonText(multiPolygon, level, writer);
		}

		private void WriteGeometryCollection(IGeometryCollection geometryCollection, int level, TextWriter writer) {
			writer.Write(&quot;GEOMETRYCOLLECTION &quot;);
			WriteGeometryCollectionText(geometryCollection, level, writer);
		}

		private void WritePointText(ICoordinate coordinate, int level, TextWriter writer) {
			if (coordinate == null) {
				writer.Write(&quot;EMPTY&quot;);
			} else {
				writer.Write(&quot;(&quot;);
				WriteCoordinate(coordinate, writer);
				writer.Write(&quot;)&quot;);
			}
		}

		private void WriteCoordinate(ICoordinate coordinate, TextWriter writer) {
			writer.Write(ToString(coordinate.X) + &quot; &quot; + ToString(coordinate.Y));

			if (dimensions &gt;= 3 &amp;&amp; !double.IsNaN(coordinate.Z)) {
				writer.Write(&quot; &quot; + ToString(coordinate.Z));
			}
		}

		private string ToString(double d) {
			var standard = d.ToString(format, formatter);
			if (!UseMaxPrecision) {
				return standard;
			}
			try {
				var converted = Convert.ToDouble(standard, formatter);
				// check if some precision is lost during text conversion: if so, use {0:R} formatter
				if (converted == d)
					return standard;
				return String.Format(formatter, MaxPrecisionFormat, d);
			} catch (OverflowException) {
				// Use MaxPrecisionFormat anyway
				return String.Format(formatter, MaxPrecisionFormat, d);
			}
		}

		private void WriteLineStringText(ILineString lineString, int level, bool doIndent, TextWriter writer) {
			if (lineString.IsEmpty)
				writer.Write(&quot;EMPTY&quot;);
			else {
				if (doIndent) Indent(level, writer);
				writer.Write(&quot;(&quot;);

				for (var i = 0; i &lt; lineString.NumPoints; i++) {
					WriteCoordinate(lineString.GetCoordinate(i), writer);

					if (i &lt; lineString.NumPoints - 1) {
						writer.Write(&quot;, &quot;);
						if (MaxCoordinatesPerLine &gt; 0 &amp;&amp;
							i % MaxCoordinatesPerLine == 0) {
							Indent(level + 1, writer);
						}						
					}
				}

				writer.Write(&quot;)&quot;);
			}
		}

		private void WritePolygonText(IPolygon polygon, int level, bool indentFirst, TextWriter writer) {
			if (polygon.IsEmpty)
				writer.Write(&quot;EMPTY&quot;);
			else {
				if (indentFirst) Indent(level, writer);
				writer.Write(&quot;(&quot;);
				WriteLineStringText(polygon.ExteriorRing, level, false, writer);

				for (var i = 0; i &lt; polygon.NumInteriorRings; i++) {
					writer.Write(&quot;, &quot;);

					WriteLineStringText(polygon.GetInteriorRing(i), level + 1, true, writer);
				}

				writer.Write(&quot;)&quot;);
			}
		}

		private void WriteMultiPointText(IMultiPoint multiPoint, int level, TextWriter writer) {
			if (multiPoint.IsEmpty)
				writer.Write(&quot;EMPTY&quot;);
			else {
				writer.Write(&quot;(&quot;);
				for (var i = 0; i &lt; multiPoint.NumGeometries; i++) {
					writer.Write(&quot;(&quot;);
					WriteCoordinate((multiPoint.GetGeometry(i)).Coordinate, writer);
					writer.Write(&quot;)&quot;);

					if (i &lt; multiPoint.NumGeometries - 1) {
						writer.Write(&quot;, &quot;);
						IndentCoords(i, level + 1, writer);
					}
				}
				writer.Write(&quot;)&quot;);
			}
		}

		private void WriteMultiLineStringText(IMultiLineString multiLineString, int level, bool indentFirst, TextWriter writer) {
			if (multiLineString.IsEmpty)
				writer.Write(&quot;EMPTY&quot;);
			else {
				var level2 = level;
				var doIndent = indentFirst;
				writer.Write(&quot;(&quot;);
				for (var i = 0; i &lt; multiLineString.NumGeometries; i++) {
					if (i &gt; 0) {
						writer.Write(&quot;, &quot;);
						level2 = level + 1;
						doIndent = true;
					}

					WriteLineStringText((ILineString)multiLineString.GetGeometry(i), level2, doIndent, writer);
				}
				writer.Write(&quot;)&quot;);
			}
		}

		private void WriteMultiPolygonText(IMultiPolygon multiPolygon, int level, TextWriter writer) {
			if (multiPolygon.IsEmpty)
				writer.Write(&quot;EMPTY&quot;);
			else {
				var level2 = level;
				var doIndent = false;
				writer.Write(&quot;(&quot;);
				for (var i = 0; i &lt; multiPolygon.NumGeometries; i++) {
					if (i &gt; 0) {
						writer.Write(&quot;, &quot;);
						level2 = level + 1;
						doIndent = true;
					}
					WritePolygonText((IPolygon)multiPolygon.GetGeometry(i), level2, doIndent, writer);
				}
				writer.Write(&quot;)&quot;);
			}
		}

		private void WriteGeometryCollectionText(IGeometryCollection geometryCollection, int level, TextWriter writer) {
			if (geometryCollection.IsEmpty)
				writer.Write(&quot;EMPTY&quot;);
			else {
				var level2 = level;
				writer.Write(&quot;(&quot;);
				for (var i = 0; i &lt; geometryCollection.NumGeometries; i++) {
					if (i &gt; 0) {
						writer.Write(&quot;, &quot;);
						level2 = level + 1;
					}
					WriteGeometry(geometryCollection.GetGeometry(i), level2, writer);
				}
				writer.Write(&quot;)&quot;);
			}
		}

		private void IndentCoords(int coordIndex, int level, TextWriter writer) {
			if (MaxCoordinatesPerLine &lt;= 0 || coordIndex % MaxCoordinatesPerLine != 0)
				return;

			Indent(level, writer);
		}

		private void Indent(int level, TextWriter writer) {
			if (!UseFormatting || level &lt;= 0) return;
			writer.Write(&quot;\n&quot;);
			for (int i = 0; i &lt; level; i++)
				writer.Write(indentTabStr);
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[31,3,32,13,0],[33,3,33,4,0],[29,3,29,38,0],[35,3,35,35,0],[36,4,36,41,0],[37,5,37,35,0],[39,4,39,33,0],[40,3,40,4,0],[43,10,43,46,0],[47,4,47,27,0],[57,4,57,57,0],[58,4,58,51,0],[61,4,66,6,0],[67,4,67,15,0],[71,4,71,34,0],[72,9,72,19,0],[73,5,73,20,0],[72,31,72,34,0],[72,20,72,29,0],[75,4,75,26,0],[79,4,79,33,0],[81,11,81,44,0],[82,5,82,38,0],[85,4,85,25,0],[89,4,89,57,0],[90,4,90,87,0],[92,4,92,57,0],[93,4,93,69,0],[94,4,94,39,0],[96,4,96,28,0],[97,3,97,4,0],[100,4,100,26,0],[102,4,102,27,0],[103,5,103,34,0],[104,5,104,49,0],[105,11,105,39,0],[106,5,106,59,0],[107,9,107,37,0],[108,5,108,59,0],[109,9,109,34,0],[110,5,110,53,0],[111,9,111,37,0],[112,5,112,59,0],[113,9,113,42,0],[114,5,114,69,0],[115,9,115,39,0],[116,5,116,63,0],[117,9,117,45,0],[118,5,118,75,0],[120,5,120,111,0],[124,4,124,27,0],[125,4,125,46,0],[126,3,126,4,0],[129,4,129,32,0],[130,4,130,58,0],[131,3,131,4,0],[134,4,134,32,0],[135,4,135,58,0],[136,3,136,4,0],[139,4,139,29,0],[140,4,140,52,0],[141,3,141,4,0],[144,4,144,32,0],[145,4,145,51,0],[146,3,146,4,0],[149,4,149,37,0],[150,4,150,68,0],[151,3,151,4,0],[154,4,154,34,0],[155,4,155,55,0],[156,3,156,4,0],[159,4,159,40,0],[160,4,160,67,0],[161,3,161,4,0],[164,4,164,27,0],[165,5,165,27,0],[167,5,167,23,0],[168,5,168,41,0],[169,5,169,23,0],[171,3,171,4,0],[174,4,174,72,0],[176,4,176,55,0],[177,5,177,48,0],[179,3,179,4,0],[182,4,182,49,0],[183,4,183,25,0],[184,5,184,21,0],[187,5,187,59,0],[189,5,189,24,0],[190,6,190,22,0],[191,5,191,60,0],[192,6,192,31,0],[194,5,194,60,0],[196,3,196,4,0],[199,4,199,27,0],[200,5,200,27,0],[202,5,202,18,0],[202,19,202,41,0],[203,5,203,23,0],[205,10,205,20,0],[206,6,206,59,0],[208,6,208,39,0],[209,7,209,26,0],[210,7,211,39,0],[212,8,212,34,0],[205,47,205,50,0],[205,21,205,45,0],[217,5,217,23,0],[219,3,219,4,0],[222,4,222,24,0],[223,5,223,27,0],[225,5,225,21,0],[225,22,225,44,0],[226,5,226,23,0],[227,5,227,69,0],[229,10,229,20,0],[230,6,230,25,0],[232,6,232,79,0],[229,51,229,54,0],[229,21,229,49,0],[235,5,235,23,0],[237,3,237,4,0],[240,4,240,27,0],[241,5,241,27,0],[243,5,243,23,0],[244,10,244,20,0],[245,6,245,24,0],[246,6,246,70,0],[247,6,247,24,0],[249,6,249,43,0],[250,7,250,26,0],[251,7,251,42,0],[244,51,244,54,0],[244,21,244,49,0],[254,5,254,23,0],[256,3,256,4,0],[259,4,259,32,0],[260,5,260,27,0],[262,5,262,24,0],[263,5,263,32,0],[264,5,264,23,0],[265,10,265,20,0],[266,6,266,16,0],[267,7,267,26,0],[268,7,268,26,0],[269,7,269,23,0],[272,6,272,97,0],[265,56,265,59,0],[265,21,265,54,0],[274,5,274,23,0],[276,3,276,4,0],[279,4,279,29,0],[280,5,280,27,0],[282,5,282,24,0],[283,5,283,26,0],[284,5,284,23,0],[285,10,285,20,0],[286,6,286,16,0],[287,7,287,26,0],[288,7,288,26,0],[289,7,289,23,0],[291,6,291,88,0],[285,53,285,56,0],[285,21,285,51,0],[293,5,293,23,0],[295,3,295,4,0],[298,4,298,35,0],[299,5,299,27,0],[301,5,301,24,0],[302,5,302,23,0],[303,10,303,20,0],[304,6,304,16,0],[305,7,305,26,0],[306,7,306,26,0],[308,6,308,71,0],[303,59,303,62,0],[303,21,303,57,0],[310,5,310,23,0],[312,3,312,4,0],[315,4,315,78,0],[316,5,316,12,0],[318,4,318,26,0],[319,3,319,4,0],[322,4,322,37,0],[322,38,322,45,0],[323,4,323,23,0],[324,9,324,19,0],[325,5,325,32,0],[324,31,324,34,0],[324,20,324,29,0],[326,3,326,4,0]]);
    </script>
  </body>
</html>