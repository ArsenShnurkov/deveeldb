<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.index\blockindexbase_t.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections;
using System.Collections.Generic;

namespace Deveel.Data.Index {
	/// &lt;summary&gt;
	/// An implementation of an index of values that are stored across an array of blocks.
	/// &lt;/summary&gt;
	/// &lt;remarks&gt;
	/// This allows for quicker insertion and deletion of values, including 
	/// other memory saving benefits.
	/// &lt;para&gt;
	/// The class works as follows:
	/// &lt;list type=&quot;bullet&quot;&gt;
	/// &lt;item&gt;The index can contain any number of &lt;see cref=&quot;int&quot;&gt;integer&lt;/see&gt;
	/// values.&lt;/item&gt;
	/// &lt;item&gt;Each value is stored within a block of integers A block is 
	/// of finite size.&lt;/item&gt;
	/// &lt;item&gt;When a block becomes full, values are moved around until 
	/// enough space is free. This may be by inserting a new block or by shifting
	/// informations from one block to another.&lt;/item&gt;
	/// &lt;item&gt;When a block becomes empty, it is removed.&lt;/item&gt;
	/// &lt;/list&gt;
	/// &lt;/para&gt;
	/// &lt;para&gt;
	/// The benefits of this system are that inserts and deletes are fast even
	/// for very large lists. There are no megabyte sized arraycopies. Also,
	/// the object could be extended to a version that pages un-used blocks to disk
	/// thus saving precious system memory.
	/// &lt;/para&gt;
	/// &lt;para&gt;
	/// &lt;b&gt;Note:&lt;/b&gt; The following methods are &lt;b&gt;not&lt;/b&gt; optimal:
	/// &lt;see cref=&quot;Item(int)&quot;/&gt;, &lt;see cref=&quot;Insert(int, T)&quot;/&gt;, 
	/// &lt;see cref=&quot;RemoveAt(int)&quot;/&gt;.&lt;br/&gt;
	/// Specifically, they slow as the specified &lt;i&gt;index&lt;/i&gt; nears the end of large lists.
	/// &lt;/para&gt;
	/// &lt;para&gt;
	/// This type of structure is very fast for large sorted lists where values can
	/// be inserted at any position within the list. Care needs to be taken for
	/// lists where values are inserted and removed constantly, because
	/// fragmentation of the list blocks can occur. 
	/// For example, adding 60,000 random entries followed by removing 50,000 random 
	/// entries will result in many only partially filled blocks. Since each block 
	/// takes a constant amount of memory, this may not be acceptable.
	/// &lt;/para&gt;
	/// &lt;/remarks&gt;
	public abstract class BlockIndexBase&lt;T&gt; : IIndex&lt;T&gt; where T : IComparable&lt;T&gt;, IEquatable&lt;T&gt; {
		protected BlockIndexBase() {
			Count = 0;
			IsReadOnly = false;
			Blocks = new List&lt;IIndexBlock&lt;T&gt;&gt;(10);
		}

		protected BlockIndexBase(IEnumerable&lt;IIndexBlock&lt;T&gt;&gt; blocks)
			: this() {
			foreach (var block in blocks) {
				Blocks.Add(block);
				Count += block.Count;
			}
		}

		protected BlockIndexBase(IEnumerable&lt;T&gt; values)
			: this() {
			foreach (var value in values) {
				Add(value);
			}
		}

		protected BlockIndexBase(IIndex&lt;T&gt; index)
			: this() {
			if (index is BlockIndexBase&lt;T&gt;) {
				// Optimization for when the input list is a BlockIntegerList
				var blockIndex = (BlockIndexBase&lt;T&gt;) index;

				var inBlocks = blockIndex.Blocks;
				int inBlocksCount = inBlocks.Count;
				// For each block in &#39;blockIndex&#39;
				for (int i = 0; i &lt; inBlocksCount; ++i) {
					// get the block.
					var block = inBlocks[i];
					// Insert a new block in this object.
					var destBlock = InsertBlock(i, NewBlock());
					// Copy the contents of the source block to the new destination block.
					block.CopyTo(destBlock);
				}

				// Set the size of the list
				Count = blockIndex.Count; //count;
			} else {
				// The case when IIntegerList type is not known
				var i = index.GetEnumerator();
				while (i.MoveNext()) {
					Add(i.Current);
				}
			}

			// If the given list is immutable then set this list to immutable
			if (index.IsReadOnly)
				IsReadOnly = true;
		}

		protected List&lt;IIndexBlock&lt;T&gt;&gt; Blocks { get; private set; }

		public bool IsReadOnly { get; set; }

		public int Count { get; private set; }

		public T this[int index] {
			get {
				int size = Blocks.Count;
				int start = 0;
				for (int i = 0; i &lt; size; ++i) {
					var block = Blocks[i];
					int bsize = block.Count;
					if (index &gt;= start &amp;&amp; index &lt; start + bsize)
						return block[index - start];

					start += bsize;
				}

				throw new ArgumentOutOfRangeException(&quot;index&quot;);
			}
		}

		/// &lt;summary&gt;
		/// Creates a new &lt;see cref=&quot;IIndexBlock{T}&quot;/&gt; for the given implementation.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		protected abstract IIndexBlock&lt;T&gt; NewBlock();

		/// &lt;summary&gt;
		/// Called when the class decides the given &lt;see cref=&quot;IIndexBlock{T}&quot;/&gt; 
		/// is no longer needed.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;block&quot;&gt;&lt;/param&gt;
		/// &lt;remarks&gt;
		/// Provided as an event for derived classes to intercept.
		/// &lt;/remarks&gt;
		protected virtual void OnDeleteBlock(IIndexBlock&lt;T&gt; block) {
		}


		/// &lt;summary&gt;
		/// Inserts a block at the given position in the index.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;block&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		private IIndexBlock&lt;T&gt; InsertBlock(int index, IIndexBlock&lt;T&gt; block) {
			Blocks.Insert(index, block);

			// Point to next in the list.
			if (index + 1 &lt; Blocks.Count) {
				var nextBlock = Blocks[index + 1];
				block.Next = nextBlock;
				nextBlock.Previous = block;
			} else {
				block.Next = null;
			}

			// Point to previous in the list.
			if (index &gt; 0) {
				var prevBlock = Blocks[index - 1];
				block.Previous = prevBlock;
				prevBlock.Next = block;
			} else {
				block.Previous = null;
			}

			return block;
		}

		/// &lt;summary&gt;
		/// Removes a block from the given position in the index.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;
		private void RemoveBlock(int index) {
			// Alter linked list pointers.
			IIndexBlock&lt;T&gt; newPrev = null;
			IIndexBlock&lt;T&gt; newNext = null;
			if (index + 1 &lt; Blocks.Count) {
				newNext = Blocks[index + 1];
			}
			if (index &gt; 0) {
				newPrev = Blocks[index - 1];
			}

			if (newPrev != null) {
				newPrev.Next = newNext;
			}
			if (newNext != null) {
				newNext.Previous = newPrev;
			}

			var beenRemoved = Blocks[index];
			Blocks.RemoveAt(index);
			OnDeleteBlock(beenRemoved);
		}

		/// &lt;summary&gt;
		/// Inserts a value in the given block position in the list.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;blockIndex&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;block&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
		private void InsertIntoBlock(T value, int blockIndex, IIndexBlock&lt;T&gt; block, int position) {
			block.Insert(value, position);

			++Count;
			// Is the block full?
			if (block.IsFull) {
				// We need to move half of the data out of this block into either the
				// next block or create a new block to store it.

				// The size that we going to zap out of this block.
				int moveSize = (block.Count/7) - 1;

				// The block to move half the data from this block.
				IIndexBlock&lt;T&gt; moveTo;

				// Is there a next block?
				if (blockIndex &lt; Blocks.Count - 1) {
					var nextBlock = Blocks[blockIndex + 1];
					// Yes, can this block contain half the values from this block?
					if (nextBlock.CanContain(moveSize)) {
						moveTo = nextBlock;
					} else {
						// Can&#39;t contain so insert a new block.
						moveTo = InsertBlock(blockIndex + 1, NewBlock());
					}

				} else {
					// No next block so create a new block
					moveTo = InsertBlock(blockIndex + 1, NewBlock());
				}

				// &#39;moveTo&#39; should be set to the block we are to use to move half the
				// data from this block.
				block.MoveTo(moveTo, 0, moveSize);
			}
		}

		/// &lt;summary&gt;
		/// Removes the value from the given position in the specified block.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;blockIndex&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;block&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
		/// &lt;remarks&gt;
		/// It returns the value that used to be at that position.
		/// &lt;/remarks&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		private T RemoveFromBlock(int blockIndex, IIndexBlock&lt;T&gt; block, int position) {
			var oldValue = block.RemoveAt(position);
			--Count;
			// If we have emptied out this block, then we should remove it from the
			// list.
			if (block.IsEmpty &amp;&amp; Blocks.Count &gt; 1)
				RemoveBlock(blockIndex);

			return oldValue;
		}

		/// &lt;summary&gt;
		/// Uses a binary search algorithm to quickly determine the index of the 
		/// &lt;see cref=&quot;IIndexBlock{T}&quot;/&gt; within &#39;blocks&#39; of the block 
		/// that contains the given key value using the &lt;see cref=&quot;IIndexComparer{T}&quot;/&gt; 
		/// as a lookup comparator.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;comparer&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		private int FindBlockContaining(object key, IIndexComparer&lt;T&gt; comparer) {
			if (Count == 0)
				return -1;

			int low = 0;
			int high = Blocks.Count - 1;

			while (low &lt;= high) {
				int mid = (low + high)/2;
				var block = Blocks[mid];

				// Is what we are searching for lower than the bottom value?
				if (comparer.CompareValue(block.Bottom, (DataObject) key) &gt; 0) {
					high = mid - 1;
				}
					// No, then is it greater than the highest value?
				else if (comparer.CompareValue(block.Top, (DataObject) key) &lt; 0) {
					low = mid + 1;
				}
					// Must be inside this block then!
				else {
					return mid;
				}
			}

			return -(low + 1); // key not found.
		}

		/// &lt;summary&gt;
		/// Uses a binary search algorithm to quickly determine the index of 
		/// the &lt;see cref=&quot;IIndexBlock{T}&quot;/&gt; within &#39;blocks&#39; of the block 
		/// that contains the given key value using the &lt;see cref=&quot;IIndexComparer{T}&quot;/&gt; 
		/// as a lookup comparator.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;comparer&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		private int FindLastBlock(object key, IIndexComparer&lt;T&gt; comparer) {
			if (Count == 0)
				return -1;

			int low = 0;
			int high = Blocks.Count - 1;

			while (low &lt;= high) {
				if (high - low &lt;= 2) {
					for (int i = high; i &gt;= low; --i) {
						var block1 = Blocks[i];
						if (comparer.CompareValue(block1.Bottom, (DataObject) key) &lt;= 0) {
							if (comparer.CompareValue(block1.Top, (DataObject) key) &gt;= 0)
								return i;
							return -(i + 1) - 1;
						}
					}
					return -(low + 1);
				}

				int mid = (low + high)/2;
				var block = Blocks[mid];

				// Is what we are searching for lower than the bottom value?
				if (comparer.CompareValue(block.Bottom, (DataObject) key) &gt; 0) {
					high = mid - 1;
				}
					// No, then is it greater than the highest value?
				else if (comparer.CompareValue(block.Top, (DataObject) key) &lt; 0) {
					low = mid + 1;
				}
					// Equal, so highest must be someplace between mid and high.
				else {
					low = mid;
					if (low == high) {
						return low;
					}
				}
			}

			return -(low + 1); // key not found.
		}

		/// &lt;summary&gt;
		/// Uses a binary search algorithm to quickly determine the index of the 
		/// &lt;see cref=&quot;IIndexBlock{T}&quot;/&gt; within &#39;blocks&#39; of the block 
		/// that contains the given key value using the &lt;see cref=&quot;IIndexComparer{T}&quot;/&gt; 
		/// as a lookup comparator.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;key&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;c&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		private int FindFirstBlock(object key, IIndexComparer&lt;T&gt; c) {
			if (Count == 0) {
				return -1;
			}

			int low = 0;
			int high = Blocks.Count - 1;

			while (low &lt;= high) {

				if (high - low &lt;= 2) {
					for (int i = low; i &lt;= high; ++i) {
						var block1 = Blocks[i];
						if (c.CompareValue(block1.Top, (DataObject) key) &gt;= 0) {
							if (c.CompareValue(block1.Bottom, (DataObject) key) &lt;= 0)
								return i;
							return -(i + 1);
						}
					}
					return -(high + 1) - 1;
				}

				int mid = (low + high)/2;
				var block = Blocks[mid];

				// Is what we are searching for lower than the bottom value?
				if (c.CompareValue(block.Bottom, (DataObject) key) &gt; 0) {
					high = mid - 1;
				}
					// No, then is it greater than the highest value?
				else if (c.CompareValue(block.Top, (DataObject) key) &lt; 0) {
					low = mid + 1;
				}
					// Equal, so highest must be someplace between mid and high.
				else {
					high = mid;
				}
			}

			return -(low + 1); // key not found.
		}

		private static bool IsSmallerOrEqual(T x, T y) {
			return x.CompareTo(y) &lt;= 0;
		}

		private static bool IsGreaterOrEqual(T x, T y) {
			return x.CompareTo(y) &gt;= 0;
		}

		private static bool IsGreater(T x, T y) {
			return x.CompareTo(y) &gt; 0;
		}

		private static bool IsSmaller(T x, T y) {
			return x.CompareTo(y) &lt; 0;
		}

		/// &lt;summary&gt;
		/// Uses a binary search algorithm to quickly determine the index of the 
		/// &lt;see cref=&quot;IIndexBlock{T}&quot;/&gt; within &#39;blocks&#39; of the 
		/// block that contains the given value.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;val&quot;&gt;&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		private int FindLastBlock(T val) {
			if (Count == 0) {
				return -1;
			}

			int low = 0;
			int high = Blocks.Count - 1;

			while (low &lt;= high) {

				if (high - low &lt;= 2) {
					for (int i = high; i &gt;= low; --i) {
						var block1 = Blocks[i];
						if (IsSmallerOrEqual(block1.Bottom, val)) {
							if (IsGreaterOrEqual(block1.Top, val))
								return i;
							return -(i + 1) - 1;
						}
					}
					return -(low + 1);
				}

				int mid = (low + high)/2;
				var block = Blocks[mid];

				// Is what we are searching for lower than the bottom value?
				if (IsGreater(block.Bottom,val)) {
					high = mid - 1;
				}
					// No, then is it greater than the highest value?
				else if (IsSmaller(block.Top, val)) {
					low = mid + 1;
				}
					// Equal, so highest must be someplace between mid and high.
				else {
					low = mid;
					if (low == high) {
						return low;
					}
				}
			}

			return -(low + 1); // key not found.
		}

		/// &lt;summary&gt;
		/// Checks if the current index is mutable.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// This is called before any mutable operations on the index: if the index is 
		/// mutable and empty then an empty block is added to the index.
		/// &lt;/remarks&gt;
		/// &lt;exception cref=&quot;ApplicationException&quot;&gt;
		/// Thrown if the index is read-only.
		/// &lt;/exception&gt;
		private void CheckImmutable() {
			if (IsReadOnly)
				throw new ApplicationException(&quot;Index is read-only.&quot;);

			// HACK: We have a side effect of checking whether the list is immutable.
			//   If the block list doesn&#39;t contain any entries we add one here.  This
			//   hack reduces the memory requirements.
			if (Blocks.Count == 0) {
				InsertBlock(0, NewBlock());
			}
		}

		/// &lt;summary&gt;
		/// Copies the data from each block into the given int[] array.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;array&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;offset&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;length&quot;&gt;&lt;/param&gt;
		/// &lt;remarks&gt;
		/// The int[] array must be big enough to fit all the data in this list.
		/// &lt;/remarks&gt;
		internal void CopyToArray(T[] array, int offset, int length) {
			if (array.Length &lt; length || (offset + length) &gt; Count)
				throw new ApplicationException(&quot;Size mismatch.&quot;);

			foreach (var block in Blocks) {
				offset += block.CopyTo(array, offset);
			}
		}

		public void Insert(int index, T value) {
			CheckImmutable();

			int size = Blocks.Count;
			int start = 0;
			for (int i = 0; i &lt; size; ++i) {
				var block = Blocks[i];
				int bsize = block.Count;
				if (index &gt;= start &amp;&amp; index &lt;= start + bsize) {
					InsertIntoBlock(value, i, block, index - start);
					return;
				}
				start += bsize;
			}

			throw new ArgumentOutOfRangeException(&quot;index&quot;);
		}

		public void Add(T value) {
			CheckImmutable();

			int size = Blocks.Count;
			var block = Blocks[size - 1];
			InsertIntoBlock(value, size - 1, block, block.Count);
		}

		public T RemoveAt(int index) {
			CheckImmutable();

			int size = Blocks.Count;
			int start = 0;
			for (int i = 0; i &lt; size; ++i) {
				var block = Blocks[i];
				int bsize = block.Count;
				if (index &gt;= start &amp;&amp; index &lt;= start + bsize) {
					return RemoveFromBlock(i, block, index - start);
				}
				start += bsize;
			}

			throw new ArgumentOutOfRangeException(&quot;index&quot;);
		}

		public bool Contains(T value) {
			int blockIndex = FindLastBlock(value);

			if (blockIndex &lt; 0)
				// We didn&#39;t find in the list, so return false.
				return false;

			// We got a block, so find out if it&#39;s in the block or not.
			var block = Blocks[blockIndex];

			// Find, if not there then return false.
			return block.SearchLast(value) &gt;= 0;
		}

		public void InsertSort(T value) {
			CheckImmutable();

			int blockIndex = FindLastBlock(value);

			if (blockIndex &lt; 0) {
				// Not found a block,
				// The block to insert the value,
				blockIndex = (-(blockIndex + 1)) - 1;
				if (blockIndex &lt; 0) {
					blockIndex = 0;
				}
			}

			// We got a block, so find out if it&#39;s in the block or not.
			var block = Blocks[blockIndex];

			// The point to insert in the block,
			int i = block.SearchLast(value);
			if (i &lt; 0) {
				i = -(i + 1);
			} else {
				i = i + 1;
				// NOTE: A block can never become totally full so it&#39;s always okay to
				//   skip one ahead.
			}

			// Insert value into the block,
			InsertIntoBlock(value, blockIndex, block, i);
		}

		public bool UniqueInsertSort(T value) {
			CheckImmutable();

			int blockIndex = FindLastBlock(value);

			if (blockIndex &lt; 0) {
				// Not found a block,
				// The block to insert the value,
				blockIndex = (-(blockIndex + 1)) - 1;
				if (blockIndex &lt; 0) {
					blockIndex = 0;
				}
			}

			// We got a block, so find out if it&#39;s in the block or not.
			var block = Blocks[blockIndex];

			// The point to insert in the block,
			int i = block.SearchLast(value);
			if (i &lt; 0) {
				i = -(i + 1);
			} else {
				// This means we found the value in the given block, so return false.
				return false;
			}

			// Insert value into the block,
			InsertIntoBlock(value, blockIndex, block, i);

			// Value inserted so return true.
			return true;
		}

		public bool RemoveSort(T value) {
			CheckImmutable();

			int blockIndex = FindLastBlock(value);

			if (blockIndex &lt; 0) {
				// Not found a block,
				// The block to remove the value,
				blockIndex = (-(blockIndex + 1)) - 1;
				if (blockIndex &lt; 0) {
					blockIndex = 0;
				}
			}

			// We got a block, so find out if it&#39;s in the block or not.
			var block = Blocks[blockIndex];

			// The point to remove the block,
			int i = block.SearchLast(value);
			if (i &lt; 0) {
				// This means we can&#39;t found the value in the given block, so return
				// false.
				return false;
			}

			// Remove value into the block,
			var valRemoved = RemoveFromBlock(blockIndex, block, i);
			if (!value.Equals(valRemoved))
				throw new ApplicationException(&quot;Incorrect value removed.&quot;);

			// Value removed so return true.
			return true;
		}

		public bool Contains(object key, IIndexComparer&lt;T&gt; comparer) {
			int blockIndex = FindBlockContaining(key, comparer);

			if (blockIndex &lt; 0)
				// We didn&#39;t find in the list, so return false.
				return false;

			// We got a block, so find out if it&#39;s in the block or not.
			var block = Blocks[blockIndex];

			// Find, if not there then return false.
			return block.BinarySearch(key, comparer) &gt;= 0;
		}

		public void InsertSort(object key, T value, IIndexComparer&lt;T&gt; comparer) {
			CheckImmutable();

			int blockIndex = FindLastBlock(key, comparer);

			if (blockIndex &lt; 0) {
				// Not found a block,
				// The block to insert the value,
				blockIndex = (-(blockIndex + 1)) - 1;
				if (blockIndex &lt; 0) {
					blockIndex = 0;
				}
			}

			// We got a block, so find out if it&#39;s in the block or not.
			var block = Blocks[blockIndex];

			// The point to insert in the block,
			int i = block.SearchLast(key, comparer);
			if (i &lt; 0) {
				i = -(i + 1);
			} else {
				i = i + 1;
				// NOTE: A block can never become totally full so it&#39;s always okay to
				//   skip one ahead.
			}

			// Insert value into the block,
			InsertIntoBlock(value, blockIndex, block, i);
		}

		public T RemoveSort(object key, T value, IIndexComparer&lt;T&gt; comparer) {
			CheckImmutable();

			// Find the range of blocks that the value is in.
			int origBlockIndex = FindFirstBlock(key, comparer);
			int blockIndex = origBlockIndex;
			int lastBlockIndex = Blocks.Count - 1;

			if (blockIndex &lt; 0)
				// Not found in a block,
				throw new ApplicationException(&quot;Value (&quot; + key + &quot;) was not found in the list.&quot;);

			var block = Blocks[blockIndex];
			int i = block.IndexOf(value);
			while (i == -1) {
				// If not found, go to next block
				++blockIndex;
				if (blockIndex &gt; lastBlockIndex)
					throw new ApplicationException(&quot;Value (&quot; + key + &quot;) was not found in the list.&quot;);

				block = Blocks[blockIndex];
				// Try and find the value within this block
				i = block.IndexOf(value);
			}

			// Remove value from the block,
			return RemoveFromBlock(blockIndex, block, i);
		}

		public int SearchLast(object key, IIndexComparer&lt;T&gt; comparer) {
			int blockIndex = FindLastBlock(key, comparer);
			int sr;

			if (blockIndex &lt; 0) {
				// Guarenteed not found in any blocks so return start of insert block
				blockIndex = (-(blockIndex + 1)); // - 1;
				sr = -1;
			} else {
				// We got a block, so find out if it&#39;s in the block or not.
				var block = Blocks[blockIndex];

				// Try and find it in the block,
				sr = block.SearchLast(key, comparer);
			}

			int offset = 0;
			for (int i = 0; i &lt; blockIndex; ++i) {
				var block = Blocks[i];
				offset += block.Count;
			}

			return sr &gt;= 0 ? offset + sr : -offset + sr;
		}

		public int SearchFirst(object key, IIndexComparer&lt;T&gt; comparer) {
			int blockNum = FindFirstBlock(key, comparer);
			int sr;

			if (blockNum &lt; 0) {
				// Guarenteed not found in any blocks so return start of insert block
				blockNum = (-(blockNum + 1)); // - 1;
				sr = -1;
			} else {
				// We got a block, so find out if it&#39;s in the block or not.
				var block = Blocks[blockNum];

				// Try and find it in the block,
				sr = block.SearchFirst(key, comparer);
			}

			int offset = 0;
			for (int i = 0; i &lt; blockNum; ++i) {
				var block = Blocks[i];
				offset += block.Count;
			}

			return sr &gt;= 0 ? offset + sr : -offset + sr;
		}

		public IIndexEnumerator&lt;T&gt; GetEnumerator() {
			return GetEnumerator(0, Count - 1);
		}

		public IIndexEnumerator&lt;T&gt; GetEnumerator(int startOffset, int endOffset) {
			return new Enumerator(this, startOffset, endOffset);
		}

		IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator() {
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator() {
			return GetEnumerator();
		}

		#region Enumerator

		class Enumerator : IIndexEnumerator&lt;T&gt; {
			private readonly BlockIndexBase&lt;T&gt; index;
			private readonly int startOffset;
			private int endOffset;

			private IIndexBlock&lt;T&gt; currentBlock;
			private int currentBlockSize;
			private int blockIndex;
			private int blockOffset;

			private int currentOffset;

			public Enumerator(BlockIndexBase&lt;T&gt; index, int startOffset, int endOffset) {
				this.index = index;
				this.startOffset = startOffset;
				this.endOffset = endOffset;

				Reset();
			}

			private void SetupVars(int offset) {
				int size = index.Blocks.Count;
				int start = 0;
				for (blockIndex = 0; blockIndex &lt; size; ++blockIndex) {
					var block = index.Blocks[blockIndex];
					int bsize = block.Count;
					if (offset &lt; start + bsize) {
						blockOffset = offset - start;
						if (blockOffset &lt; 0)
							blockOffset = -1;

						currentBlock = block;
						currentBlockSize = bsize;
						return;
					}
					start += bsize;
				}

				throw new IndexOutOfRangeException(&quot;&#39;index&#39; (&quot; + offset + &quot;) out of bounds.&quot;);
			}



			public void Dispose() {
			}

			public bool MoveNext() {
				if (currentOffset &lt; endOffset) {
					++currentOffset;

					if (++blockOffset &gt;= currentBlockSize) {
						++blockIndex;
						currentBlock = index.Blocks[blockIndex];
						currentBlockSize = currentBlock.Count;
						blockOffset = 0;
					}

					return true;
				}

				return false;
			}

			public void Reset() {
				currentOffset = startOffset - 1;

				if (endOffset &gt;= startOffset) {
					// Setup variables to 1 before the start
					SetupVars(startOffset - 1);
				}
			}

			public T Current {
				get { return currentBlock[blockOffset]; }
			}

			object IEnumerator.Current {
				get { return Current; }
			}

			private void WalkBack() {
				--blockOffset;
				--currentOffset;
				if (blockOffset &lt; 0) {
					if (blockIndex &gt; 0) {
						--blockIndex;
						currentBlock = index.Blocks[blockIndex];
						currentBlockSize = currentBlock.Count;
						blockOffset = currentBlock.Count - 1;
					}
				}
			}

			public bool MoveBack() {
				if (currentOffset &gt; startOffset) {
					WalkBack();
					return true;
				}

				return false;
			}

			public void Remove() {
				index.CheckImmutable();

				// NOT ELEGANT: We check &#39;blocks&#39; size to determine if the value
				//   deletion caused blocks to be removed.  If it did, we set up the
				//   internal variables afresh with a call to &#39;setupVars&#39;.
				int origBlockCount = index.Blocks.Count;
				index.RemoveFromBlock(blockIndex, currentBlock, blockOffset);

				// Did the number of blocks in the list change?
				if (origBlockCount == index.Blocks.Count) {
					// HACK: Evaluate the current cached block size
					--currentBlockSize;
					WalkBack();
				} else {
					--currentOffset;
					SetupVars(currentOffset);
				}
				--endOffset;
			}
		}

		#endregion
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[78,3,79,12,0],[80,26,80,32,0],[80,13,80,22,0],[81,5,81,16,0],[80,23,80,25,0],[83,3,83,4,0],[85,3,86,12,0],[87,4,87,35,0],[89,5,89,48,0],[91,5,91,38,0],[92,5,92,40,0],[94,10,94,20,0],[96,6,96,30,0],[98,6,98,49,0],[100,6,100,30,0],[94,40,94,43,0],[94,21,94,38,0],[104,5,104,30,0],[107,5,107,35,0],[109,6,109,21,0],[108,5,108,25,0],[114,4,114,25,0],[115,5,115,23,0],[116,3,116,4,0],[126,5,126,29,0],[127,5,127,19,0],[128,10,128,20,0],[129,6,129,28,0],[130,6,130,30,0],[131,6,131,50,0],[132,7,132,35,0],[134,6,134,21,0],[128,31,128,34,0],[128,21,128,29,0],[137,5,137,52,0],[156,3,156,4,0],[170,5,170,39,0],[171,5,171,28,0],[172,5,172,32,0],[179,5,179,39,0],[180,5,180,32,0],[181,5,181,28,0],[195,4,195,34,0],[196,4,196,34,0],[197,4,197,33,0],[198,5,198,33,0],[200,4,200,18,0],[201,5,201,33,0],[204,4,204,24,0],[205,5,205,28,0],[207,4,207,24,0],[208,5,208,32,0],[211,4,211,36,0],[212,4,212,27,0],[213,4,213,31,0],[214,3,214,4,0],[233,5,233,40,0],[239,5,239,39,0],[240,6,240,45,0],[242,6,242,41,0],[243,7,243,26,0],[246,7,246,56,0],[251,6,251,55,0],[256,5,256,39,0],[271,4,271,44,0],[272,4,272,12,0],[275,4,275,42,0],[276,5,276,29,0],[278,4,278,20,0],[291,4,291,19,0],[292,5,292,15,0],[294,4,294,16,0],[295,4,295,32,0],[298,5,298,30,0],[299,5,299,29,0],[302,5,302,67,0],[303,6,303,21,0],[306,10,306,69,0],[307,6,307,20,0],[311,6,311,17,0],[297,4,297,23,0],[315,4,315,22,0],[347,5,347,30,0],[348,5,348,29,0],[351,5,351,67,0],[352,6,352,21,0],[355,10,355,69,0],[356,6,356,20,0],[360,6,360,16,0],[361,6,361,22,0],[362,7,362,18,0],[367,4,367,22,0],[381,5,381,15,0],[390,35,390,38,0],[398,6,398,29,0],[401,5,401,30,0],[402,5,402,29,0],[405,5,405,60,0],[406,6,406,21,0],[409,10,409,62,0],[410,6,410,20,0],[414,6,414,17,0],[418,4,418,22,0],[430,4,430,30,0],[434,4,434,30,0],[459,9,459,18,0],[455,35,455,38,0],[463,6,463,24,0],[466,5,466,30,0],[467,5,467,29,0],[470,5,470,37,0],[471,6,471,21,0],[474,10,474,40,0],[475,6,475,20,0],[479,6,479,16,0],[480,6,480,22,0],[481,7,481,18,0],[486,4,486,22,0],[501,5,501,59,0],[521,4,521,59,0],[522,5,522,54,0],[524,26,524,32,0],[524,13,524,22,0],[525,5,525,43,0],[524,23,524,25,0],[527,3,527,4,0],[530,4,530,21,0],[532,4,532,28,0],[533,4,533,18,0],[534,9,534,19,0],[535,5,535,27,0],[536,5,536,29,0],[537,5,537,50,0],[538,6,538,54,0],[539,6,539,13,0],[541,5,541,20,0],[534,30,534,33,0],[534,20,534,28,0],[544,4,544,51,0],[556,4,556,21,0],[558,4,558,28,0],[559,4,559,18,0],[560,9,560,19,0],[561,5,561,27,0],[562,5,562,29,0],[563,5,563,50,0],[564,6,564,54,0],[566,5,566,20,0],[560,30,560,33,0],[560,20,560,28,0],[569,4,569,51,0],[573,4,573,42,0],[575,4,575,23,0],[577,5,577,18,0],[580,4,580,35,0],[583,4,583,40,0],[587,4,587,21,0],[589,4,589,42,0],[591,4,591,23,0],[594,5,594,42,0],[595,5,595,24,0],[596,6,596,21,0],[601,4,601,35,0],[604,4,604,36,0],[605,4,605,14,0],[606,5,606,18,0],[608,5,608,15,0],[614,4,614,49,0],[615,3,615,4,0],[640,5,640,18,0],[651,4,651,21,0],[653,4,653,42,0],[655,4,655,23,0],[658,5,658,42,0],[659,5,659,24,0],[660,6,660,21,0],[665,4,665,35,0],[668,4,668,36,0],[669,4,669,14,0],[672,5,672,18,0],[676,4,676,59,0],[677,4,677,34,0],[678,5,678,64,0],[681,4,681,16,0],[685,4,685,56,0],[687,4,687,23,0],[689,5,689,18,0],[692,4,692,35,0],[695,4,695,50,0],[720,5,720,15,0],[730,4,730,21,0],[733,4,733,55,0],[734,4,734,36,0],[735,4,735,42,0],[737,4,737,23,0],[739,5,739,86,0],[741,4,741,35,0],[742,4,742,33,0],[745,5,745,18,0],[746,5,746,37,0],[747,6,747,87,0],[749,5,749,32,0],[751,5,751,30,0],[743,4,743,19,0],[755,4,755,49,0],[776,5,776,27,0],[777,5,777,27,0],[775,36,775,39,0],[801,5,801,27,0],[802,5,802,27,0],[800,34,800,37,0],[821,4,821,27,0],[861,6,861,21,0],[849,45,849,57,0],[864,5,864,83,0],[877,7,877,20,0],[878,7,878,47,0],[879,7,879,45,0],[880,7,880,23,0],[903,11,903,26,0],[907,5,907,19,0],[908,5,908,21,0],[909,5,909,25,0],[910,6,910,25,0],[911,7,911,20,0],[912,7,912,47,0],[913,7,913,45,0],[914,7,914,44,0],[917,4,917,5,0],[920,5,920,37,0],[921,6,921,17,0],[922,6,922,18,0],[925,5,925,18,0],[929,5,929,28,0],[934,5,934,45,0],[935,5,935,66,0],[938,5,938,46,0],[940,6,940,25,0],[941,6,941,17,0],[943,6,943,22,0],[944,6,944,31,0],[946,5,946,17,0],[947,4,947,5,0],[64,3,64,29,1],[65,4,65,14,1],[66,4,66,23,1],[67,4,67,42,1],[68,3,68,4,1],[70,3,71,12,1],[72,26,72,32,1],[72,13,72,22,1],[73,5,73,23,1],[74,5,74,26,1],[72,23,72,25,1],[76,3,76,4,1],[166,4,166,32,1],[169,4,169,33,1],[174,5,174,23,1],[178,4,178,18,1],[183,5,183,27,1],[186,4,186,17,1],[224,4,224,34,1],[226,4,226,12,1],[228,4,228,21,1],[258,3,258,4,1],[328,4,328,19,1],[329,5,329,15,1],[331,4,331,16,1],[332,4,332,32,1],[335,5,335,25,1],[336,11,336,24,1],[337,7,337,30,1],[338,7,338,71,1],[339,8,339,69,1],[340,9,340,18,1],[341,8,341,28,1],[336,35,336,38,1],[336,25,336,33,1],[344,6,344,24,1],[334,4,334,23,1],[380,4,380,19,1],[384,4,384,16,1],[385,4,385,32,1],[389,5,389,25,1],[390,11,390,23,1],[391,7,391,30,1],[392,7,392,61,1],[393,8,393,65,1],[394,9,394,18,1],[395,8,395,24,1],[390,24,390,33,1],[387,4,387,23,1],[422,4,422,31,1],[426,4,426,31,1],[445,4,445,19,1],[446,5,446,15,1],[449,4,449,16,1],[450,4,450,32,1],[454,5,454,25,1],[455,11,455,24,1],[456,7,456,30,1],[457,7,457,48,1],[458,8,458,46,1],[460,8,460,28,1],[455,25,455,33,1],[452,4,452,23,1],[500,4,500,19,1],[506,4,506,26,1],[507,5,507,32,1],[509,3,509,4,1],[548,4,548,21,1],[550,4,550,28,1],[551,4,551,33,1],[552,4,552,57,1],[553,3,553,4,1],[618,4,618,21,1],[620,4,620,42,1],[622,4,622,23,1],[625,5,625,42,1],[626,5,626,24,1],[627,6,627,21,1],[632,4,632,35,1],[635,4,635,36,1],[636,4,636,14,1],[637,5,637,18,1],[644,4,644,49,1],[647,4,647,16,1],[699,4,699,21,1],[701,4,701,50,1],[703,4,703,23,1],[706,5,706,42,1],[707,5,707,24,1],[708,6,708,21,1],[713,4,713,35,1],[716,4,716,44,1],[717,4,717,14,1],[718,5,718,18,1],[726,4,726,49,1],[727,3,727,4,1],[759,4,759,50,1],[762,4,762,23,1],[764,5,764,38,1],[765,5,765,13,1],[768,5,768,36,1],[771,5,771,42,1],[774,4,774,19,1],[775,9,775,19,1],[775,20,775,34,1],[780,4,780,48,1],[784,4,784,49,1],[787,4,787,21,1],[789,5,789,34,1],[790,5,790,13,1],[793,5,793,34,1],[796,5,796,43,1],[799,4,799,19,1],[800,9,800,19,1],[800,20,800,32,1],[805,4,805,48,1],[809,4,809,39,1],[813,4,813,56,1],[817,4,817,27,1],[838,4,838,78,1],[839,5,839,24,1],[840,5,840,36,1],[841,5,841,32,1],[843,5,843,13,1],[844,4,844,5,1],[847,5,847,35,1],[848,5,848,19,1],[849,10,849,24,1],[850,6,850,43,1],[851,6,851,30,1],[852,6,852,33,1],[853,7,853,36,1],[854,7,854,27,1],[855,8,855,25,1],[857,7,857,28,1],[858,7,858,32,1],[859,7,859,14,1],[849,26,849,43,1],[870,4,870,5,1],[873,5,873,35,1],[874,6,874,22,1],[876,6,876,44,1],[883,6,883,18,1],[886,5,886,18,1],[890,5,890,37,1],[892,5,892,34,1],[894,6,894,33,1],[896,4,896,5,1],[899,11,899,44,1]]);
    </script>
  </body>
</html>