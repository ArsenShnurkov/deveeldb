<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.store\filestoredata.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.IO;

namespace Deveel.Data.Store {
	public sealed class FileStoreData : IStoreData {
		private FileStream fileStream;
		private readonly object objectLock = new object();

		public const int BufferSize = 1024*2;

		public FileStoreData(string filePath) {
			if (String.IsNullOrEmpty(filePath))
				throw new ArgumentNullException(&quot;filePath&quot;);

			FilePath = filePath;
			IsOpen = false;
		}

		~FileStoreData() {
			Dispose(false);
		}

		public string FilePath { get; private set; }

		public bool IsOpen { get; private set; }

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing) {
			if (disposing) {
				if (IsOpen)
					Close();

				if (fileStream != null)
					fileStream.Dispose();
			}
		}

		public bool Exists {
			get {
				lock (objectLock) {
					return File.Exists(FilePath);
				}
			}
		}

		public long Length {
			get { return IsOpen ? fileStream.Length : new FileInfo(FilePath).Length; }
		}

		public bool IsReadOnly { get; private set; }

		public bool Delete() {
			if (IsOpen)
				return false;

			try {
				File.Delete(FilePath);
				return !Exists;
			} catch (Exception) {
				return false;
			}
		}

		public void Open(bool readOnly) {
			lock (objectLock) {
				var options = FileOptions.WriteThrough | FileOptions.Encrypted;

				fileStream = new FileStream(FilePath, readOnly ? FileMode.Open : FileMode.OpenOrCreate,
					readOnly ? FileAccess.Read : FileAccess.ReadWrite, FileShare.None, BufferSize, options);
				IsOpen = true;
				IsReadOnly = readOnly;
			}
		}

		public void Close() {
			lock (objectLock) {
				try {
					fileStream.Close();
				} finally {
					IsOpen = false;
				}
			}
		}

		public int Read(long position, byte[] buffer, int offset, int length) {
			// Make sure we don&#39;t Read past the end
			lock (objectLock) {
				length = System.Math.Max(0, System.Math.Min(length, (int)(Length - position)));
				int count = 0;
				if (position &lt; Length) {
					fileStream.Seek(position, SeekOrigin.Begin);
					count = fileStream.Read(buffer, offset, length);
				}
				return count;
			}
		}

		public void Write(long position, byte[] buffer, int offset, int length) {
			if (IsReadOnly)
				throw new IOException();

			// Make sure we don&#39;t Write past the end
			lock (objectLock) {
				length = System.Math.Max(0, System.Math.Min(length, (int)(Length - position)));
				if (position &lt; Length) {
					fileStream.Seek(position, SeekOrigin.Begin);
					fileStream.Write(buffer, offset, length);
				}
			}
		}

		public void Flush() {
			try {
				fileStream.Flush();
			} catch (IOException) {
				// There isn&#39;t much we can do about this exception.  By itself it
				// doesn&#39;t indicate a terminating error so it&#39;s a good idea to ignore
				// it.  Should it be silently ignored?
			}
		}

		public void SetLength(long value) {
			lock (objectLock) {
				fileStream.SetLength(value);
			}
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[23,3,23,53,0],[27,3,27,40,0],[28,4,28,39,0],[29,5,29,49,0],[31,4,31,24,0],[32,4,32,19,0],[33,3,33,4,0],[36,4,36,19,0],[37,3,37,4,0],[44,4,44,18,0],[45,4,45,30,0],[46,3,46,4,0],[49,4,49,18,0],[50,5,50,16,0],[51,6,51,14,0],[53,5,53,28,0],[54,6,54,27,0],[56,3,56,4,0],[60,5,60,22,0],[61,6,61,35,0],[63,4,63,5,0],[67,10,67,76,0],[73,4,73,15,0],[74,5,74,18,0],[77,5,77,27,0],[78,5,78,20,0],[79,6,79,23,0],[80,5,80,18,0],[82,3,82,4,0],[85,4,85,21,0],[86,5,86,68,0],[88,5,89,94,0],[90,5,90,19,0],[91,5,91,27,0],[93,3,93,4,0],[96,4,96,21,0],[98,6,98,25,0],[100,6,100,21,0],[103,3,103,4,0],[107,4,107,21,0],[108,5,108,84,0],[109,5,109,19,0],[110,5,110,27,0],[111,6,111,50,0],[112,6,112,54,0],[114,5,114,18,0],[116,3,116,4,0],[119,4,119,19,0],[120,5,120,29,0],[123,4,123,21,0],[124,5,124,84,0],[125,5,125,27,0],[126,6,126,50,0],[127,6,127,47,0],[130,3,130,4,0],[134,5,134,24,0],[135,6,135,25,0],[140,3,140,4,0],[143,4,143,21,0],[144,5,144,33,0],[146,3,146,4,0]]);
    </script>
  </body>
</html>