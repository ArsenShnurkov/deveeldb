<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.linq\evaluator.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.Linq.Expressions;

namespace Deveel.Data.Linq {
	static class Evaluator {
		/// &lt;summary&gt;
		/// Performs evaluation &amp; replacement of independent sub-trees
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;expression&quot;&gt;The root of the expression tree.&lt;/param&gt;
		/// &lt;param name=&quot;fnCanBeEvaluated&quot;&gt;A function that decides whether a given expression node can be part of the local function.&lt;/param&gt;
		/// &lt;returns&gt;A new tree with sub-trees evaluated and replaced.&lt;/returns&gt;
		public static Expression PartialEval(Expression expression, Func&lt;Expression, bool&gt; fnCanBeEvaluated) {
			return new SubtreeEvaluator(new Nominator(fnCanBeEvaluated).Nominate(expression)).Eval(expression);
		}

		/// &lt;summary&gt;
		/// Performs evaluation &amp; replacement of independent sub-trees
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;expression&quot;&gt;The root of the expression tree.&lt;/param&gt;
		/// &lt;returns&gt;A new tree with sub-trees evaluated and replaced.&lt;/returns&gt;
		public static Expression PartialEval(Expression expression) {
			return PartialEval(expression, CanBeEvaluatedLocally);
		}

		private static bool CanBeEvaluatedLocally(Expression expression) {
			return expression.NodeType != ExpressionType.Parameter;
		}

		/// &lt;summary&gt;
		/// Evaluates &amp; replaces sub-trees when first candidate is reached (top-down)
		/// &lt;/summary&gt;
		class SubtreeEvaluator : ExpressionVisitor {
			HashSet&lt;Expression&gt; candidates;

			internal SubtreeEvaluator(HashSet&lt;Expression&gt; candidates) {
				this.candidates = candidates;
			}

			internal Expression Eval(Expression exp) {
				return this.Visit(exp);
			}

			public override Expression Visit(Expression exp) {
				if (exp == null) {
					return null;
				}
				if (candidates.Contains(exp)) {
					return Evaluate(exp);
				}
				return base.Visit(exp);
			}

			private Expression Evaluate(Expression e) {
				if (e.NodeType == ExpressionType.Constant) {
					return e;
				}
				LambdaExpression lambda = Expression.Lambda(e);
				Delegate fn = lambda.Compile();
				return Expression.Constant(fn.DynamicInvoke(null), e.Type);
			}
		}

		/// &lt;summary&gt;
		/// Performs bottom-up analysis to determine which nodes can possibly
		/// be part of an evaluated sub-tree.
		/// &lt;/summary&gt;
		class Nominator : ExpressionVisitor {
			Func&lt;Expression, bool&gt; fnCanBeEvaluated;
			HashSet&lt;Expression&gt; candidates;
			bool cannotBeEvaluated;

			internal Nominator(Func&lt;Expression, bool&gt; fnCanBeEvaluated) {
				this.fnCanBeEvaluated = fnCanBeEvaluated;
			}

			internal HashSet&lt;Expression&gt; Nominate(Expression expression) {
				this.candidates = new HashSet&lt;Expression&gt;();
				this.Visit(expression);
				return this.candidates;
			}

			public override Expression Visit(Expression expression) {
				if (expression != null) {
					bool saveCannotBeEvaluated = this.cannotBeEvaluated;
					this.cannotBeEvaluated = false;
					base.Visit(expression);
					if (!this.cannotBeEvaluated) {
						if (this.fnCanBeEvaluated(expression)) {
							this.candidates.Add(expression);
						} else {
							this.cannotBeEvaluated = true;
						}
					}
					this.cannotBeEvaluated |= saveCannotBeEvaluated;
				}
				return expression;
			}
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[30,4,30,103,0],[39,4,39,58,0],[43,4,43,59,0],[52,4,52,61,0],[53,5,53,34,0],[54,4,54,5,0],[57,5,57,28,0],[61,5,61,21,0],[62,6,62,18,0],[64,5,64,34,0],[65,6,65,27,0],[67,5,67,28,0],[71,5,71,47,0],[72,6,72,15,0],[74,5,74,52,0],[75,5,75,36,0],[76,5,76,64,0],[89,4,89,63,0],[90,5,90,46,0],[91,4,91,5,0],[94,5,94,49,0],[95,5,95,28,0],[96,5,96,28,0],[100,5,100,28,0],[101,6,101,58,0],[102,6,102,37,0],[103,6,103,29,0],[104,6,104,34,0],[105,7,105,45,0],[106,8,106,40,0],[108,8,108,38,0],[111,6,111,54,0],[113,5,113,23,0]]);
    </script>
  </body>
</html>