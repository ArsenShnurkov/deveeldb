<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.expressions\sqlexpression.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;

using Deveel.Data.DbSystem;
using Deveel.Data.Sql.Compile;
using Deveel.Data.Types;

namespace Deveel.Data.Sql.Expressions {
	/// &lt;summary&gt;
	/// Defines the base class for instances that represent SQL expression tree nodes.
	/// &lt;/summary&gt;
	/// &lt;remarks&gt;
	/// The architecture of the SQL Expression domain is to keep the implementation
	/// internal to the project, that means it will be possible to construct expressions
	/// only through this class, calling factory methods (for example &lt;see cref=&quot;Binary&quot;/&gt;).
	/// &lt;/remarks&gt;
	[Serializable]
	public abstract class SqlExpression {
		/// &lt;summary&gt;
		/// Internally constructs the SQL expression, avoiding external implementations
		/// to be allowed to inherit this class.
		/// &lt;/summary&gt;
		internal SqlExpression() {
		}

		/// &lt;summary&gt;
		/// Gets the type code of this SQL expression.
		/// &lt;/summary&gt;
		public abstract SqlExpressionType ExpressionType { get; }

		/// &lt;summary&gt;
		/// Gets a value indicating whether the expression can be evaluated
		/// to another simpler one.
		/// &lt;/summary&gt;
		/// &lt;seealso cref=&quot;Evaluate(EvaluateContext)&quot;/&gt;
		public virtual bool CanEvaluate {
			get { return false; }
		}

		internal int EvaluatePrecedence {
			get {
				// Primary
				if (ExpressionType == SqlExpressionType.Reference ||
				    ExpressionType == SqlExpressionType.FunctionCall ||
					ExpressionType == SqlExpressionType.Constant)
					return 150;

				// Unary
				if (ExpressionType == SqlExpressionType.UnaryPlus ||
				    ExpressionType == SqlExpressionType.Negate ||
				    ExpressionType == SqlExpressionType.Not)
					return 140;

				// Cast
				if (ExpressionType == SqlExpressionType.Cast)
					return 139;

				// Multiplicative
				if (ExpressionType == SqlExpressionType.Multiply ||
				    ExpressionType == SqlExpressionType.Divide ||
				    ExpressionType == SqlExpressionType.Modulo)
					return 130;

				// Additive
				if (ExpressionType == SqlExpressionType.Add ||
				    ExpressionType == SqlExpressionType.Subtract)
					return 120;

				// Relational
				if (ExpressionType == SqlExpressionType.GreaterThan ||
				    ExpressionType == SqlExpressionType.GreaterOrEqualThan ||
				    ExpressionType == SqlExpressionType.SmallerThan ||
				    ExpressionType == SqlExpressionType.SmallerOrEqualThan ||
					ExpressionType == SqlExpressionType.Is ||
					ExpressionType == SqlExpressionType.IsNot ||
					ExpressionType == SqlExpressionType.Like ||
					ExpressionType == SqlExpressionType.NotLike)
					return 110;

				// Equality
				if (ExpressionType == SqlExpressionType.Equal ||
				    ExpressionType == SqlExpressionType.NotEqual)
					return 100;

				// Logical
				if (ExpressionType == SqlExpressionType.And)
					return 90;
				if (ExpressionType == SqlExpressionType.Or)
					return 89;
				if (ExpressionType == SqlExpressionType.XOr)
					return 88;

				if (ExpressionType == SqlExpressionType.Conditional)
					return 80;

				if (ExpressionType == SqlExpressionType.Assign)
					return 70;

				if (ExpressionType == SqlExpressionType.Tuple)
					return 60;

				return -1;
			}
		}

		public virtual SqlExpression Prepare(IExpressionPreparer preparer) {
			var visitor = new PreparerVisitor(preparer);
			return visitor.Visit(this);
		}

		public virtual SqlExpression Accept(SqlExpressionVisitor visitor) {
			return visitor.Visit(this);
		}

		/// &lt;summary&gt;
		/// When overridden by a derived class, this method evaluates the expression
		/// within the provided context.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;context&quot;&gt;The context for the evaluation of the expression, providing
		/// access to the system or to the execution context.&lt;/param&gt;
		/// &lt;remarks&gt;
		/// &lt;para&gt;
		/// This method is only executed is &lt;see cref=&quot;CanEvaluate&quot;/&gt; is &lt;c&gt;true&lt;/c&gt;, and the
		/// override method can reduce this expression to a simpler form.
		/// &lt;/para&gt;
		/// &lt;/remarks&gt;
		/// &lt;returns&gt;
		/// Returns a new &lt;seealso cref=&quot;SqlExpression&quot;/&gt; that is the result of the
		/// evaluation of this expression, within the context given.
		/// &lt;/returns&gt;
		/// &lt;exception cref=&quot;ExpressionEvaluateException&quot;&gt;
		/// If any error occurred while evaluating the expression.
		/// &lt;/exception&gt;
		public virtual SqlExpression Evaluate(EvaluateContext context) {
			var visitor = new ExpressionEvaluatorVisitor(context);
			return visitor.Visit(this);
		}

		/// &lt;summary&gt;
		/// Statically evaluates the expression, outside any context.
		/// &lt;/summary&gt;
		/// &lt;para&gt;
		/// This overload of the &lt;c&gt;Evaluate&lt;/c&gt; logic provides an empty context
		/// to &lt;see cref=&quot;Evaluate(EvaluateContext)&quot;/&gt;, so that dynamic resolutions
		/// (eg. function calls, states assessments, etc.) will throw an exception.
		/// &lt;/para&gt;
		/// &lt;para&gt;
		/// Care must be taken when calling this method, that the expression tree
		/// represented does not contain any reference to dynamically resolved
		/// expressions (&lt;see cref=&quot;SqlFunctionCallExpression&quot;/&gt; for example), otherwise
		/// its evaluation will result in an exception state.
		/// &lt;/para&gt;
		/// &lt;returns&gt;
		/// Returns a new &lt;seealso cref=&quot;SqlExpression&quot;/&gt; that is the result of the
		/// static evaluation of this expression.
		/// &lt;/returns&gt;
		/// &lt;exception cref=&quot;ExpressionEvaluateException&quot;&gt;
		/// If any error occurred while evaluating the expression.
		/// &lt;/exception&gt;
		public SqlExpression Evaluate() {
			return Evaluate(null, null);
		}

		public SqlExpression Evaluate(IQueryContext context, IVariableResolver variables) {
			return Evaluate(context, variables, null);
		}

		public SqlExpression Evaluate(IQueryContext context, IVariableResolver variables, IGroupResolver group) {
			return Evaluate(new EvaluateContext(context, variables, group));
		}

		public override string ToString() {
			var builder = new ExpressionStringBuilder();
			return builder.ToSqlString(this);
		}

		/// &lt;summary&gt;
		/// Parses the given SQL string to an expression that can be evaluated.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;s&quot;&gt;The string to parse.&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns an instance of &lt;seealso cref=&quot;SqlExpression&quot;/&gt; that represents
		/// the given SQL string parsed.
		/// &lt;/returns&gt;
		public static SqlExpression Parse(string s) {
			try {
				var compiler = SqlParsers.Expression;
				var result = compiler.Parse(s);

				if (result.HasErrors)
					throw new SqlParseException();

				var visitor = new ExpressionBuilder();
				return visitor.Build(result.RootNode);
			} catch (SqlParseException ex) {
				throw new SqlExpressionException(ExpressionErrorCodes.CannotParse,
					&quot;Could not parse input expression: see inner exception for details.&quot;, ex);
			}
		}

		#region Factory Methods 

		#region Primary

		public static SqlConstantExpression Constant(object value) {
			return Constant(DataObject.Create(value));
		}

		public static SqlConstantExpression Constant(DataObject value) {
			return new SqlConstantExpression(value);
		}

		public static SqlCastExpression Cast(SqlExpression value, DataType destType) {
			return new SqlCastExpression(value, destType);
		}

		public static SqlFunctionCallExpression FunctionCall(ObjectName functionName) {
			return FunctionCall(functionName, new SqlExpression[0]);
		}

		public static SqlFunctionCallExpression FunctionCall(ObjectName functionName, SqlExpression[] args) {
			return new SqlFunctionCallExpression(functionName, args);
		}

		public static SqlFunctionCallExpression FunctionCall(string functionName) {
			return FunctionCall(functionName, new SqlExpression[0]);
		}

		public static SqlFunctionCallExpression FunctionCall(string functionName, SqlExpression[] args) {
			return FunctionCall(ObjectName.Parse(functionName), args);
		}

		public static SqlReferenceExpression Reference(ObjectName objectName) {
			return new SqlReferenceExpression(objectName);
		}

		public static SqlVariableReferenceExpression VariableReference(string varName) {
			return new SqlVariableReferenceExpression(varName);
		}
 
		#endregion

		public static SqlConditionalExpression Conditional(SqlExpression testExpression, SqlExpression ifTrue) {
			return Conditional(testExpression, ifTrue, null);
		}

		public static SqlConditionalExpression Conditional(SqlExpression testExpression, SqlExpression ifTrue, SqlExpression ifFalse) {
			return new SqlConditionalExpression(testExpression, ifTrue, ifFalse);
		}

		#region Binary Expressions

		public static SqlBinaryExpression Binary(SqlExpression left, SqlExpressionType expressionType, SqlExpression right) {
			if (expressionType == SqlExpressionType.Add)
				return Add(left, right);
			if (expressionType == SqlExpressionType.Subtract)
				return Subtract(left, right);
			if (expressionType == SqlExpressionType.Multiply)
				return Multiply(left, right);
			if (expressionType == SqlExpressionType.Divide)
				return Divide(left, right);
			if (expressionType == SqlExpressionType.Modulo)
				return Modulo(left, right);

			if (expressionType == SqlExpressionType.Equal)
				return Equal(left, right);
			if (expressionType == SqlExpressionType.NotEqual)
				return NotEqual(left, right);
			if (expressionType == SqlExpressionType.Is)
				return Is(left, right);
			if (expressionType == SqlExpressionType.IsNot)
				return IsNot(left, right);
			if (expressionType == SqlExpressionType.GreaterThan)
				return GreaterThan(left, right);
			if (expressionType == SqlExpressionType.GreaterOrEqualThan)
				return GreaterOrEqualThan(left, right);
			if (expressionType == SqlExpressionType.SmallerThan)
				return SmallerThan(left, right);
			if (expressionType == SqlExpressionType.SmallerOrEqualThan)
				return SmallerOrEqualThan(left, right);

			if (expressionType == SqlExpressionType.Like)
				return Like(left, right);
			if (expressionType == SqlExpressionType.NotLike)
				return NotLike(left, right);

			if (expressionType == SqlExpressionType.And)
				return And(left, right);
			if (expressionType == SqlExpressionType.Or)
				return Or(left, right);
			if (expressionType == SqlExpressionType.XOr)
				return XOr(left, right);

			throw new ArgumentException(String.Format(&quot;Expression type {0} is not a Binary&quot;, expressionType));
		}

		public static SqlBinaryExpression Equal(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.Equal, right);
		}

		public static SqlBinaryExpression NotEqual(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.NotEqual, right);
		}

		public static SqlBinaryExpression Is(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.Is, right);
		}

		public static SqlBinaryExpression IsNot(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.IsNot, right);
		}

		public static SqlBinaryExpression SmallerOrEqualThan(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.SmallerOrEqualThan, right);
		}

		public static SqlBinaryExpression GreaterOrEqualThan(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.GreaterOrEqualThan, right);
		}

		public static SqlBinaryExpression SmallerThan(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.SmallerThan, right);
		}

		public static SqlBinaryExpression GreaterThan(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.GreaterThan, right);
		}

		public static SqlBinaryExpression Like(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.Like, right);
		}

		public static SqlBinaryExpression NotLike(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.NotLike, right);
		}

		public static SqlBinaryExpression And(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.And, right);
		}

		public static SqlBinaryExpression Or(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.Or, right);
		}

		public static SqlBinaryExpression XOr(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.XOr, right);
		}

		public static SqlBinaryExpression Add(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.Add, right);
		}

		public static SqlBinaryExpression Subtract(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.Subtract, right);
		}

		public static SqlBinaryExpression Multiply(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.Multiply, right);
		}

		public static SqlBinaryExpression Divide(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.Divide, right);
		}

		public static SqlBinaryExpression Modulo(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.Modulo, right);
		}

		public static SqlBinaryExpression AnyEqual(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.AnyEqual, right);
		}

		public static SqlBinaryExpression AnyNotEqual(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.AnyNotEqual, right);
		}

		public static SqlBinaryExpression AnyGreaterThan(SqlExpression left, SqlExpression right) {
			return new SqlBinaryExpression(left, SqlExpressionType.AnyGreaterThan, right);
		}

		#endregion

		#region Unary Expressions

		public static SqlUnaryExpression Unary(SqlExpressionType expressionType, SqlExpression operand) {
			if (expressionType == SqlExpressionType.UnaryPlus)
				return UnaryPlus(operand);
			if (expressionType == SqlExpressionType.Negate)
				return Negate(operand);
			if (expressionType == SqlExpressionType.Not)
				return Not(operand);

			throw new ArgumentException(String.Format(&quot;Expression Type {0} is not an Unary.&quot;, expressionType));
		}

		public static SqlUnaryExpression Not(SqlExpression operand) {
			return new SqlUnaryExpression(SqlExpressionType.Not, operand);
		}

		public static SqlUnaryExpression Negate(SqlExpression operand) {
			return new SqlUnaryExpression(SqlExpressionType.Negate, operand);
		}

		public static SqlUnaryExpression UnaryPlus(SqlExpression operand) {
			return new SqlUnaryExpression(SqlExpressionType.UnaryPlus, operand);
		}

		#endregion

		public static SqlAssignExpression Assign(string reference, SqlExpression valueExpression) {
			return Assign(ObjectName.Parse(reference), valueExpression);
		}

		public static SqlAssignExpression Assign(ObjectName reference, SqlExpression expression) {
			return new SqlAssignExpression(reference, expression);
		}

		public static SqlTupleExpression Tuple(SqlExpression[] expressions) {
			return new SqlTupleExpression(expressions);
		}

		public static SqlTupleExpression Tuple(SqlExpression expr1, SqlExpression exp2) {
			return Tuple(new[] {expr1, exp2});
		}

		public static SqlTupleExpression Tuple(SqlExpression expr1, SqlExpression expr2, SqlExpression expr3) {
			return Tuple(new[] {expr1, expr2, expr3});
		}

		#endregion
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[52,10,52,23,0],[67,6,67,17,0],[71,6,71,17,0],[80,5,81,54,0],[82,6,82,17,0],[85,5,92,50,0],[93,6,93,17,0],[96,5,97,54,0],[98,6,98,17,0],[101,5,101,49,0],[102,6,102,16,0],[103,5,103,48,0],[104,6,104,16,0],[105,5,105,49,0],[106,6,106,16,0],[108,5,108,57,0],[109,6,109,16,0],[111,5,111,52,0],[112,6,112,16,0],[114,5,114,51,0],[115,6,115,16,0],[117,5,117,15,0],[122,4,122,48,0],[123,4,123,31,0],[127,4,127,31,0],[206,6,206,36,0],[210,6,210,34,0],[211,5,212,80,0],[229,4,229,50,0],[233,4,233,60,0],[241,4,241,60,0],[253,4,253,55,0],[259,4,259,53,0],[263,4,263,73,0],[276,5,276,32,0],[278,5,278,32,0],[283,5,283,34,0],[285,5,285,28,0],[287,5,287,31,0],[291,5,291,44,0],[293,5,293,37,0],[295,5,295,44,0],[299,4,299,52,0],[300,5,300,33,0],[302,4,302,48,0],[303,5,303,29,0],[304,4,304,47,0],[305,5,305,28,0],[306,4,306,48,0],[307,5,307,29,0],[309,4,309,102,0],[317,4,317,76,0],[321,4,321,70,0],[325,4,325,73,0],[329,4,329,86,0],[333,4,333,86,0],[337,4,337,79,0],[349,4,349,75,0],[357,4,357,70,0],[361,4,361,71,0],[377,4,377,74,0],[381,4,381,74,0],[385,4,385,76,0],[389,4,389,79,0],[393,4,393,82,0],[401,4,401,54,0],[402,5,402,31,0],[403,4,403,51,0],[404,5,404,28,0],[405,4,405,48,0],[406,5,406,25,0],[408,4,408,103,0],[412,4,412,66,0],[416,4,416,69,0],[420,4,420,72,0],[426,4,426,64,0],[430,4,430,58,0],[438,4,438,38,0],[442,4,442,46,0],[38,3,38,27,1],[39,3,39,4,1],[58,5,60,51,1],[61,6,61,17,1],[64,5,66,49,1],[70,5,70,50,1],[74,5,76,52,1],[77,6,77,17,1],[150,4,150,58,1],[151,4,151,31,1],[176,4,176,32,1],[180,4,180,46,1],[184,4,184,68,1],[188,4,188,48,1],[189,4,189,37,1],[202,5,202,42,1],[203,5,203,36,1],[205,5,205,26,1],[208,5,208,43,1],[209,5,209,43,1],[214,3,214,4,1],[221,4,221,46,1],[225,4,225,44,1],[237,4,237,61,1],[245,4,245,62,1],[249,4,249,50,1],[269,4,269,48,1],[270,5,270,29,1],[271,4,271,53,1],[272,5,272,34,1],[273,4,273,53,1],[274,5,274,34,1],[275,4,275,51,1],[277,4,277,51,1],[280,4,280,50,1],[281,5,281,31,1],[282,4,282,53,1],[284,4,284,47,1],[286,4,286,50,1],[288,4,288,56,1],[289,5,289,37,1],[290,4,290,63,1],[292,4,292,56,1],[294,4,294,63,1],[297,4,297,49,1],[298,5,298,30,1],[313,4,313,73,1],[341,4,341,79,1],[345,4,345,72,1],[353,4,353,71,1],[365,4,365,71,1],[369,4,369,76,1],[373,4,373,76,1],[434,4,434,47,1]]);
    </script>
  </body>
</html>