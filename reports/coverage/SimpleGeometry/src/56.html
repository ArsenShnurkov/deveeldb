<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.index\indexsetstore.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Schema;

using Deveel.Data.DbSystem;
using Deveel.Data.Store;

namespace Deveel.Data.Index {
	class IndexSetStore {
		private IArea startArea;

		private long indexHeaderPointer;
		private IArea indexHeaderArea;

		private IndexBlock[] indexBlocks;

		private bool disposed;

		private const int Magic = 0x0CA90291;

		public IndexSetStore(IDatabaseContext databaseContext, IStore store) {
			Store = store;
		}

		public IStore Store { get; private set; }

		internal void DeleteAreas(IEnumerable&lt;int&gt; deletedAreas) {
			lock (this) {
				if (Store != null) {
					try {
						Store.LockForWrite();

						foreach (var id in deletedAreas) {
							Store.DeleteArea(id);
						}

					} catch (IOException e) {
						// TODO: Raise the error to the system
					} finally {
						Store.UnlockForWrite();
					}
				}
			}
		}

		private long CreateNewBlock() {
			// Allocate the area
			var a = Store.CreateArea(16);
			long indexBlockP = a.Id;
			// Setup the header
			a.WriteInt4(1);     // version
			a.WriteInt4(0);     // reserved
			a.WriteInt8(0);    // block entries
			a.Flush();

			return indexBlockP;
		}

		public long Create() {
			lock (this) {
				// Create an empty index header area
				var a = Store.CreateArea(16);
				indexHeaderPointer = a.Id;
				a.WriteInt4(1); // version
				a.WriteInt4(0); // reserved
				a.WriteInt8(0); // number of indexes in the set
				a.Flush();

				// Set up the local IArea object for the index header
				indexHeaderArea = Store.GetArea(indexHeaderPointer);

				indexBlocks = new IndexBlock[0];

				// Allocate the starting header
				var sa = Store.CreateArea(32);
				long startPointer = sa.Id;
				// The magic
				sa.WriteInt4(Magic);
				// The version
				sa.WriteInt4(1);
				// Pointer to the index header
				sa.WriteInt8(indexHeaderPointer);
				sa.Flush();

				// Set the &#39;start_area&#39; value.
				startArea = Store.GetArea(startPointer);

				return startPointer;
			}
		}

		public void Open(long startPointer) {
			lock (this) {
				// Set up the start area
				startArea = Store.GetArea(startPointer);

				int magic = startArea.ReadInt4();
				if (magic != Magic)
					throw new IOException(&quot;Magic value for index set does not match.&quot;);

				int version = startArea.ReadInt4();
				if (version != 1)
					throw new IOException(&quot;Unknown version for index set.&quot;);

				// Setup the index_header area
				indexHeaderPointer = startArea.ReadInt8();
				indexHeaderArea = Store.GetArea(indexHeaderPointer);

				// Read the index header area
				version = indexHeaderArea.ReadInt4(); // version
				if (version != 1)
					throw new IOException(&quot;Incorrect version&quot;);

				indexHeaderArea.ReadInt4(); // reserved
				int indexCount = (int)indexHeaderArea.ReadInt8();
				indexBlocks = new IndexBlock[indexCount];

				// Initialize each index block
				for (int i = 0; i &lt; indexCount; ++i) {
					int type = indexHeaderArea.ReadInt4();
					int blockSize = indexHeaderArea.ReadInt4();
					long indexBlockPointer = indexHeaderArea.ReadInt8();
					if (type != 1)
						throw new IOException(&quot;Do not understand index type: &quot; + type);

					indexBlocks[i] = new IndexBlock(this, i, blockSize, indexBlockPointer);
					indexBlocks[i].AddReference();
				}
			}
		}

		public void Close() {
			lock (this) {
				if (Store != null) {
					for (int i = 0; i &lt; indexBlocks.Length; ++i) {
						indexBlocks[i].RemoveReference();
					}
					Store = null;
					indexBlocks = null;
				}
			}
		}

		public void GetAreasUsed(List&lt;long&gt; list) {
			list.Add(startArea.Id);
			list.Add(indexHeaderPointer);

			foreach (var block in indexBlocks) {
				list.Add(block.StartOffset);
				long[] blockPointers = block.GetBlockPointers();
				list.AddRange(blockPointers);
			}
		}

		public void PrepareIndexLists(int count, int type, int blockSize) {
			lock (this) {
				try {
					Store.LockForWrite();

					// Allocate a new area for the list
					int newSize = 16 + ((indexBlocks.Length + count) * 16);
					var newIndexArea = Store.CreateArea(newSize);
					long newIndexPointer = newIndexArea.Id;
					var newIndexBlocks = new IndexBlock[(indexBlocks.Length + count)];

					// Copy the existing area
					indexHeaderArea.Position = 0;
					int version = indexHeaderArea.ReadInt4();
					int reserved = indexHeaderArea.ReadInt4();
					long icount = indexHeaderArea.ReadInt8();
					newIndexArea.WriteInt4(version);
					newIndexArea.WriteInt4(reserved);
					newIndexArea.WriteInt8(icount + count);

					for (int i = 0; i &lt; indexBlocks.Length; ++i) {
						int itype = indexHeaderArea.ReadInt4();
						int iblockSize = indexHeaderArea.ReadInt4();
						long indexBlockP = indexHeaderArea.ReadInt8();

						newIndexArea.WriteInt4(itype);
						newIndexArea.WriteInt4(iblockSize);
						newIndexArea.WriteInt8(indexBlockP);

						newIndexBlocks[i] = indexBlocks[i];
					}

					// Add the new entries
					for (int i = 0; i &lt; count; ++i) {
						long newBlankBlockP = CreateNewBlock();

						newIndexArea.WriteInt4(type);
						newIndexArea.WriteInt4(blockSize);
						newIndexArea.WriteInt8(newBlankBlockP);

						var newBlock = new IndexBlock(this, indexBlocks.Length + i, blockSize, newBlankBlockP);
						newBlock.AddReference();
						newIndexBlocks[indexBlocks.Length + i] = newBlock;
					}

					// Finished initializing the index.
					newIndexArea.Flush();

					// The old index header pointer
					long oldIndexHeaderP = indexHeaderPointer;

					// Update the state of this object,
					indexHeaderPointer = newIndexPointer;
					indexHeaderArea = Store.GetArea(newIndexPointer);
					indexBlocks = newIndexBlocks;

					// Update the start pointer
					startArea.Position = 8;
					startArea.WriteInt8(newIndexPointer);
					startArea.Flush();

					// Free the old header
					Store.DeleteArea(oldIndexHeaderP);
				} finally {
					Store.UnlockForWrite();
				}
			}
		}

		public IIndexSet GetSnapshotIndex() {
			lock (this) {
				// Clone the blocks list.  This represents the current snapshot of the
				// index state.
				var snapshotIndexBlocks = (IndexBlock[])indexBlocks.Clone();

				// Add this as the reference
				for (int i = 0; i &lt; snapshotIndexBlocks.Length; ++i) {
					snapshotIndexBlocks[i].AddReference();
				}

				return new SnapshotIndexSet(this, snapshotIndexBlocks);
			}
		}

		private void CommitIndexHeader() {
			lock (this) {
				// Make a new index header area for the changed set.
				var a = Store.CreateArea(16 + (indexBlocks.Length * 16));
				long aOffset = a.Id;

				a.WriteInt4(1); // version
				a.WriteInt4(0); // reserved
				a.WriteInt8(indexBlocks.Length); // count

				foreach (var indBlock in indexBlocks) {
					a.WriteInt4(1);
					a.WriteInt4(indBlock.BlockSize);
					a.WriteInt8(indBlock.StartOffset);
				}

				// Finish creating the updated header
				a.Flush();

				// The old index header pointer
				long oldIndexHeaderP = indexHeaderPointer;

				// Set the new index header
				indexHeaderPointer = aOffset;
				indexHeaderArea = Store.GetArea(indexHeaderPointer);

				// Write the change to &#39;startPointer&#39;
				startArea.Position = 8;
				startArea.WriteInt8(indexHeaderPointer);
				startArea.Flush();

				// Free the old header index
				Store.DeleteArea(oldIndexHeaderP);
			}
		}

		public void CommitIndexSet(IIndexSet indexSet) {
			var removedBlocks = new List&lt;IndexBlock&gt;();

			lock (this) {
				var sIndexSet = (SnapshotIndexSet)indexSet;
				var indices = sIndexSet.AllIndices.ToList();

				try {
					try {
						Store.LockForWrite();

						// For each Index in the index set,
						foreach (var index in indices) {
							int indexNum = index.IndexNumber;

							// The IndexBlock we are changing
							var curIndexBlock = indexBlocks[indexNum];

							// Get all the blocks in the list
							var blocks = index.AllBlocks.ToList();

							// Make up a new block list for this index set.
							var area = Store.CreateArea(16 + (blocks.Count * 28));
							long blockP = area.Id;
							area.WriteInt4(1);               // version
							area.WriteInt4(0);               // reserved
							area.WriteInt8(blocks.Count);  // block count

							foreach (var block in blocks) {
								var mappedBlock = (IMappedBlock)block;

								long bottomInt = 0;
								long topInt = 0;
								int blockSize = mappedBlock.Count;
								if (blockSize &gt; 0) {
									bottomInt = mappedBlock.Bottom;
									topInt = mappedBlock.Top;
								}

								long blockPointer = mappedBlock.BlockPointer;

								// Is the block new or was it changed?
								if (blockPointer == -1 || mappedBlock.HasChanged) {
									// If this isn&#39;t -1 then write this sector on the list of
									// sectors to delete during GC.
									if (blockPointer != -1)
										curIndexBlock.AddDeletedArea(blockPointer);

									// This is a new block or a block that&#39;s been changed
									// Write the block to the file system
									blockPointer = mappedBlock.Flush();
								}

								area.WriteInt8(bottomInt);
								area.WriteInt8(topInt);
								area.WriteInt8(blockPointer);
								area.WriteInt4(blockSize | (((int)mappedBlock.CompactType) &lt;&lt; 24));
							}

							// Finish initializing the area
							area.Flush();

							// Add the deleted blocks
							var deletedBlocks = index.DeletedBlocks.ToArray();
							for (int i = 0; i &lt; deletedBlocks.Length; ++i) {
								long delBlockP = deletedBlocks[i].BlockPointer;
								if (delBlockP != -1)
									curIndexBlock.AddDeletedArea(delBlockP);
							}

							// Mark the current block as deleted
							curIndexBlock.MarkAsDeleted();

							// Now create a new IndexBlock object
							var newIndexBlock = new IndexBlock(this, indexNum, curIndexBlock.BlockSize, blockP);
							newIndexBlock.Parent = curIndexBlock;

							// Add reference to the new one
							newIndexBlock.AddReference();

							// Update the index_blocks list
							indexBlocks[indexNum] = newIndexBlock;

							// We remove this later.
							removedBlocks.Add(curIndexBlock);
						}

						// Commit the new index header (index_blocks)
						CommitIndexHeader();
					} finally {
						Store.UnlockForWrite();
					}

					// Commit finished.

				} catch (IOException e) {
					throw new ApplicationException(&quot;IO Error: &quot; + e.Message, e);
				}

			}

			// Remove all the references for the changed blocks,
			foreach (var block in removedBlocks) {
				block.RemoveReference();
			}
		}

		public void CommitDropIndex(int indexNum) {
			lock (this) {
				// The IndexBlock we are dropping
				var curIndexBlock = indexBlocks[indexNum];
				int blockSize = curIndexBlock.BlockSize;

				try {
					Store.LockForWrite();

					// Add all the elements to the deleted areas in the block
					var allBlockPointers = curIndexBlock.GetBlockPointers();
					foreach (long area in allBlockPointers) {
						curIndexBlock.AddDeletedArea(area);
					}

					// Mark the current block as deleted
					curIndexBlock.MarkAsDeleted();

					// Make up a new blank block list for this index set.
					long blockP = CreateNewBlock();

					// Now create a new IndexBlock object
					var newIndexBlock = new IndexBlock(this, indexNum, blockSize, blockP);

					// Add reference to the new one
					newIndexBlock.AddReference();
					// Remove reference to the old
					curIndexBlock.RemoveReference();
					// Update the index_blocks list
					indexBlocks[indexNum] = newIndexBlock;

					// Commit the new index header (index_blocks)
					CommitIndexHeader();
				} finally {
					Store.UnlockForWrite();
				}
			}
		}

		#region IndexBlock

		#endregion
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[55,8,55,29,0],[117,6,117,73,0],[121,6,121,62,0],[130,6,130,49,0],[142,7,142,70,0],[163,4,163,27,0],[164,4,164,33,0],[166,26,166,37,0],[166,13,166,22,0],[167,5,167,33,0],[168,5,168,53,0],[169,5,169,34,0],[166,23,166,25,0],[171,3,171,4,0],[194,7,194,46,0],[195,7,195,51,0],[196,7,196,53,0],[198,7,198,37,0],[199,7,199,42,0],[200,7,200,43,0],[202,7,202,42,0],[193,46,193,49,0],[358,9,358,56,0],[359,9,359,29,0],[360,10,360,50,0],[357,50,357,53,0],[388,7,388,28,0],[389,6,389,66,0],[401,4,401,15,0],[403,5,403,47,0],[404,5,404,45,0],[407,6,407,27,0],[410,6,410,62,0],[411,28,411,44,0],[411,15,411,24,0],[412,7,412,42,0],[411,25,411,27,0],[416,6,416,36,0],[419,6,419,37,0],[422,6,422,76,0],[425,6,425,35,0],[427,6,427,38,0],[429,6,429,44,0],[432,6,432,26,0],[434,6,434,29,0],[437,3,437,4,0],[39,3,39,71,1],[40,4,40,18,1],[41,3,41,4,1],[46,4,46,15,1],[47,5,47,23,1],[49,7,49,28,1],[51,26,51,38,1],[51,16,51,22,1],[52,8,52,29,1],[51,23,51,25,1],[58,7,58,30,1],[62,3,62,4,1],[66,4,66,33,1],[67,4,67,28,1],[69,4,69,19,1],[70,4,70,19,1],[71,4,71,19,1],[72,4,72,14,1],[74,4,74,23,1],[78,4,78,15,1],[80,5,80,34,1],[81,5,81,31,1],[82,5,82,20,1],[83,5,83,20,1],[84,5,84,20,1],[85,5,85,15,1],[88,5,88,57,1],[90,5,90,37,1],[93,5,93,35,1],[94,5,94,31,1],[96,5,96,25,1],[98,5,98,21,1],[100,5,100,38,1],[101,5,101,16,1],[104,5,104,45,1],[106,5,106,25,1],[108,3,108,4,1],[111,4,111,15,1],[113,5,113,45,1],[115,5,115,38,1],[116,5,116,24,1],[119,5,119,40,1],[120,5,120,22,1],[124,5,124,47,1],[125,5,125,57,1],[128,5,128,42,1],[129,5,129,22,1],[132,5,132,32,1],[133,5,133,54,1],[134,5,134,46,1],[137,10,137,20,1],[138,6,138,44,1],[139,6,139,49,1],[140,6,140,58,1],[141,6,141,20,1],[144,6,144,77,1],[145,6,145,36,1],[137,37,137,40,1],[137,21,137,35,1],[148,3,148,4,1],[151,4,151,15,1],[152,5,152,23,1],[153,11,153,21,1],[154,7,154,40,1],[153,46,153,49,1],[153,22,153,44,1],[156,6,156,19,1],[157,6,157,25,1],[160,3,160,4,1],[174,4,174,15,1],[176,6,176,27,1],[179,6,179,61,1],[180,6,180,51,1],[181,6,181,45,1],[182,6,182,72,1],[185,6,185,35,1],[186,6,186,47,1],[187,6,187,48,1],[188,6,188,47,1],[189,6,189,38,1],[190,6,190,39,1],[191,6,191,45,1],[193,11,193,21,1],[193,22,193,44,1],[206,11,206,21,1],[207,7,207,46,1],[209,7,209,36,1],[210,7,210,41,1],[211,7,211,46,1],[213,7,213,94,1],[214,7,214,31,1],[215,7,215,57,1],[206,33,206,36,1],[206,22,206,31,1],[219,6,219,27,1],[222,6,222,48,1],[225,6,225,43,1],[226,6,226,55,1],[227,6,227,35,1],[230,6,230,29,1],[231,6,231,43,1],[232,6,232,24,1],[235,6,235,40,1],[237,6,237,29,1],[240,3,240,4,1],[243,4,243,15,1],[246,5,246,65,1],[249,10,249,20,1],[250,6,250,44,1],[249,53,249,56,1],[249,21,249,51,1],[253,5,253,60,1],[255,3,255,4,1],[258,4,258,15,1],[260,5,260,62,1],[261,5,261,25,1],[263,5,263,20,1],[264,5,264,20,1],[265,5,265,37,1],[267,30,267,41,1],[267,14,267,26,1],[268,6,268,21,1],[269,6,269,38,1],[270,6,270,40,1],[267,27,267,29,1],[274,5,274,15,1],[277,5,277,47,1],[280,5,280,34,1],[281,5,281,57,1],[284,5,284,28,1],[285,5,285,45,1],[286,5,286,23,1],[289,5,289,39,1],[291,3,291,4,1],[294,4,294,47,1],[296,4,296,15,1],[297,5,297,48,1],[298,5,298,49,1],[302,7,302,28,1],[305,29,305,36,1],[305,16,305,25,1],[306,8,306,41,1],[309,8,309,50,1],[312,8,312,46,1],[315,8,315,62,1],[316,8,316,30,1],[317,8,317,26,1],[318,8,318,26,1],[319,8,319,37,1],[321,30,321,36,1],[321,17,321,26,1],[322,9,322,47,1],[324,9,324,28,1],[325,9,325,25,1],[326,9,326,43,1],[327,9,327,27,1],[328,10,328,41,1],[329,10,329,35,1],[332,9,332,54,1],[335,9,335,58,1],[338,10,338,33,1],[339,11,339,54,1],[343,10,343,45,1],[346,9,346,35,1],[347,9,347,32,1],[348,9,348,38,1],[349,9,349,76,1],[321,27,321,29,1],[353,8,353,21,1],[356,8,356,58,1],[357,13,357,23,1],[357,24,357,48,1],[364,8,364,38,1],[367,8,367,92,1],[368,8,368,45,1],[371,8,371,37,1],[374,8,374,46,1],[377,8,377,41,1],[305,26,305,28,1],[381,7,381,27,1],[383,7,383,30,1],[395,26,395,39,1],[395,13,395,22,1],[396,5,396,29,1],[395,23,395,25,1],[398,3,398,4,1]]);
    </script>
  </body>
</html>