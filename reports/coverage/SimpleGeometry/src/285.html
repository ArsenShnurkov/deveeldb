<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql\tableinfo.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text;

using Deveel.Data.Sql.Expressions;
using Deveel.Data.Transactions;
using Deveel.Data.Types;

namespace Deveel.Data.Sql {
	/// &lt;summary&gt;
	/// Defines the metadata properties of a table existing 
	/// within a database.
	/// &lt;/summary&gt;
	/// &lt;remarks&gt;
	/// A table structure implements a unique name within a
	/// database system, and a list columns that shape the
	/// design of the data that the table can accommodate.
	/// &lt;/remarks&gt;
	[Serializable]
	public sealed class TableInfo : IObjectInfo, IEnumerable&lt;ColumnInfo&gt; {
		private readonly IList&lt;ColumnInfo&gt; columns;
		private readonly Dictionary&lt;ObjectName, int&gt; columnsCache;

		/// &lt;summary&gt;
		/// Constructs the object with the given table name.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;tableName&quot;&gt;The unique name of the table within
		/// the database system.&lt;/param&gt;
		/// &lt;param name=&quot;id&quot;&gt;The unique identifier of the table in the database.&lt;/param&gt;
		/// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;
		/// If the provided &lt;paramref name=&quot;tableName&quot;/&gt; is &lt;c&gt;null&lt;/c&gt;.
		/// &lt;/exception&gt;
		public TableInfo(ObjectName tableName)
			: this(tableName, -1, false, new List&lt;ColumnInfo&gt;(), false) {
		}

		private TableInfo(ObjectName tableName, int id, bool perm, IList&lt;ColumnInfo&gt; columns, bool isReadOnly) {
			if (tableName == null) 
				throw new ArgumentNullException(&quot;tableName&quot;);

			TableName = tableName;
			Id = id;
			IsPermanent = perm;
			this.columns = columns;
			IsReadOnly = isReadOnly;

			columnsCache = new Dictionary&lt;ObjectName, int&gt;();
		}

		DbObjectType IObjectInfo.ObjectType {
			get { return DbObjectType.Table; }
		}

		/// &lt;summary&gt;
		/// Gets the fully qualified name of the table that is ensured 
		/// to be unique within the system.
		/// &lt;/summary&gt;
		public ObjectName TableName { get; private set; }

		ObjectName IObjectInfo.FullName {
			get { return TableName; }
		}

		/// &lt;summary&gt;
		/// Gets a unique identifier of the table in a database system.
		/// &lt;/summary&gt;
		/// &lt;seealso cref=&quot;IsPermanent&quot;/&gt;
		public int Id { get; private set; }

		/// &lt;summary&gt;
		/// Gets a value that indicates if the table is permanent.
		/// &lt;/summary&gt;
		/// &lt;seealso cref=&quot;ITransaction.CreateTable&quot;/&gt;
		public bool IsPermanent { get; private set; }

		/// &lt;summary&gt;
		/// Gets the name part of the table name.
		/// &lt;/summary&gt;
		/// &lt;seealso cref=&quot;TableName&quot;/&gt;
		/// &lt;seealso cref=&quot;ObjectName.Name&quot;/&gt;
		public string Name {
			get { return TableName.Name; }
		}

		/// &lt;summary&gt;
		/// Gets the schema name part of the table name.
		/// &lt;/summary&gt;
		/// &lt;seealso cref=&quot;TableName&quot;/&gt;
		/// &lt;seealso cref=&quot;ObjectName.Parent&quot;/&gt;
		public ObjectName SchemaName {
			get { return TableName.Parent; }
		}

		/// &lt;summary&gt;
		/// Gets the name of the catalog containing the table, if defined.
		/// &lt;/summary&gt;
		public string CatalogName {
			get { return SchemaName != null &amp;&amp; SchemaName.Parent != null ? SchemaName.Parent.Name : null; }
		}

		///// &lt;summary&gt;
		///// Gets or sets a boolean value that indicates if the column names
		///// will be resolved in case-insensitive mode.
		///// &lt;/summary&gt;
		///// &lt;remarks&gt;
		///// By default the value of this flag is set to &lt;c&gt;true&lt;/c&gt;.
		///// &lt;/remarks&gt;
		//public bool IgnoreCase { get; set; }

		/// &lt;summary&gt;
		/// Gets a boolean value that indicates if the structure of this
		/// table cannot be altered.
		/// &lt;/summary&gt;
		public bool IsReadOnly { get; private set; }

		/// &lt;summary&gt;
		/// Gets a count of the &lt;see cref=&quot;ColumnInfo&quot;&gt;columns&lt;/see&gt; 
		/// defined by this object.
		/// &lt;/summary&gt;
		public int ColumnCount {
			get { return columns.Count; }
		}

		/// &lt;summary&gt;
		/// Gets the column object defined at the given offset within 
		/// the table.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;offset&quot;&gt;The zero-based offset of the column to return.&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns an object of type &lt;see cref=&quot;ColumnInfo&quot;/&gt; that is
		/// at the given offset within the table.
		/// &lt;/returns&gt;
		/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;
		/// If the given &lt;paramref name=&quot;offset&quot;/&gt; is less than zero or
		/// greater or equal than the number of columns defined in the table.
		/// &lt;/exception&gt;
		public ColumnInfo this[int offset] {
			get {
				if (offset &lt; 0 || offset &gt;= columns.Count)
					throw new ArgumentOutOfRangeException(&quot;offset&quot;);

				return columns[offset];
			}
		}

		private void AssertNotReadOnly() {
			if (IsReadOnly)
				throw new InvalidOperationException();
		}

		public void Establish(int id) {
			Id = id;
			IsPermanent = true;
		}

		internal void AddColumnSafe(ColumnInfo column) {
			if (column == null)
				throw new ArgumentNullException(&quot;column&quot;);

			AssertNotReadOnly();

			columnsCache.Clear();
			column.TableInfo = this;
			columns.Add(column);
		}

		/// &lt;summary&gt;
		/// Adds a new column to the table at the last position of the
		/// columns list in the table metadata.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;column&quot;&gt;The &lt;see cref=&quot;ColumnInfo&quot;/&gt; metadata to
		/// add to the table.&lt;/param&gt;
		/// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;
		/// If the given &lt;paramref name=&quot;column&quot;/&gt; is &lt;c&gt;null&lt;/c&gt;.
		/// &lt;/exception&gt;
		/// &lt;exception cref=&quot;InvalidOperationException&quot;&gt;
		/// If the table is immutable (&lt;see cref=&quot;IsReadOnly&quot;/&gt; is equals to &lt;c&gt;true&lt;/c&gt;)
		/// &lt;/exception&gt;
		/// &lt;exception cref=&quot;ArgumentException&quot;&gt;
		/// If the column is already defined in this table or if it
		/// is attacted to another table.
		/// &lt;/exception&gt;
		public void AddColumn(ColumnInfo column) {
			if (column == null)
				throw new ArgumentNullException(&quot;column&quot;);

			AssertNotReadOnly();

			if (column.TableInfo != null &amp;&amp;
			    column.TableInfo != this)
				throw new ArgumentException(String.Format(&quot;The column {0} belongs to another table already ({1})&quot;, column.ColumnName,
					column.TableInfo.Name));

			if (columns.Any(x =&gt; x.ColumnName == column.ColumnName))
				throw new ArgumentException(String.Format(&quot;Column {0} is already defined in table {1}&quot;, column.ColumnName, TableName));

			columnsCache.Clear();
			column.TableInfo = this;
			columns.Add(column);
		}

		/// &lt;summary&gt;
		/// Adds a new column to the table having the given name and type.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;columnName&quot;&gt;The name of the column to add.&lt;/param&gt;
		/// &lt;param name=&quot;columnType&quot;&gt;The &lt;see cref=&quot;DataType&quot;/&gt; of the column to add.&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns an instance of &lt;see cref=&quot;ColumnInfo&quot;/&gt; that is generated by
		/// the given parameters.
		/// &lt;/returns&gt;
		/// &lt;seealso cref=&quot;AddColumn(string, DataType, bool)&quot;/&gt;
		public ColumnInfo AddColumn(string columnName, DataType columnType) {
			return AddColumn(columnName, columnType, false);
		}

		/// &lt;summary&gt;
		/// Adds a new column to the table having the given name and type.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;columnName&quot;&gt;The name of the column to add.&lt;/param&gt;
		/// &lt;param name=&quot;columnType&quot;&gt;The &lt;see cref=&quot;DataType&quot;/&gt; of the column to add.&lt;/param&gt;
		/// &lt;param name=&quot;notNull&quot;&gt;If the column values must be &lt;c&gt;NOT NULL&lt;/c&gt;.&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns an instance of &lt;see cref=&quot;ColumnInfo&quot;/&gt; that is generated by
		/// the given parameters.
		/// &lt;/returns&gt;
		/// &lt;seealso cref=&quot;AddColumn(string, DataType, bool)&quot;/&gt;
		/// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;
		/// If either &lt;paramref name=&quot;columnName&quot;/&gt; or the &lt;paramref name=&quot;columnType&quot;/&gt;
		/// arguments are &lt;c&gt;null&lt;/c&gt;.
		/// &lt;/exception&gt;
		/// &lt;seealso cref=&quot;AddColumn(ColumnInfo)&quot;/&gt;
		public ColumnInfo AddColumn(string columnName, DataType columnType, bool notNull) {
			if (String.IsNullOrEmpty(columnName))
				throw new ArgumentNullException(&quot;columnName&quot;);

			if (columnType == null)
				throw new ArgumentNullException(&quot;columnType&quot;);

			var column = new ColumnInfo(columnName, columnType);
			column.IsNotNull = notNull;
			AddColumn(column);
			return column;
		}

		/// &lt;inheritdoc/&gt;
		public IEnumerator&lt;ColumnInfo&gt; GetEnumerator() {
			return columns.GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator() {
			return GetEnumerator();
		}

		/// &lt;summary&gt;
		/// Gets the offset of the column with the given name.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;columnName&quot;&gt;The name of the column of which
		/// to get the offset.&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns a zero-based index of a column with the given name,
		/// if defined by the table metadata, or -1 otherwise.
		/// &lt;/returns&gt;
		public int IndexOfColumn(string columnName) {
			return IndexOfColumn(new ObjectName(TableName, columnName));
		}

		public int IndexOfColumn(ObjectName columnName) {
			int index;
			if (!columnsCache.TryGetValue(columnName, out index)) {
				bool found = false;
				for (int i = 0; i &lt; columns.Count; i++) {
					var column = columns[i];
					if (column.ColumnName.Equals(columnName.Name, StringComparison.Ordinal)) {
						index = i;
						columnsCache[columnName] = index;
						found = true;
					}
				}

				if (!found)
					index = -1;
			}

			return index;
		}

		/// &lt;summary&gt;
		/// Creates a new instance of &lt;see cref=&quot;TableInfo&quot;/&gt; as an immutable copy
		/// of this table metadata.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;
		/// Returns a new read-only instance of &lt;see cref=&quot;TableInfo&quot;/&gt; that is
		/// a copy of this table metadata.
		/// &lt;/returns&gt;
		public TableInfo AsReadOnly() {
			return new TableInfo(TableName, Id, IsPermanent, new ReadOnlyCollection&lt;ColumnInfo&gt;(columns), true);
		}

		public TableInfo Alias(ObjectName alias) {
			return new TableInfo(alias, Id, IsPermanent, new ReadOnlyCollection&lt;ColumnInfo&gt;(columns), true);
		}

		internal SqlExpression ResolveColumns(bool ignoreCase, SqlExpression expression) {
			throw new NotImplementedException();
		}

		public IEnumerable&lt;int&gt; IndexOfColumns(IEnumerable&lt;string&gt; columnNames) {
			if (columnNames == null)
				return new int[0];

			return columnNames.Select(IndexOfColumn).ToList().AsReadOnly();
		}

		internal void SerializeTo(Stream stream) {
			var writer = new BinaryWriter(stream, Encoding.Unicode);
			writer.Write(3);	// Version

			var catName = CatalogName;
			if (catName == null)
				catName = String.Empty;

			writer.Write(catName);
			writer.Write(SchemaName.Name);
			writer.Write(Name);

			var colCount = columns.Count;
			writer.Write(colCount);
			for (int i = 0; i &lt; colCount; i++) {
				var column = columns[i];
				column.SerializeTo(stream);
			}
		}

		internal static TableInfo DeserializeFrom(Stream stream, IUserTypeResolver typeResolver) {
			var reader = new BinaryReader(stream, Encoding.Unicode);

			var version = reader.ReadInt32();
			if (version != 3)
				throw new FormatException(&quot;Invalid version of the table info.&quot;);

			var catName = reader.ReadString();
			var schemName = reader.ReadString();
			var tableName = reader.ReadString();

			var objSchemaName = !String.IsNullOrEmpty(catName)
				? new ObjectName(new ObjectName(catName), schemName)
				: new ObjectName(schemName);

			var objTableName = new ObjectName(objSchemaName, tableName);

			var tableInfo = new TableInfo(objTableName);

			var colCount = reader.ReadInt32();
			for (int i = 0; i &lt; colCount; i++) {
				var columnInfo = ColumnInfo.DeserializeFrom(stream, typeResolver);

				if (columnInfo != null)
					tableInfo.AddColumn(columnInfo);
			}

			return tableInfo;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[59,5,59,50,0],[71,10,71,36,0],[81,10,81,27,0],[160,6,160,54,0],[168,5,168,43,0],[178,5,178,47,0],[205,5,205,47,0],[211,5,212,30,0],[215,5,215,124,0],[254,5,254,51,0],[257,5,257,51,0],[271,4,271,27,0],[301,6,301,17,0],[324,4,324,40,0],[329,5,329,23,0],[359,5,359,69,0],[53,3,54,63,1],[55,3,55,4,1],[57,3,57,105,1],[58,4,58,26,1],[61,4,61,26,1],[62,4,62,12,1],[63,4,63,23,1],[64,4,64,27,1],[65,4,65,28,1],[67,4,67,53,1],[68,3,68,4,1],[102,10,102,32,1],[111,10,111,34,1],[118,10,118,97,1],[141,10,141,31,1],[159,5,159,47,1],[162,5,162,28,1],[167,4,167,19,1],[169,3,169,4,1],[172,4,172,12,1],[173,4,173,23,1],[174,3,174,4,1],[177,4,177,23,1],[180,4,180,24,1],[182,4,182,25,1],[183,4,183,28,1],[184,4,184,24,1],[185,3,185,4,1],[204,4,204,23,1],[207,4,207,24,1],[209,4,210,33,1],[214,4,214,25,1],[214,58,214,60,1],[217,4,217,25,1],[218,4,218,28,1],[219,4,219,24,1],[220,3,220,4,1],[233,4,233,52,1],[253,4,253,41,1],[256,4,256,27,1],[259,4,259,56,1],[260,4,260,31,1],[261,4,261,22,1],[262,4,262,18,1],[267,4,267,35,1],[284,4,284,64,1],[289,4,289,57,1],[290,5,290,24,1],[291,10,291,20,1],[292,6,292,30,1],[293,6,293,78,1],[294,7,294,17,1],[295,7,295,40,1],[296,7,296,20,1],[291,40,291,43,1],[291,21,291,38,1],[300,5,300,16,1],[304,4,304,17,1],[316,4,316,104,1],[320,4,320,100,1],[328,4,328,28,1],[331,4,331,67,1],[335,4,335,60,1],[336,4,336,20,1],[338,4,338,30,1],[339,4,339,24,1],[340,5,340,28,1],[342,4,342,26,1],[343,4,343,34,1],[344,4,344,23,1],[346,4,346,33,1],[347,4,347,27,1],[348,9,348,19,1],[349,5,349,29,1],[350,5,350,32,1],[348,34,348,37,1],[348,20,348,32,1],[352,3,352,4,1],[355,4,355,60,1],[357,4,357,37,1],[358,4,358,21,1],[361,4,361,38,1],[362,4,362,40,1],[363,4,363,40,1],[365,4,367,33,1],[369,4,369,64,1],[371,4,371,48,1],[373,4,373,38,1],[374,9,374,19,1],[375,5,375,71,1],[377,5,377,28,1],[378,6,378,38,1],[374,34,374,37,1],[374,20,374,32,1],[381,4,381,21,1],[214,25,214,58,1]]);
    </script>
  </body>
</html>