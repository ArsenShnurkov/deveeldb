<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.routines\functioninfo.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;

using Deveel.Data.DbSystem;
using Deveel.Data.Sql;
using Deveel.Data.Types;

namespace Deveel.Data.Routines {
	/// &lt;summary&gt;
	/// The function signature information that are used to resolve
	/// a function within a context.
	/// &lt;/summary&gt;
	/// &lt;seealso cref=&quot;RoutineInfo&quot;/&gt;
	public sealed class FunctionInfo : RoutineInfo {
		/// &lt;summary&gt;
		/// Constructs a &lt;see cref=&quot;FunctionInfo&quot;/&gt; without arguments.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;routineName&quot;&gt;The name of the function.&lt;/param&gt;
		public FunctionInfo(ObjectName routineName, FunctionType functionType) 
			: this(routineName, (DataType)null, functionType) {
		}

		public FunctionInfo(ObjectName routineName, DataType returnType) 
			: this(routineName, returnType, FunctionType.Static) {
		}

		public FunctionInfo(ObjectName routineName, DataType returnType, FunctionType functionType) 
			: base(routineName) {
			ReturnType = returnType;
			FunctionType = functionType;
			AssertUnboundAtEnd();
		}

		public FunctionInfo(ObjectName routineName, RoutineParameter[] parameters) 
			: this(routineName, parameters, FunctionType.Static) {
		}

		public FunctionInfo(ObjectName routineName, RoutineParameter[] parameters, FunctionType functionType) 
			: this(routineName, parameters, null, functionType) {
		}

		public FunctionInfo(ObjectName routineName, RoutineParameter[] parameters, DataType returnType) 
			: this(routineName, parameters, returnType, FunctionType.Static) {
		}

		public FunctionInfo(ObjectName routineName, RoutineParameter[] parameters, DataType returnType, FunctionType functionType) 
			: base(routineName, parameters) {
			ReturnType = returnType;
			FunctionType = functionType;
			AssertUnboundAtEnd();
		}

		protected override DbObjectType ObjectType {
			get { return DbObjectType.Function; }
		}

		public DataType ReturnType { get; private set; }

		private void AssertUnboundAtEnd() {
			for (int i = 0; i &lt; Parameters.Length; i++) {
				var param = Parameters[i];
				if (param.IsUnbounded) {
					if (HasUnboundParameter)
						throw new ArgumentException(&quot;Cannot specify more than one &#39;unbounded&#39; argument for a function.&quot;);

					if (i != Parameters.Length - 1)
						throw new ArgumentException(&quot;An unbounded parameter must be present only at the end.&quot;);

					HasUnboundParameter = true;
				}
			}
		}

		private bool HasUnboundParameter { get; set; }

		/// &lt;summary&gt;
		/// Gets the kind of function.
		/// &lt;/summary&gt;
		public FunctionType FunctionType { get; private set; }

		internal override bool MatchesInvoke(Invoke request, IQueryContext queryContext) {
			if (request == null)
				return false;

			// TODO: have a patch to check if this must be case-insensitive compare
			// TODO: have the request to respect the [Name1].[Name2].[NameN] format as the routine
			if (!RoutineName.Equals(request.RoutineName))
				return false;

			// TODO: add a better resolution to obtain the final type of the argument
			//       and compare it to the parameter type definition
			bool unboundedSeen = false;
			for (int i = 0; i &lt; request.Arguments.Length; i++) {
				if (i + 1 &gt; Parameters.Length) {
					if (!unboundedSeen)
						return false;

					// TODO: verify the type of the argument (how to evaluate?)

				} else {
					var param = Parameters[i];
					unboundedSeen = param.IsUnbounded;

					// TODO: verify the type of the argument (how to evaluate?)
				}
			}

			if (!unboundedSeen &amp;&amp; request.Arguments.Length != Parameters.Length)
				return false;

			return true;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[34,3,35,53,0],[36,3,36,4,0],[38,3,39,56,0],[40,3,40,4,0],[42,3,43,23,0],[44,4,44,28,0],[45,4,45,32,0],[46,4,46,25,0],[47,3,47,4,0],[57,3,58,68,0],[59,3,59,4,0],[69,10,69,39,0],[78,6,78,30,0],[79,7,79,104,0],[81,6,81,37,0],[82,7,82,94,0],[84,6,84,33,0],[98,5,98,18,0],[103,5,103,18,0],[110,6,110,25,0],[111,7,111,20,0],[124,5,124,18,0],[49,3,50,56,1],[51,3,51,4,1],[53,3,54,55,1],[55,3,55,4,1],[61,3,62,35,1],[63,4,63,28,1],[64,4,64,32,1],[65,4,65,25,1],[66,3,66,4,1],[75,9,75,19,1],[76,5,76,31,1],[77,5,77,27,1],[75,43,75,46,1],[75,20,75,41,1],[87,3,87,4,1],[97,4,97,24,1],[102,4,102,49,1],[107,4,107,31,1],[108,9,108,19,1],[109,5,109,35,1],[116,6,116,32,1],[117,6,117,40,1],[108,50,108,53,1],[108,20,108,48,1],[123,4,123,72,1],[126,4,126,16,1]]);
    </script>
  </body>
</html>