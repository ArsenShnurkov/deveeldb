<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.dbsystem\tablesource.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

using Deveel.Data.Caching;
using Deveel.Data.Index;
using Deveel.Data.Sql;
using Deveel.Data.Sql.Objects;
using Deveel.Data.Store;
using Deveel.Data.Transactions;
using Deveel.Data.Types;

namespace Deveel.Data.DbSystem {
	class TableSource {
		private IndexSetStore indexSetStore;
		private VersionedTableIndexList tableIndices;

		private FixedRecordList recordList;
		private long indexHeaderOffset;
		private long listHeaderOffset;
		private IArea headerArea;
		private long firstDeleteChainRecord;

		private long sequenceId;

		private bool isClosed;
		private int rootLock;

		internal TableSource(TableSourceComposite composite, IStoreSystem storeSystem, IObjectStore objStore, int tableId, string sourceName) {
			if (composite == null)
				throw new ArgumentNullException(&quot;composite&quot;);

			Composite = composite;
			StoreSystem = storeSystem;
			ObjectStore = objStore;
			TableId = tableId;
			SourceName = sourceName;

			GC = new TableSourceGC(this);

			// Generate the name of the store file name.
			StoreIdentity = MakeSourceIdentity(composite.DatabaseContext.SystemContext, tableId, sourceName);
		}

		public TableSourceComposite Composite { get; private set; }

		public IDatabaseContext DatabaseContext {
			get { return Composite.DatabaseContext; }
		}

		public IDatabase Database {
			get { return Composite.Database; }
		}

		public ISystemContext SystemContext {
			get { return DatabaseContext.SystemContext; }
		}

		private IStoreSystem StoreSystem { get; set; }

		public int TableId { get; private set; }

		public ObjectName TableName {
			get { return TableInfo.TableName; }
		}

		public string SourceName { get; private set; }

		public bool IsRootLocked {
			get {
				lock (this) {
					return rootLock &gt; 0;
				}
			}
		}

		public TableInfo TableInfo { get; private set; }

		public int ColumnCount {
			get { return TableInfo.ColumnCount; }
		}

		public int RawRowCount {
			get {
				lock (recordList) {
					long total = recordList.NodeCount;
					// 32-bit row limitation here - we should return a long.
					return (int)total;
				}
			}
		}

		public long CurrentUniqueId {
			get {
				lock (recordList) {
					return sequenceId - 1;
				}
			}
		}

		public bool CanCompact {
			get {
				// TODO: We should perform some analysis on the data to decide if a
				//   compact is necessary or not.
				return true;
			}
		}

		public bool IsReadOnly {
			get { return DatabaseContext.SystemContext.ReadOnly(); }
		}

		public IndexSetInfo IndexSetInfo { get; private set; }

		public bool IsClosed {
			get {
				lock (this) {
					return isClosed;
				}
			}
			protected set {
				lock (this) {
					isClosed = value;
				}
			}
		}

		public bool HasChangesPending {
			get {
				lock (this) {
					return tableIndices.HasChangesPending;
				}
			}
		}

		public string StoreIdentity { get; private set; }

		public IStore Store { get; private set; }

		public IObjectStore ObjectStore { get; private set; }

		public TableSourceGC GC { get; private set; }

		public bool HasShutdown { get; private set; }

		public TableCellCache CellCache {
			get { return DatabaseContext.CellCache; }
		}

		public bool CellCaching {
			get { return CellCache != null; }
		}

		public bool Exists() {
			return StoreSystem.StoreExists(StoreIdentity);
		}

		private void ClearLocks() {
			lock (this) {
				rootLock = 0;
			}
		}

		public void Close(bool dropPending) {
			if (IsClosed)
				return;

			lock (this) {
				// NOTE: This method MUST be synchronized over the table to prevent
				//   establishing a root Lock on this table.  If a root Lock is established
				//   then the collection event could fail.

				lock (recordList) {
					// If we are root locked, we must become un root locked.
					ClearLocks();

					try {
						try {
							Store.LockForWrite();

							// Force a garbage collection event.
							if (!IsReadOnly)
								GC.Collect(true);

							// If we are closing pending a drop, we need to remove all blob
							// references input the table.
							// NOTE: This must only happen after the above collection event.
							if (dropPending) {
								// Scan and remove all blob references for this dropped table.
								ReleaseObjects();
							}
						} finally {
							Store.UnlockForWrite();
						}
					} catch (Exception e) {
						// TODO: Register the error to the logs 
					}

					// Synchronize the store
					indexSetStore.Close();

					// Close the store input the store system.
					StoreSystem.CloseStore(Store);

					TableInfo = null;
					IsClosed = true;
				}
			}
		}

		private void ReleaseObjects() {
			lock (recordList) {
				long elements = recordList.NodeCount;
				for (long rowNumber = 0; rowNumber &lt; elements; ++rowNumber) {
					var a = recordList.GetRecord(rowNumber);
					var status = (RecordState) a.ReadInt4();
					// Is the record not deleted?
					if (status != RecordState.Deleted) {
						// Get the record pointer
						long recordPointer = a.ReadInt8();
						ReleaseRowObjects(recordPointer);
					}
				}
			}
		}

		public bool Drop() {
			throw new NotImplementedException();
		}

		public void Open() {
			bool needsCheck = OpenTable();

			// Create table indices
			tableIndices = new VersionedTableIndexList(this);

			// Load internal state
			LoadInternal();

			if (needsCheck) {
				// Do an opening scan of the table.  Any records that are uncommited
				// must be marked as deleted.
				DoOpeningScan();
			}
		}

		private void DoOpeningScan() {
			lock (this) {
				// ASSERTION: No root locks and no pending transaction changes,
				//   VERY important we assert there&#39;s no pending transactions.
				if (IsRootLocked || HasChangesPending)
					// This shouldn&#39;t happen if we are calling from &#39;open&#39;.
					throw new Exception(&quot;Odd, we are root locked or have pending journal changes.&quot;);

				// This is pointless if we are in Read only mode.
				if (!IsReadOnly) {
					// Get the master index of rows in this table
					var indexSet = CreateIndexSet();
					var masterIndex = indexSet.GetIndex(0);

					// NOTE: We assume the index information is correct and that the
					//   allocation information is potentially bad.

					int rowCount = RawRowCount;
					for (int rowNumber = 0; rowNumber &lt; rowCount; ++rowNumber) {
						// Is this record marked as deleted?
						if (!IsRecordDeleted(rowNumber)) {
							// Get the type flags for this record.
							var type = ReadRecordState(rowNumber);

							// Check if this record is marked as committed removed, or is an
							// uncommitted record.
							if (type == RecordState.CommittedRemoved ||
								type == RecordState.Uncommitted) {
								// Check it&#39;s not in the master index...
								if (!masterIndex.Contains(rowNumber)) {
									// Delete it.
									DoHardRowRemove(rowNumber);
								} else {
									// Mark the row as committed added because it is in the index.
									WriteRecordState(rowNumber, RecordState.CommittedAdded);

								}
							} else {
								// Must be committed added.  Check it&#39;s indexed.
								if (!masterIndex.Contains(rowNumber)) {
									// Not indexed, so data is inconsistant.

									// Mark the row as committed removed because it is not in the
									// index.
									WriteRecordState(rowNumber, RecordState.CommittedRemoved);

								}
							}
						} else {
							// if deleted
							// Check this record isn&#39;t in the master index.
							if (masterIndex.Contains(rowNumber)) {
								// It&#39;s in the master index which is wrong!  We should remake the
								// indices.

								// Mark the row as committed added because it is in the index.
								WriteRecordState(rowNumber, RecordState.CommittedAdded);

							}
						}
					} // for (int i = 0 ; i &lt; row_count; ++i)

					// Dispose the index set
					indexSet.Dispose();
				}

				ScanForLeaks();
			}
		}

		private void ScanForLeaks() {
			lock (recordList) {
				// The list of pointers to areas (as Long).
				var usedAreas = new List&lt;long&gt;();

				usedAreas.Add(headerArea.Id);

				headerArea.Position = 16;
				// Add the DataTableInfo and DataIndexSetInfo objects
				usedAreas.Add(headerArea.ReadInt8());
				usedAreas.Add(headerArea.ReadInt8());

				// Add all the used areas input the list_structure itself.
				recordList.GetAreasUsed(usedAreas);

				// Adds all the user areas input the index store.
				indexSetStore.GetAreasUsed(usedAreas);

				// Search the list structure for all areas
				long elements = recordList.NodeCount;
				for (long i = 0; i &lt; elements; ++i) {
					var area = recordList.GetRecord(i);
					var status = (RecordState) area.ReadInt4();
					if (status != RecordState.Deleted) {
						usedAreas.Add(area.ReadInt8());
					}
				}

				// Following depends on store implementation
				if (Store is StoreBase) {
					var aStore = (StoreBase)Store;
					var leakedAreas = aStore.FindAllocatedAreasNotIn(usedAreas).ToList();
					if (leakedAreas.Count == 0) {
					} else {
						foreach (long areaPointer in leakedAreas) {
							Store.DeleteArea(areaPointer);
						}
					}
				}
			}
		}

		private bool OpenTable() {
			// Open the store.
			Store = StoreSystem.OpenStore(StoreIdentity);
			bool needCheck = !Store.ClosedClean;

			// Setup the list structure
			recordList = new FixedRecordList(Store, 12);

			// Read and setup the pointers
			ReadStoreHeaders();

			return needCheck;
		}

		public IIndexSet CreateIndexSet() {
			return indexSetStore.GetSnapshotIndex();
		}

		public void AddIndex(IndexInfo indexInfo) {
			lock (this) {
				// TODO: are there other checks to be done here?

				IndexSetInfo.AddIndex(indexInfo);
			}
		}

		private void CommitIndexSet(IIndexSet indexSet) {
			indexSetStore.CommitIndexSet(indexSet);
			indexSet.Dispose();
		}

		private void SetTableInfo(TableInfo info) {
			lock (this) {
				// Check table_id isn&#39;t too large.
				if ((TableId &amp; 0x0F0000000) != 0)
					throw new ApplicationException(&quot;&#39;table_id&#39; exceeds maximum possible keys.&quot;);

				info.Establish(TableId);
				TableInfo = info;

				// Create table indices
				tableIndices = new VersionedTableIndexList(this);

				// Setup the DataIndexSetInfo
				SetIndexSetInfo();
			}
		}

		private void SetIndexSetInfo() {
			lock (this) {
				// Create the initial DataIndexSetInfo object.
				IndexSetInfo = new IndexSetInfo(TableInfo.TableName);
				foreach (var colInfo in TableInfo) {
					if (colInfo.IsIndexable) {
						var indexName = String.Format(&quot;IDX_{0}&quot;, colInfo.ColumnName);
						var indexType = colInfo.IndexType;
						if (String.IsNullOrEmpty(indexType))
							indexType = DefaultIndexTypes.InsertSearch;

						IndexSetInfo.AddIndex(new IndexInfo(indexName, indexType, new[] {colInfo.ColumnName}, false));
					}
				}
			}
		}

		private void LoadInternal() {
			lock (this) {
				// Set up the stat keys.
				// TODO: 
				isClosed = false;
			}
		}

		public void Create(TableInfo tableInfo) {
			// Set the data table info object
			SetTableInfo(tableInfo);

			// Load internal state
			LoadInternal();

			// Set up internal state of this object
			//TableId = tableInfo.Id;

			CreateTable();
		}

		private static string MakeSourceIdentity(ISystemContext context, int tableId, string tableName) {
			string str = tableName.Replace(&#39;.&#39;, &#39;_&#39;).ToLower();

			// Go through each character and remove each non a-z,A-Z,0-9,_ character.
			// This ensure there are no strange characters in the file name that the
			// underlying OS may not like.
			StringBuilder osifiedName = new StringBuilder();
			int count = 0;
			for (int i = 0; i &lt; str.Length || count &gt; 64; ++i) {
				char c = str[i];
				if ((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) ||
					(c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) ||
					(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) ||
					c == &#39;_&#39;) {
					osifiedName.Append(c);
					++count;
				}
			}

			return String.Format(&quot;{0}_{1}&quot;, tableId, osifiedName);
		}

		private void CreateTable() {
			// Initially set the table sequence_id to 1
			sequenceId = 1;

			// Create and open the store.
			Store = StoreSystem.CreateStore(StoreIdentity);

			try {
				Store.LockForWrite();

				// Setup the list structure
				recordList = new FixedRecordList(Store, 12);
			} finally {
				Store.UnlockForWrite();
			}

			// Initialize the store to an empty state,
			SetupInitialStore();
			indexSetStore.PrepareIndexLists(TableInfo.ColumnCount + 1, 1, 1024);
		}

		private void SetupInitialStore() {
			byte[] tableInfoBuf;
			using (var stream = new MemoryStream()) {
				var writer = new BinaryWriter(stream, Encoding.Unicode);
				writer.Write(1);
				TableInfo.SerializeTo(stream);

				tableInfoBuf = stream.ToArray();
			}

			byte[] indexSetInfoBuf;
			using (var stream = new MemoryStream()) {
				var writer = new BinaryWriter(stream, Encoding.Unicode);
				writer.Write(1);

				IndexSetInfo.SerialiazeTo(stream);
				
				indexSetInfoBuf = stream.ToArray();
			}

			try {
				Store.LockForWrite();

				// Allocate an 80 byte header
				var headerWriter = Store.CreateArea(80);
				long headerPointer = headerWriter.Id;
				// Allocate space to store the DataTableInfo serialization
				var dataTableDefWriter = Store.CreateArea(tableInfoBuf.Length);
				long tableInfoOffset = dataTableDefWriter.Id;
				// Allocate space to store the DataIndexSetInfo serialization
				var indexSetWriter = Store.CreateArea(indexSetInfoBuf.Length);
				long indexSetInfoPointer = indexSetWriter.Id;

				// Allocate space for the list header
				listHeaderOffset = recordList.Create();
				recordList.WriteDeleteHead(-1);
				firstDeleteChainRecord = -1;

				// Create the index store
				indexSetStore = new IndexSetStore(DatabaseContext, Store);
				indexHeaderOffset = indexSetStore.Create();

				// Write the main header
				headerWriter.WriteInt4(1);                       // Version
				headerWriter.WriteInt4(TableId);                 // table id
				headerWriter.WriteInt8(sequenceId);              // initial sequence id
				headerWriter.WriteInt8(tableInfoOffset);     // pointer to DataTableInfo
				headerWriter.WriteInt8(indexSetInfoPointer);  // pointer to DataIndexSetInfo
				headerWriter.WriteInt8(indexHeaderOffset);      // index header pointer
				headerWriter.WriteInt8(listHeaderOffset);       // list header pointer
				headerWriter.Flush();

				// Write the table info
				dataTableDefWriter.Write(tableInfoBuf, 0, tableInfoBuf.Length);
				dataTableDefWriter.Flush();

				// Write the index set info
				indexSetWriter.Write(indexSetInfoBuf, 0, indexSetInfoBuf.Length);
				indexSetWriter.Flush();

				// Set the pointer to the header input the reserved area.
				var fixedArea = Store.GetArea(-1);
				fixedArea.WriteInt8(headerPointer);
				fixedArea.Flush();

				// Set the header area
				headerArea = Store.GetArea(headerPointer);
			} finally {
				Store.UnlockForWrite();
			}
		}

		private void ReadStoreHeaders() {
			// Read the fixed header
			var fixedArea = Store.GetArea(-1);

			// Set the header area
			headerArea = Store.GetArea(fixedArea.ReadInt8());

			// Open a stream to the header
			var version = headerArea.ReadInt4();              // version
			if (version != 1)
				throw new IOException(&quot;Incorrect version identifier.&quot;);

			TableId = headerArea.ReadInt4();                  // table_id
			sequenceId = headerArea.ReadInt8();               // sequence id
			long infoPointer = headerArea.ReadInt8();         // pointer to DataTableInfo
			long indexInfoPointer = headerArea.ReadInt8();    // pointer to DataIndexSetInfo
			indexHeaderOffset = headerArea.ReadInt8();       // pointer to index header
			listHeaderOffset = headerArea.ReadInt8();        // pointer to list header

			// Read the table info
			using (var stream = Store.GetAreaInputStream(infoPointer)) {
				var reader = new BinaryReader(stream, Encoding.Unicode);
				version = reader.ReadInt32();
				if (version != 1)
					throw new IOException(&quot;Incorrect TableInfo version identifier.&quot;);

				var userTypeResolver = new UserTypeResolver(Database);
				TableInfo = TableInfo.DeserializeFrom(stream, userTypeResolver);
				TableInfo.Establish(TableId);
			}

			// Read the data index set info
			using (var stream = Store.GetAreaInputStream(indexInfoPointer)) {
				var reader = new BinaryReader(stream, Encoding.Unicode);
				version = reader.ReadInt32();
				if (version != 1)
					throw new IOException(&quot;Incorrect IndexSetInfo version identifier.&quot;);

				IndexSetInfo = Sql.IndexSetInfo.DeserializeFrom(stream);
			}

			// Read the list header
			recordList.Open(listHeaderOffset);
			firstDeleteChainRecord = recordList.ReadDeleteHead();

			// Init the index store
			indexSetStore = new IndexSetStore(DatabaseContext, Store);
			try {
				indexSetStore.Open(indexHeaderOffset);
			} catch (IOException) {
				// If this failed try writing output a new empty index set.
				// ISSUE: Should this occur here?  This is really an attempt at repairing
				//   the index store.
				indexSetStore = new IndexSetStore(DatabaseContext, Store);
				indexHeaderOffset = indexSetStore.Create();
				indexSetStore.PrepareIndexLists(TableInfo.ColumnCount + 1, 1, 1024);
				headerArea.Position = 32;
				headerArea.WriteInt8(indexHeaderOffset);
				headerArea.Position = 0;
				headerArea.Flush();
			}
		}

		public long GetNextUniqueId() {
			lock (recordList) {
				long v = sequenceId;
				++sequenceId;
				if (HasShutdown)
					throw new Exception(&quot;IO operation while shutting down.&quot;);

				try {
					try {
						Store.LockForWrite();
						headerArea.Position = 4 + 4;
						headerArea.WriteInt8(sequenceId);
						headerArea.Flush();
					} finally {
						Store.UnlockForWrite();
					}
				} catch (IOException e) {
					throw new ApplicationException(&quot;IO Error: &quot; + e.Message);
				}

				return v;
			}
		}

		public void SetUniqueId(long value) {
			lock (recordList) {
				sequenceId = value;
				if (HasShutdown)
					throw new Exception(&quot;IO operation while shutting down.&quot;);

				try {
					try {
						Store.LockForWrite();
						headerArea.Position = 4 + 4;
						headerArea.WriteInt8(sequenceId);
						headerArea.Flush();
					} finally {
						Store.UnlockForWrite();
					}
				} catch (IOException e) {
					throw new ApplicationException(&quot;IO Error: &quot; + e.Message, e);
				}
			}
		}

		public IMutableTable CreateTableAtCommit(ITransaction transaction) {
			return CreateTableAtCommit(transaction, new TableEventRegistry(this));
		}

		public IMutableTable CreateTableAtCommit(ITransaction transaction, TableEventRegistry registry) {
			return new TransactionTable(transaction, this, registry);
		}

		internal void CommitTransactionChange(int commitId, TableEventRegistry change, IIndexSet indexSet) {
			lock (this) {
				// ASSERT: Can&#39;t do this if source is Read only.
				if (IsReadOnly)
					throw new ApplicationException(&quot;Can&#39;t commit transaction journal, table is Read only.&quot;);

				change.CommitId = commitId;

				try {
					// Add this registry to the multi version table indices log
					tableIndices.AddRegistry(change);

					// Write the modified index set to the index store
					// (Updates the index file)
					CommitIndexSet(indexSet);

					// Update the state of the committed added data to the file system.
					// (Updates data to the allocation file)
					//
					// ISSUE: This can add up to a lot of changes to the allocation file and
					//   the runtime could potentially be terminated in the middle of
					//   the update.  If an interruption happens the allocation information
					//   may be incorrectly flagged.  The type of corruption this would
					//   result in would be;
					//   + From an &#39;update&#39; the updated record may disappear.
					//   + From a &#39;delete&#39; the deleted record may not delete.
					//   + From an &#39;insert&#39; the inserted record may not insert.
					//
					// Note, the possibility of this type of corruption occuring has been
					// minimized as best as possible given the current architecture.
					// Also note that is not possible for a table file to become corrupted
					// beyond recovery from this issue.

					foreach (var entry in change) {
						if (entry is TableRowEvent) {
							var rowEvent = (TableRowEvent) entry;
							var rowIndex = rowEvent.RowNumber;

							if (rowEvent.EventType == TableRowEventType.Add) {
								// Record commit added
								var oldType = WriteRecordState(rowIndex, RecordState.CommittedAdded);

								// Check the record was in an uncommitted state before we changed
								// it.
								if (oldType != RecordState.Uncommitted) {
									WriteRecordState(rowIndex, oldType);
									throw new ApplicationException(String.Format(&quot;Record {0} of table {1} was not in an uncommitted state!&quot;,
										rowIndex, TableName));
								}
							} else if (rowEvent.EventType == TableRowEventType.Remove) {
								// Record commit removed
								var oldType = WriteRecordState(rowIndex, RecordState.CommittedRemoved);

								// Check the record was in an added state before we removed it.
								if (oldType != RecordState.CommittedAdded) {
									WriteRecordState(rowIndex, oldType);
									throw new ApplicationException(String.Format(&quot;Record {0} of table {1} was not in an added state!&quot;, rowIndex,
										TableName));
								}

								// Notify collector that this row has been marked as deleted.
								GC.DeleteRow(rowIndex);
							}
						}
					}
				} catch (IOException e) {
					throw new ApplicationException(&quot;IO Error: &quot; + e.Message, e);
				}

			}
		}

		public RecordState WriteRecordState(int rowNumber, RecordState state) {
			lock (recordList) {
				if (HasShutdown)
					throw new IOException(&quot;IO operation while shutting down.&quot;);

				// Find the record entry input the block list.
				var blockArea = recordList.GetRecord(rowNumber);
				int pos = blockArea.Position;
				// Get the status.
				var oldStatus = (RecordState) blockArea.ReadInt4();

				// Write the new status
				try {
					Store.LockForWrite();

					blockArea.Position = pos;
					blockArea.WriteInt4((int)state);
					blockArea.Flush();
				} finally {
					Store.UnlockForWrite();
				}

				return oldStatus;
			}
		}

		public RecordState ReadRecordState(int rowNumber) {
			lock (recordList) {
				// Find the record entry input the block list.
				var blockArea = recordList.GetRecord(rowNumber);
				// Get the status.
				return (RecordState) blockArea.ReadInt4();
			}
		}

		public bool IsRecordDeleted(int rowNumber) {
			var state = ReadRecordState(rowNumber);
			return state == RecordState.Deleted;
		}

		private void DoHardRowRemove(int rowNumber) {
			lock (this) {
				// Internally delete the row,
				OnDeleteRow(rowNumber);

				// Update stats
				//TODO:
			}
		}

		internal void HardRemoveRow(int rowIndex) {
			lock (this) {
				// ASSERTION: We are not under a root Lock.
				if (IsRootLocked)
					throw new ApplicationException(&quot;Cannot remove row, table is locked&quot;);

				var typeKey = ReadRecordState(rowIndex);
				// Check this record is marked as committed removed.
				if (typeKey != RecordState.CommittedRemoved)
					throw new ApplicationException(String.Format(&quot;The row {0} is not marked as committed removed&quot;, rowIndex));

				DoHardRowRemove(rowIndex);
			}
		}

		internal bool HardCheckAndReclaimRow(int recordIndex) {
			lock (this) {
				// ASSERTION: We are not under a root Lock.
				if (IsRootLocked)
					throw new ApplicationException(&quot;Assertion failed: Can&#39;t remove row, table is under a root Lock.&quot;);

				// Row already deleted?
				if (IsRecordDeleted(recordIndex))
					return false;

				var typeKey = ReadRecordState(recordIndex);

				// Check this record is marked as committed removed.
				if (typeKey != RecordState.CommittedRemoved)
					return false;

				DoHardRowRemove(recordIndex);
				return true;
			}
		}

		private void OnDeleteRow(int rowIndex) {
			lock (recordList) {
				if (HasShutdown)
					throw new IOException(&quot;IO operation while VM shutting down.&quot;);

				// Find the record entry input the block list.
				var blockArea = recordList.GetRecord(rowIndex);
				int p = blockArea.Position;
				var status = (RecordState) blockArea.ReadInt4();

				// Check it is not already deleted
				if (status == RecordState.Deleted)
					throw new IOException(&quot;Record is already marked as deleted.&quot;);

				long recordPointer = blockArea.ReadInt8();

				// Update the status record.
				try {
					Store.LockForWrite();

					blockArea.Position = p;
					blockArea.WriteInt4((int)RecordState.Deleted);
					blockArea.WriteInt8(firstDeleteChainRecord);
					blockArea.Flush();
					firstDeleteChainRecord = rowIndex;

					// Update the first_delete_chain_record field input the header
					recordList.WriteDeleteHead(firstDeleteChainRecord);

					// If the record contains any references to blobs, remove the reference
					// here.
					ReleaseRowObjects(recordPointer);

					// Free the record from the store
					Store.DeleteArea(recordPointer);
				} finally {
					Store.UnlockForWrite();
				}
			}
		}

		private void ReleaseRowObjects(long recordPointer) {
			// NOTE: Does this need to be optimized?
			IArea recordArea = Store.GetArea(recordPointer);
			recordArea.ReadInt4();  // reserved

			// Look for any blob references input the row
			for (int i = 0; i &lt; ColumnCount; ++i) {
				int ctype = recordArea.ReadInt4();
				int cellOffset = recordArea.ReadInt4();

				if (ctype == 1) {
					// Type 1 is not a large object
				} else if (ctype == 2) {
					int curP = recordArea.Position;
					recordArea.Position = cellOffset + 4 + (ColumnCount * 8);

					int btype = recordArea.ReadInt4();
					recordArea.ReadInt4();    // (reserved)

					if (btype == 0) {
						long blobRefId = recordArea.ReadInt8();

						// Release this reference
						ObjectStore.ReleaseObject(blobRefId);
					}

					// Revert the area pointer
					recordArea.Position = curP;
				} else {
					throw new Exception(&quot;Unrecognised type.&quot;);
				}
			}
		}

		public int AddRow(Row row) {
			int rowNumber;

			lock (this) {
				rowNumber = OnAddRow(row);

			} // lock

			// Update stats
			// TODO:

			// Return the record index of the new data in the table
			return rowNumber;
		}


		private long AddToRecordList(long recordPointer) {
			lock (recordList) {
				if (HasShutdown)
					throw new IOException(&quot;IO operation while shutting down.&quot;);

				// If there are no free deleted records input the delete chain,
				if (firstDeleteChainRecord == -1)
					// Grow the fixed structure to allow more nodes,
					GrowRecordList();

				// Pull free block from the delete chain and recycle it.
				long recycledRecord = firstDeleteChainRecord;
				var block = recordList.GetRecord(recycledRecord);
				int recPos = block.Position;

				// Status of the recycled block
				var status = (RecordState) block.ReadInt4();
				if (status != RecordState.Deleted)
					throw new ApplicationException(String.Format(&quot;Record {0} is not deleted. ({1})&quot;, recPos, status));

				// The pointer to the next input the chain.
				long nextChain = block.ReadInt8();
				firstDeleteChainRecord = nextChain;

				try {
					Store.LockForWrite();

					// Update the first_delete_chain_record field input the header
					recordList.WriteDeleteHead(firstDeleteChainRecord);

					// Update the block
					block.Position = recPos;
					block.WriteInt4((int)RecordState.Uncommitted);
					block.WriteInt8(recordPointer);
					block.Flush();
				} finally {
					Store.UnlockForWrite();
				}

				return recycledRecord;
			}
		}

		private void GrowRecordList() {
			try {
				Store.LockForWrite();

				// Increase the size of the list structure.
				recordList.IncreaseSize();

				// The start record of the new size
				int newBlockNumber = recordList.BlockCount - 1;
				long startIndex = recordList.BlockFirstPosition(newBlockNumber);
				long sizeOfBlock = recordList.BlockNodeCount(newBlockNumber);

				// The IArea object for the new position
				var a = recordList.GetRecord(startIndex);

				// Set the rest of the block as deleted records
				for (long n = 0; n &lt; sizeOfBlock - 1; ++n) {
					a.WriteInt4((int)RecordState.Deleted);
					a.WriteInt8(startIndex + n + 1);
				}

				// The last block is end of delete chain.
				a.WriteInt4((int)RecordState.Deleted);
				a.WriteInt8(firstDeleteChainRecord);
				a.Flush();

				// And set the new delete chain
				firstDeleteChainRecord = startIndex;

				// Set the reserved area
				recordList.WriteDeleteHead(firstDeleteChainRecord);
			} finally {
				Store.UnlockForWrite();
			}
		}

		private int OnAddRow(Row row) {
			long rowNumber;
			int intRowNumber;

			// Write the record to the store.
			lock (recordList) {
				long recordPointer = WriteRecord(row);

				// Now add this record into the record block list,
				rowNumber = AddToRecordList(recordPointer);
				intRowNumber = (int)rowNumber;
			}

			// Update the cell cache as appropriate
			if (CellCaching) {
				int rowCells = row.ColumnCount;
				for (int i = 0; i &lt; rowCells; ++i) {
					// Put the row/column/TObject into the cache.
					CellCache.Set(TableId, intRowNumber, i, row.GetValue(i));
				}
			}

			// Return the record index of the new data input the table
			// NOTE: We are casting this from a long to int which means we are limited
			//   to ~2 billion record references.
			return (int)rowNumber;
		}

		private long WriteRecord(Row data) {
			// Calculate how much space this record will use
			int rowCells = data.ColumnCount;

			int[] cellSizes = new int[rowCells];
			int[] cellTypes = new int[rowCells];

			try {
				Store.LockForWrite();

				// Establish a reference to any blobs input the record
				int allRecordsSize = 0;
				for (int i = 0; i &lt; rowCells; ++i) {
					var cell = data.GetValue(i);
					int cellSize;
					int cellType;

					if (cell.Value is IObjectRef) {
						var largeObjectRef = (IObjectRef)cell.Value;

						cellSize = 16;
						cellType = 2;
						if (largeObjectRef != null) {
							// Tell the blob store interface that we&#39;ve made a static reference
							// to this blob.
							ObjectStore.EstablishObject(largeObjectRef.ObjectId.Id);
						}
					} else {
						cellSize = cell.Size;
						cellType = 1;
					}

					cellSizes[i] = cellSize;
					cellTypes[i] = cellType;
					allRecordsSize += cellSize;
				}

				// Allocate space for the record,
				var area = Store.CreateArea(allRecordsSize + (rowCells * 8) + 4);
				long recordPointer = area.Id;

				// The record output stream
				using (var areaStream = new AreaStream(area)) {
					var writer = new BinaryWriter(areaStream);

					// Write the record header first,
					writer.Write(0);        // reserved for future use
					int cellSkip = 0;
					for (int i = 0; i &lt; rowCells; ++i) {
						writer.Write(cellTypes[i]);
						writer.Write(cellSkip);
						cellSkip += cellSizes[i];
					}

					// Now Write a serialization of the cells themselves,
					for (int i = 0; i &lt; rowCells; ++i) {
						var obj = data.GetValue(i);
						int cellType = cellTypes[i];
						if (cellType == 1) {
							// Regular object
							obj.SerializeTo(areaStream, SystemContext);
						} else if (cellType == 2) {
							// This is a binary large object and must be represented as a ref
							// to a blob input the BlobStore.
							var largeObjectRef = (IObjectRef)obj.Value;
							if (largeObjectRef == null) {
								// null value
								writer.Write(1);
								writer.Write(0);                  // Reserved for future use
								writer.Write(-1L);
							} else {
								writer.Write(0);
								writer.Write(0);                  // Reserved for future use
								writer.Write(largeObjectRef.ObjectId.Id);
							}
						} else {
							throw new IOException(&quot;Unrecognised cell type.&quot;);
						}
					}

					// Flush the output
					writer.Flush();
				}

				// Finish the record
				area.Flush();

				// Return the record
				return recordPointer;
			} finally {
				Store.UnlockForWrite();
			}
		}

		public void BuildIndexes() {
			lock (this) {
				var indexSet = CreateIndexSet();

				var indexSetInfo = IndexSetInfo;

				int rowCount = RawRowCount;

				// Master index is always on index position 0
				IIndex masterIndex = indexSet.GetIndex(0);

				// First, update the master index
				for (int rowIndex = 0; rowIndex &lt; rowCount; ++rowIndex) {
					// If this row isn&#39;t deleted, set the index information for it,
					if (!IsRecordDeleted(rowIndex)) {
						// First add to master inde
						if (!masterIndex.UniqueInsertSort(rowIndex))
							throw new Exception(&quot;Master index entry was duplicated.&quot;);
					}
				}

				// Commit the master index
				CommitIndexSet(indexSet);

				// Now go ahead and build each index in this table
				int indexCount = indexSetInfo.IndexCount;
				for (int i = 0; i &lt; indexCount; ++i) {
					BuildIndex(i);
				}
			}
		}

		private void BuildIndex(int indexNumber) {
			lock (this) {
				var indexSet = CreateIndexSet();

				// Master index is always on index position 0
				var masterIndex = indexSet.GetIndex(0);

				// A minimal ITable for constructing the indexes
				var minTable = new MinimalTable(this, masterIndex);

				// Set up schemes for the index,
				var index = CreateColumnIndex(indexSet, minTable, indexNumber);

				// Rebuild the entire index
				int rowCount = RawRowCount;
				for (int rowIndex = 0; rowIndex &lt; rowCount; ++rowIndex) {
					// If this row isn&#39;t deleted, set the index information for it,
					if (!IsRecordDeleted(rowIndex))
						index.Insert(rowIndex);
				}

				// Commit the index
				CommitIndexSet(indexSet);
			}
		}

		internal ColumnIndex CreateColumnIndex(IIndexSet indexSet, ITable table, int columnOffset) {
			lock (this) {
				var column = TableInfo[columnOffset];
				if (!column.IsIndexable ||
				    (String.IsNullOrEmpty(column.IndexType) ||
				     column.IndexType.Equals(DefaultIndexTypes.BlindSearch)))
					return new BlindSearchIndex(table, columnOffset);

				var indexI = IndexSetInfo.FindIndexForColumns(new[] {column.ColumnName});
				return CreateIndexAt(indexSet, table, indexI);
			}
		}

		private ColumnIndex CreateIndexAt(IIndexSet indexSet, ITable table, int indexI) {
			lock (this) {
				try {
					// Get the IndexDef object
					var indexInfo = IndexSetInfo.GetIndex(indexI);

					if (indexInfo == null)
						return null;

					if (indexInfo.IndexType.Equals(DefaultIndexTypes.InsertSearch)) {
						string[] cols = indexInfo.ColumnNames;
						var tableInfo = TableInfo;
						if (cols.Length != 1)
							throw new Exception(&quot;Multi-column indexes not supported at this time.&quot;);

						// If a single column
						var colIndex = tableInfo.IndexOfColumn(cols[0]);

						// Get the index from the index set and set up the new InsertSearch
						// scheme.
						var indexList = indexSet.GetIndex(indexInfo.Offset);
						return new InsertSearchIndex(table, colIndex, indexList);
					}

					// TODO: load the type from the system
					throw new Exception(&quot;Unrecognized index type.&quot;);
				} catch (Exception ex) {
					throw new InvalidOperationException(String.Format(&quot;An error occurred while creating a colummn for table {0}&quot;, TableName), ex);
				}
			}
		}

		public void CopyFrom(int tableId, TableSource destSource, IIndexSet indexSet) {
			throw new NotImplementedException();
		}

		public void AddLock() {
			lock (this) {
				// TODO: Emit the stat to the system
				++rootLock;
			}
		}

		public void RemoveLock() {
			lock (this) {
				if (!isClosed) {
					// TODO: Emit the event to the system

					if (rootLock == 0)
						throw new ApplicationException(&quot;Too many root locks removed!&quot;);

					--rootLock;

					// If the last Lock is removed, schedule a possible collection.
					if (rootLock == 0)
						CheckForCleanup();
				}
			}
		}

		private void CheckForCleanup() {
			lock (this) {
				GC.Collect(false);
			}
		}

		public DataObject GetValue(int rowIndex, int columnOffset) {
			// NOTES:
			// This is called *A LOT*.  It&#39;s a key part of the 20% of the program
			// that&#39;s run 80% of the time.
			// This performs very nicely for rows that are completely contained within
			// 1 sector.  However, rows that contain large cells (eg. a large binary
			// or a large string) and spans many sectors will not be utilizing memory
			// as well as it could.
			// The reason is because all the data for a row is Read from the store even
			// if only 1 cell of the column is requested.  This will have a big
			// impact on column scans and searches.  The cell cache takes some of this
			// performance bottleneck away.
			// However, a better implementation of this method is made difficult by
			// the fact that sector spans can be compressed.  We should perhaps
			// revise the low level data storage so only sectors can be compressed.

			// First check if this is within the cache before we continue.
			DataObject cell;
			if (CellCaching) {
				cell = CellCache.Get(TableId, rowIndex, columnOffset);
				if (cell != null)
					return cell;
			}

			// We maintain a cache of byte[] arrays that contain the rows Read input
			// from the file.  If consequtive reads are made to the same row, then
			// this will cause lots of fast cache hits.

			long recordPointer = -1;
			try {
				lock (recordList) {
					// Increment the file hits counter
					//TODO:
					//++sRunFileHits;

					//if (sRunFileHits &gt;= 100) {
					//	// TODO: Register the stats
					//	sRunFileHits = 0;
					//}

					// Get the node for the record
					var listBlock = recordList.GetRecord(rowIndex);
					var status = (RecordState) listBlock.ReadInt4();
					// Check it&#39;s not deleted
					if (status == RecordState.Deleted)
						throw new ApplicationException(String.Format(&quot;Record {0} was deleted: unable to read.&quot;, rowIndex));

					// Get the pointer to the record we are reading
					recordPointer = listBlock.ReadInt8();
				}

				// Open a stream to the record
				using (var stream = Store.GetAreaInputStream(recordPointer)) {
					var reader = new BinaryReader(stream);

					stream.Seek(4 + (columnOffset * 8), SeekOrigin.Current);

					int cellType = reader.ReadInt32();
					int cellOffset = reader.ReadInt32();

					int curAt = 8 + 4 + (columnOffset * 8);
					int beAt = 4 + (ColumnCount * 8);
					int skipAmount = (beAt - curAt) + cellOffset;

					stream.Seek(skipAmount, SeekOrigin.Current);

					// Get the TType for this column
					// NOTE: It&#39;s possible this call may need optimizing?
					var type = TableInfo[columnOffset].ColumnType;

					ISqlObject ob;
					if (cellType == 1) {
						// If standard object type
						ob = type.DeserializeObject(stream, SystemContext);
					} else if (cellType == 2) {
						// If reference to a blob input the BlobStore
						int fType = reader.ReadInt32();
						int fReserved = reader.ReadInt32();
						long refId = reader.ReadInt64();

						if (fType == 0) {
							// Resolve the reference
							var objRef = ObjectStore.GetObject(refId);
							ob = type.CreateFromLargeObject(objRef);
						} else if (fType == 1) {
							ob = null;
						} else {
							throw new Exception(&quot;Unknown blob type.&quot;);
						}
					} else {
						throw new Exception(&quot;Unrecognised cell type input data.&quot;);
					}

					// Wrap it around a TObject
					cell = new DataObject(type, ob);

					// And close the reader.
					reader.Close();
				}
			} catch (IOException e) {
				throw new Exception(String.Format(&quot;Error getting cell at ({0}, {1}) pointer = &quot; + recordPointer + &quot;.&quot;, rowIndex,
					columnOffset), e);
			}

			// And WriteByte input the cache and return it.
			if (CellCaching) {
				CellCache.Set(TableId, rowIndex, columnOffset, cell);
			}

			return cell;
		}

		#region MinimalTable

		class MinimalTable : ITable {
			private readonly TableSource source;
			private readonly IIndex masterIndex;

			public MinimalTable(TableSource source, IIndex masterIndex) {
				this.source = source;
				this.masterIndex = masterIndex;
			}

			ObjectName IDbObject.FullName {
				get { return TableInfo.TableName; }
			}

			DbObjectType IDbObject.ObjectType {
				get { return DbObjectType.Table; }
			}

			public IEnumerator&lt;Row&gt; GetEnumerator() {
				// NOTE: Returns iterator across master index before journal entry
				//   changes.
				var iterator = masterIndex.GetEnumerator();
				// Wrap it around a IRowEnumerator object.
				return new RowEnumerator(this, iterator);
			}

			private class RowEnumerator : IEnumerator&lt;Row&gt; {
				private MinimalTable table;
				private IIndexEnumerator&lt;int&gt; enumerator;

				public RowEnumerator(MinimalTable table, IIndexEnumerator&lt;int&gt; enumerator) {
					this.table = table;
					this.enumerator = enumerator;
				}

				public void Dispose() {
					table = null;
					enumerator = null;
				}

				public bool MoveNext() {
					return enumerator.MoveNext();
				}

				public void Reset() {
					enumerator.Reset();
				}

				public Row Current {
					get { return new Row(table, enumerator.Current); }
				}

				object IEnumerator.Current {
					get { return Current; }
				}
			}

			IEnumerator IEnumerable.GetEnumerator() {
				return GetEnumerator();
			}

			public void Dispose() {
				
			}

			public IDatabaseContext DatabaseContext {
				get { return source.DatabaseContext; }
			}

			public TableInfo TableInfo {
				get { return source.TableInfo; }
			}

			public int RowCount {
				get {
					// NOTE: Returns the number of rows in the master index before journal
					//   entries have been made.
					return masterIndex.Count;
				}
			}

			public DataObject GetValue(long rowNumber, int columnOffset) {
				return source.GetValue((int)rowNumber, columnOffset);
			}

			public ColumnIndex GetIndex(int columnOffset) {
				throw new NotImplementedException();
			}
		}

		#endregion

		public IEnumerable&lt;TableEventRegistry&gt; FindChangesSinceCmmit(long commitId) {
			lock (this) {
				return tableIndices.FindSinceCommit(commitId);
			}
		}

		public void RollbackTransactionChange(TableEventRegistry registry) {
			lock (this) {
				// ASSERT: Can&#39;t do this is source is Read only.
				if (IsReadOnly)
					throw new ApplicationException(&quot;Can&#39;t rollback transaction journal, table is Read only.&quot;);

				// Any rows added in the journal are marked as committed deleted and the
				// journal is then discarded.

				try {
					// Mark all rows in the data_store as appropriate to the changes.
					foreach (var tableEvent in registry) {
						if (tableEvent is TableRowEvent) {
							var rowEvent = (TableRowEvent) tableEvent;
							if (rowEvent.EventType == TableRowEventType.Add) {
								var oldState = WriteRecordState(rowEvent.RowNumber, RecordState.CommittedRemoved);
								if (oldState != RecordState.Uncommitted) {
									WriteRecordState(rowEvent.RowNumber, oldState);
									throw new InvalidOperationException(String.Format(&quot;Record {0} was not in an uncommitted state.&quot;,
										rowEvent.RowNumber));
								}

								GC.DeleteRow(rowEvent.RowNumber);
							}
						}
					}
				} catch (IOException e) {
					throw new ApplicationException(&quot;IO Error: &quot; + e.Message, e);
				}
			}
		}

		public void MergeChanges(long commitId) {
			lock (this) {
				bool allMerged = tableIndices.MergeChanges(commitId);
				// If all journal entries merged then schedule deleted row collection.
				if (allMerged &amp;&amp; !IsReadOnly) {
					CheckForCleanup();
				}
			}
		}

		#region UserTypeResolver

		class UserTypeResolver : IUserTypeResolver {
			private readonly IDatabase database;

			public UserTypeResolver(IDatabase database) {
				this.database = database;
			}

			public UserType ResolveType(ObjectName typeName) {
				using (var session = database.CreateSystemSession()) {
					return session.GetUserType(typeName);
				}
			}
		}

		#endregion
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[50,5,50,50,0],[104,5,104,22,0],[105,6,105,40,0],[107,6,107,24,0],[109,4,109,5,0],[114,5,114,22,0],[115,6,115,28,0],[117,4,117,5,0],[124,5,124,17,0],[185,5,185,12,0],[214,8,214,27,0],[234,6,234,46,0],[235,6,235,46,0],[237,6,237,40,0],[239,7,239,41,0],[240,7,240,40,0],[233,52,233,63,0],[247,4,247,40,0],[262,5,262,21,0],[267,4,267,15,0],[270,5,270,43,0],[272,6,272,86,0],[275,5,275,21,0],[277,6,277,38,0],[278,6,278,45,0],[283,6,283,33,0],[284,11,284,29,0],[286,7,286,39,0],[288,8,288,46,0],[292,8,293,41,0],[295,9,295,46,0],[297,10,297,37,0],[300,10,300,66,0],[305,9,305,46,0],[310,10,310,68,0],[317,8,317,44,0],[322,9,322,65,0],[284,52,284,63,0],[284,30,284,50,0],[329,6,329,25,0],[332,5,332,20,0],[334,3,334,4,0],[337,4,337,21,0],[339,5,339,38,0],[341,5,341,34,0],[343,5,343,30,0],[345,5,345,42,0],[346,5,346,42,0],[349,5,349,40,0],[352,5,352,43,0],[355,5,355,42,0],[356,10,356,21,0],[357,6,357,41,0],[358,6,358,49,0],[359,6,359,40,0],[360,7,360,38,0],[356,36,356,39,0],[356,22,356,34,0],[365,5,365,28,0],[366,6,366,36,0],[367,6,367,75,0],[368,6,368,33,0],[370,36,370,47,0],[370,16,370,32,0],[371,8,371,38,0],[370,33,370,35,0],[376,3,376,4,0],[397,4,397,15,0],[400,5,400,38,0],[402,3,402,4,0],[413,6,413,82,0],[589,5,589,60,0],[603,6,603,71,0],[615,6,615,74,0],[628,6,628,25,0],[632,5,632,63,0],[633,5,633,48,0],[634,5,634,73,0],[635,5,635,30,0],[636,5,636,45,0],[637,5,637,29,0],[638,5,638,24,0],[647,6,647,63,0],[658,7,658,28,0],[659,6,659,63,0],[667,4,667,21,0],[668,5,668,24,0],[669,5,669,21,0],[670,6,670,63,0],[674,7,674,28,0],[675,7,675,35,0],[676,7,676,40,0],[677,7,677,26,0],[679,7,679,30,0],[681,7,681,28,0],[682,6,682,66,0],[685,3,685,4,0],[699,6,699,94,0],[740,10,740,46,0],[741,10,742,33,0],[744,15,744,66,0],[746,9,746,80,0],[749,9,749,51,0],[750,10,750,46,0],[751,10,752,23,0],[756,9,756,32,0],[760,7,760,28,0],[761,6,761,66,0],[770,6,770,65,0],[794,4,794,21,0],[796,5,796,53,0],[798,5,798,47,0],[800,3,800,4,0],[803,4,803,43,0],[804,4,804,40,0],[808,4,808,15,0],[810,5,810,28,0],[815,3,815,4,0],[818,4,818,15,0],[820,5,820,22,0],[821,6,821,75,0],[823,5,823,45,0],[825,5,825,49,0],[826,6,826,112,0],[828,5,828,31,0],[830,3,830,4,0],[833,4,833,15,0],[835,5,835,22,0],[836,6,836,104,0],[839,5,839,38,0],[840,6,840,19,0],[842,5,842,48,0],[845,5,845,49,0],[846,6,846,19,0],[848,5,848,34,0],[849,5,849,17,0],[851,3,851,4,0],[854,4,854,21,0],[855,5,855,21,0],[856,6,856,68,0],[859,5,859,52,0],[860,5,860,32,0],[861,5,861,53,0],[864,5,864,39,0],[865,6,865,68,0],[867,5,867,47,0],[871,6,871,27,0],[873,6,873,29,0],[874,6,874,52,0],[875,6,875,50,0],[876,6,876,24,0],[877,6,877,40,0],[880,6,880,57,0],[884,6,884,39,0],[887,6,887,38,0],[889,6,889,29,0],[892,3,892,4,0],[896,4,896,52,0],[897,4,897,26,0],[900,9,900,19,0],[901,5,901,39,0],[902,5,902,44,0],[904,5,904,20,0],[906,12,906,27,0],[907,6,907,37,0],[908,6,908,63,0],[910,6,910,40,0],[911,6,911,28,0],[913,6,913,21,0],[914,7,914,46,0],[917,7,917,44,0],[921,6,921,33,0],[923,6,923,48,0],[900,37,900,40,0],[900,20,900,35,0],[926,3,926,4,0],[947,6,947,65,0],[962,6,962,104,0],[1038,5,1038,36,0],[1039,10,1039,20,0],[1041,6,1041,63,0],[1039,35,1039,38,0],[1039,21,1039,33,0],[1069,7,1069,51,0],[1071,7,1071,21,0],[1072,7,1072,20,0],[1073,7,1073,34,0],[1076,8,1076,64,0],[1112,14,1112,32,0],[1115,8,1115,51,0],[1116,8,1116,35,0],[1118,9,1118,25,0],[1119,9,1119,25,0],[1120,9,1120,27,0],[1122,9,1122,25,0],[1123,9,1123,25,0],[1124,9,1124,50,0],[1127,8,1127,57,0],[1146,4,1146,15,0],[1147,5,1147,37,0],[1149,5,1149,37,0],[1151,5,1151,32,0],[1154,5,1154,47,0],[1157,10,1157,27,0],[1159,6,1159,37,0],[1161,7,1161,51,0],[1162,8,1162,66,0],[1157,49,1157,59,0],[1157,28,1157,47,0],[1167,5,1167,30,0],[1170,5,1170,46,0],[1171,10,1171,20,0],[1172,6,1172,20,0],[1171,37,1171,40,0],[1171,21,1171,35,0],[1175,3,1175,4,0],[1178,4,1178,15,0],[1179,5,1179,37,0],[1182,5,1182,44,0],[1185,5,1185,56,0],[1188,5,1188,68,0],[1191,5,1191,32,0],[1192,10,1192,27,0],[1194,6,1194,37,0],[1195,7,1195,30,0],[1192,49,1192,59,0],[1192,28,1192,47,0],[1199,5,1199,30,0],[1201,3,1201,4,0],[1211,5,1211,78,0],[1212,5,1212,51,0],[1217,4,1217,15,0],[1220,6,1220,52,0],[1222,6,1222,28,0],[1223,7,1223,19,0],[1225,6,1225,69,0],[1226,7,1226,45,0],[1227,7,1227,33,0],[1228,7,1228,28,0],[1229,8,1229,80,0],[1232,7,1232,55,0],[1236,7,1236,59,0],[1237,7,1237,64,0],[1241,6,1241,54,0],[1242,7,1242,27,0],[1243,6,1243,132,0],[1246,3,1246,4,0],[1249,4,1249,40,0],[1253,4,1253,15,0],[1255,5,1255,16,0],[1257,3,1257,4,0],[1260,4,1260,15,0],[1261,5,1261,19,0],[1264,6,1264,24,0],[1265,7,1265,70,0],[1267,6,1267,17,0],[1270,6,1270,24,0],[1271,7,1271,25,0],[1274,3,1274,4,0],[1301,5,1301,59,0],[1302,5,1302,22,0],[1303,6,1303,18,0],[1327,7,1327,106,0],[1356,13,1356,31,0],[1358,7,1358,38,0],[1359,7,1359,42,0],[1360,7,1360,39,0],[1362,7,1362,22,0],[1364,8,1364,50,0],[1365,8,1365,48,0],[1366,14,1366,29,0],[1367,8,1367,18,0],[1369,8,1369,50,0],[1372,7,1372,65,0],[1381,6,1381,27,0],[1382,5,1383,24,0],[1388,5,1388,58,0],[1497,6,1497,96,0],[1510,10,1510,57,0],[1511,10,1512,32,0],[1519,7,1519,28,0],[1520,6,1520,66,0],[1400,4,1400,63,0],[1401,5,1401,26,0],[1402,5,1402,36,0],[1403,4,1403,5,0],[1406,11,1406,38,0],[1410,11,1410,37,0],[1416,5,1416,48,0],[1418,5,1418,46,0],[1453,5,1453,28,0],[1458,4,1458,5,0],[1461,11,1461,41,0],[1465,11,1465,35,0],[1472,6,1472,31,0],[1477,5,1477,58,0],[1481,5,1481,41,0],[1425,5,1425,79,0],[1426,6,1426,25,0],[1427,6,1427,35,0],[1428,5,1428,6,0],[1431,6,1431,19,0],[1432,6,1432,24,0],[1433,5,1433,6,0],[1436,6,1436,35,0],[1440,6,1440,25,0],[1441,5,1441,6,0],[1444,12,1444,54,0],[1448,12,1448,27,0],[1545,12,1545,56,0],[1546,6,1546,43,0],[1548,4,1548,5,0],[48,3,48,136,1],[49,4,49,26,1],[52,4,52,26,1],[53,4,53,30,1],[54,4,54,27,1],[55,4,55,22,1],[56,4,56,28,1],[58,4,58,33,1],[61,4,61,101,1],[62,3,62,4,1],[67,10,67,43,1],[71,10,71,36,1],[75,10,75,47,1],[83,10,83,37,1],[90,5,90,16,1],[91,6,91,26,1],[93,4,93,5,1],[99,10,99,39,1],[129,10,129,58,1],[136,5,136,16,1],[137,6,137,22,1],[139,4,139,5,1],[141,5,141,16,1],[142,6,142,23,1],[144,4,144,5,1],[149,5,149,16,1],[150,6,150,44,1],[152,4,152,5,1],[166,10,166,43,1],[170,10,170,35,1],[174,4,174,50,1],[178,4,178,15,1],[179,5,179,18,1],[181,3,181,4,1],[184,4,184,17,1],[187,4,187,15,1],[192,5,192,22,1],[194,6,194,19,1],[198,8,198,29,1],[201,8,201,24,1],[202,9,202,26,1],[207,8,207,24,1],[209,9,209,26,1],[212,8,212,31,1],[219,6,219,28,1],[222,6,222,36,1],[224,6,224,23,1],[225,6,225,22,1],[228,3,228,4,1],[231,4,231,21,1],[232,5,232,42,1],[233,10,233,29,1],[233,30,233,50,1],[244,3,244,4,1],[251,4,251,34,1],[254,4,254,53,1],[257,4,257,19,1],[259,4,259,19,1],[264,3,264,4,1],[380,4,380,49,1],[381,4,381,40,1],[384,4,384,48,1],[387,4,387,23,1],[389,4,389,21,1],[393,4,393,44,1],[405,4,405,43,1],[406,4,406,23,1],[407,3,407,4,1],[410,4,410,15,1],[412,5,412,38,1],[415,5,415,29,1],[416,5,416,22,1],[419,5,419,54,1],[422,5,422,23,1],[424,3,424,4,1],[427,4,427,15,1],[429,5,429,58,1],[430,29,430,38,1],[430,14,430,25,1],[431,6,431,30,1],[432,7,432,68,1],[433,7,433,41,1],[434,7,434,43,1],[435,8,435,51,1],[437,7,437,101,1],[430,26,430,28,1],[441,3,441,4,1],[444,4,444,15,1],[447,5,447,22,1],[449,3,449,4,1],[453,4,453,28,1],[456,4,456,19,1],[461,4,461,18,1],[462,3,462,4,1],[465,4,465,55,1],[470,4,470,52,1],[471,4,471,18,1],[472,9,472,19,1],[473,5,473,21,1],[474,5,477,15,1],[478,6,478,28,1],[479,6,479,14,1],[472,50,472,53,1],[472,20,472,48,1],[483,4,483,58,1],[488,4,488,19,1],[491,4,491,51,1],[494,5,494,26,1],[497,5,497,49,1],[499,5,499,28,1],[503,4,503,24,1],[504,4,504,72,1],[505,3,505,4,1],[509,11,509,42,1],[510,5,510,61,1],[511,5,511,21,1],[512,5,512,35,1],[514,5,514,37,1],[518,11,518,42,1],[519,5,519,61,1],[520,5,520,21,1],[522,5,522,39,1],[524,5,524,40,1],[528,5,528,26,1],[531,5,531,45,1],[532,5,532,42,1],[534,5,534,68,1],[535,5,535,50,1],[537,5,537,67,1],[538,5,538,50,1],[541,5,541,44,1],[542,5,542,36,1],[543,5,543,33,1],[546,5,546,63,1],[547,5,547,48,1],[550,5,550,31,1],[551,5,551,37,1],[552,5,552,40,1],[553,5,553,45,1],[554,5,554,49,1],[555,5,555,47,1],[556,5,556,46,1],[557,5,557,26,1],[560,5,560,68,1],[561,5,561,32,1],[564,5,564,70,1],[565,5,565,28,1],[568,5,568,39,1],[569,5,569,40,1],[570,5,570,23,1],[573,5,573,47,1],[575,5,575,28,1],[577,3,577,4,1],[581,4,581,38,1],[584,4,584,53,1],[587,4,587,40,1],[588,4,588,21,1],[591,4,591,36,1],[592,4,592,39,1],[593,4,593,45,1],[594,4,594,50,1],[595,4,595,46,1],[596,4,596,45,1],[599,11,599,61,1],[600,5,600,61,1],[601,5,601,34,1],[602,5,602,22,1],[605,5,605,59,1],[606,5,606,69,1],[607,5,607,34,1],[611,11,611,66,1],[612,5,612,61,1],[613,5,613,34,1],[614,5,614,22,1],[617,5,617,61,1],[621,4,621,38,1],[622,4,622,57,1],[625,4,625,62,1],[627,5,627,43,1],[640,3,640,4,1],[643,4,643,21,1],[644,5,644,25,1],[645,5,645,18,1],[646,5,646,21,1],[651,7,651,28,1],[652,7,652,35,1],[653,7,653,40,1],[654,7,654,26,1],[656,7,656,30,1],[662,5,662,14,1],[664,3,664,4,1],[688,4,688,74,1],[692,4,692,61,1],[696,4,696,15,1],[698,5,698,20,1],[701,5,701,32,1],[705,6,705,39,1],[709,6,709,31,1],[728,28,728,34,1],[728,15,728,24,1],[729,7,729,34,1],[730,8,730,45,1],[731,8,731,42,1],[733,8,733,56,1],[735,9,735,78,1],[739,9,739,48,1],[728,25,728,27,1],[765,3,765,4,1],[768,4,768,21,1],[769,5,769,21,1],[773,5,773,53,1],[774,5,774,34,1],[776,5,776,56,1],[780,6,780,27,1],[782,6,782,31,1],[783,6,783,38,1],[784,6,784,24,1],[786,6,786,29,1],[789,5,789,22,1],[791,3,791,4,1],[931,4,931,15,1],[932,5,932,31,1],[940,4,940,21,1],[945,4,945,21,1],[946,5,946,21,1],[950,5,950,38,1],[952,6,952,23,1],[955,5,955,50,1],[956,5,956,54,1],[957,5,957,33,1],[960,5,960,49,1],[961,5,961,39,1],[965,5,965,39,1],[966,5,966,40,1],[969,6,969,27,1],[972,6,972,57,1],[975,6,975,30,1],[976,6,976,52,1],[977,6,977,37,1],[978,6,978,20,1],[980,6,980,29,1],[983,5,983,27,1],[985,3,985,4,1],[989,5,989,26,1],[992,5,992,31,1],[995,5,995,52,1],[996,5,996,69,1],[997,5,997,66,1],[1000,5,1000,46,1],[1003,10,1003,21,1],[1004,6,1004,44,1],[1005,6,1005,38,1],[1003,43,1003,46,1],[1003,22,1003,41,1],[1009,5,1009,43,1],[1010,5,1010,41,1],[1011,5,1011,15,1],[1014,5,1014,41,1],[1017,5,1017,56,1],[1019,5,1019,28,1],[1021,3,1021,4,1],[1028,4,1028,21,1],[1029,5,1029,43,1],[1032,5,1032,48,1],[1033,5,1033,35,1],[1037,4,1037,20,1],[1048,4,1048,26,1],[1053,4,1053,36,1],[1055,4,1055,40,1],[1056,4,1056,40,1],[1059,5,1059,26,1],[1062,5,1062,28,1],[1063,10,1063,20,1],[1064,6,1064,34,1],[1068,6,1068,35,1],[1079,7,1079,28,1],[1080,7,1080,20,1],[1083,6,1083,30,1],[1084,6,1084,30,1],[1085,6,1085,33,1],[1063,35,1063,38,1],[1063,21,1063,33,1],[1089,5,1089,70,1],[1090,5,1090,34,1],[1093,12,1093,49,1],[1094,6,1094,48,1],[1097,6,1097,22,1],[1098,6,1098,23,1],[1099,11,1099,21,1],[1100,7,1100,34,1],[1101,7,1101,30,1],[1102,7,1102,32,1],[1099,36,1099,39,1],[1099,22,1099,34,1],[1106,11,1106,21,1],[1107,7,1107,34,1],[1108,7,1108,35,1],[1109,7,1109,25,1],[1111,8,1111,51,1],[1106,36,1106,39,1],[1106,22,1106,34,1],[1132,6,1132,21,1],[1136,5,1136,18,1],[1139,5,1139,26,1],[1141,5,1141,28,1],[1143,3,1143,4,1],[1204,4,1204,15,1],[1205,5,1205,42,1],[1206,5,1208,66,1],[1209,6,1209,55,1],[1214,3,1214,4,1],[1277,4,1277,15,1],[1278,5,1278,23,1],[1280,3,1280,4,1],[1300,4,1300,20,1],[1310,4,1310,28,1],[1312,5,1312,22,1],[1323,6,1323,53,1],[1324,6,1324,54,1],[1326,6,1326,40,1],[1330,6,1330,43,1],[1334,12,1334,64,1],[1335,6,1335,44,1],[1337,6,1337,62,1],[1339,6,1339,40,1],[1340,6,1340,42,1],[1342,6,1342,45,1],[1343,6,1343,39,1],[1344,6,1344,51,1],[1346,6,1346,50,1],[1350,6,1350,52,1],[1353,6,1353,24,1],[1355,7,1355,58,1],[1376,6,1376,38,1],[1379,6,1379,21,1],[1387,4,1387,20,1],[1391,4,1391,16,1],[1488,4,1488,15,1],[1489,5,1489,51,1],[1491,3,1491,4,1],[1494,4,1494,15,1],[1496,5,1496,20,1],[1504,33,1504,41,1],[1504,15,1504,29,1],[1505,7,1505,39,1],[1506,8,1506,50,1],[1507,8,1507,56,1],[1508,9,1508,91,1],[1509,9,1509,49,1],[1515,9,1515,42,1],[1504,30,1504,32,1],[1523,3,1523,4,1],[1526,4,1526,15,1],[1527,5,1527,58,1],[1529,5,1529,34,1],[1530,6,1530,24,1],[1533,3,1533,4,1],[1540,4,1540,47,1],[1541,5,1541,30,1],[1542,4,1542,5,1]]);
    </script>
  </body>
</html>