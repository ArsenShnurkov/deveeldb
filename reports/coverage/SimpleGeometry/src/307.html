<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.store\objectstream.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.IO;

namespace Deveel.Data.Store {
	public sealed class ObjectStream : Stream {
		private readonly ILargeObject largeObject;
		private long position;
		private Stream outTempStream;

		private long readBufferPos;
		private readonly byte[] readBuf;

		private const int BufferSize = 64*1024;

		public ObjectStream(ILargeObject largeObject) {
			if (largeObject == null)
				throw new ArgumentNullException(&quot;largeObject&quot;);

			this.largeObject = largeObject;
			outTempStream = new MemoryStream(64*1024);

			readBuf = new byte[BufferSize];
			readBufferPos = -1;
		}

		private void ReadPageContent(byte[] buffer, long pos, int length) {
			largeObject.Read(pos, buffer, length);
		}

		private void FillBuffer(long pos) {
			long readPos = (pos/BufferSize)*BufferSize;
			int toRead = (int) System.Math.Min(BufferSize, (largeObject.RawSize - readPos));
			if (toRead &gt; 0) {
				ReadPageContent(readBuf, readPos, toRead);
				readBufferPos = readPos;
			}
		}

		protected override void Dispose(bool disposing) {
			if (disposing) {
				outTempStream.Dispose();
				outTempStream = null;
			}

			base.Dispose(disposing);
		}

		public override void Flush() {
			try {
				long offset = 0;
				var buffer = new byte[BufferSize];
				var totalLength = largeObject.RawSize;

				outTempStream.Seek(0, SeekOrigin.Begin);

				while (offset &lt; totalLength) {
					// Fill the buffer
					int index = 0;
					int blockRead = (int) System.Math.Min((long) BufferSize, (totalLength - offset));
					int toRead = blockRead;
					while (toRead &gt; 0) {
						int count = outTempStream.Read(buffer, index, toRead);
						if (count == 0)
							break;

						index += count;
						toRead -= count;
					}

					// Send the part of the streamable object to the database.
					largeObject.Write(offset, buffer, blockRead);
					// Increment the offset and upload the next part of the object.
					offset += blockRead;
				}
			} finally {
				outTempStream.SetLength(0);
			}
		}

		public override long Seek(long offset, SeekOrigin origin) {
			throw new NotImplementedException();
		}

		public override void SetLength(long value) {
			throw new NotSupportedException(&quot;The lenght of the underlying object cannot be changed.&quot;);
		}

		public override int Read(byte[] buffer, int offset, int count) {
			if (!largeObject.IsComplete)
				throw new IOException(&quot;The underlying object is not complete.&quot;);

			if (count &lt;= 0) {
				return 0;
			}

			if (readBufferPos == -1) {
				FillBuffer(position);
			}

			int p = (int) (position - readBufferPos);
			long bufferEnd = System.Math.Min(readBufferPos + BufferSize, largeObject.RawSize);
			int toRead = (int) System.Math.Min((long) count, bufferEnd - position);
			if (toRead &lt;= 0) {
				return 0;
			}
			int hasRead = 0;
			while (toRead &gt; 0) {
				Array.Copy(readBuf, p, buffer, offset, toRead);
				hasRead += toRead;
				p += toRead;
				offset += toRead;
				count -= toRead;
				position += toRead;
				if (p &gt;= BufferSize) {
					FillBuffer(readBufferPos + BufferSize);
					p -= BufferSize;
				}
				bufferEnd = System.Math.Min(readBufferPos + BufferSize, largeObject.RawSize);
				toRead = (int) System.Math.Min((long)count, bufferEnd - position);
			}

			return hasRead;
		}

		public override void Write(byte[] buffer, int offset, int count) {
			if (largeObject.IsComplete)
				throw new IOException(&quot;The underlying object is complete.&quot;);

			outTempStream.Write(buffer, offset, count);
			position += count;
		}

		public override bool CanRead {
			get { return largeObject.IsComplete; }
		}

		public override bool CanSeek {
			get { return true; }
		}

		public override bool CanWrite {
			get { return !largeObject.IsComplete; }
		}

		public override long Length {
			get { return largeObject.RawSize; }
		}

		public override long Position {
			get { return position; }
			set { position = Seek(value, SeekOrigin.Begin); }
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[33,5,33,52,0],[56,4,56,18,0],[57,5,57,29,0],[58,5,58,26,0],[61,4,61,28,0],[62,3,62,4,0],[97,4,97,40,0],[101,4,101,94,0],[106,5,106,69,0],[109,5,109,14,0],[131,6,131,45,0],[132,6,132,22,0],[143,5,143,65,0],[162,10,162,37,0],[167,10,167,51,0],[167,52,167,53,0],[31,3,31,48,1],[32,4,32,28,1],[35,4,35,35,1],[36,4,36,46,1],[38,4,38,35,1],[39,4,39,23,1],[40,3,40,4,1],[43,4,43,42,1],[44,3,44,4,1],[47,4,47,47,1],[48,4,48,84,1],[49,4,49,19,1],[50,5,50,47,1],[51,5,51,29,1],[53,3,53,4,1],[66,5,66,21,1],[67,5,67,39,1],[68,5,68,43,1],[70,5,70,45,1],[74,6,74,20,1],[75,6,75,87,1],[76,6,76,29,1],[78,7,78,61,1],[79,7,79,22,1],[82,7,82,22,1],[83,7,83,23,1],[77,6,77,24,1],[87,6,87,51,1],[89,6,89,26,1],[72,5,72,33,1],[92,5,92,32,1],[94,3,94,4,1],[105,4,105,32,1],[108,4,108,19,1],[112,4,112,28,1],[113,5,113,26,1],[116,4,116,45,1],[117,4,117,86,1],[118,4,118,75,1],[119,4,119,20,1],[120,5,120,14,1],[122,4,122,20,1],[124,5,124,52,1],[125,5,125,23,1],[126,5,126,17,1],[127,5,127,22,1],[128,5,128,21,1],[129,5,129,24,1],[130,5,130,25,1],[134,5,134,82,1],[135,5,135,71,1],[123,4,123,22,1],[138,4,138,19,1],[142,4,142,31,1],[145,4,145,47,1],[146,4,146,22,1],[147,3,147,4,1],[150,10,150,40,1],[154,10,154,22,1],[158,10,158,41,1],[166,10,166,26,1]]);
    </script>
  </body>
</html>