<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.objects\sqlnumber.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;

using Deveel.Math;

namespace Deveel.Data.Sql.Objects {
	[Serializable]
	public struct SqlNumber : ISqlObject, IComparable&lt;SqlNumber&gt;, IConvertible, IEquatable&lt;SqlNumber&gt; {
		private readonly BigDecimal innerValue;
		private readonly int byteCount;
		private readonly long valueAsLong;

		public static readonly SqlNumber Zero = new SqlNumber(NumericState.None, BigDecimal.Zero);
		public static readonly SqlNumber One = new SqlNumber(NumericState.None, BigDecimal.One);
		public static readonly SqlNumber Null = new SqlNumber(NumericState.None, null);

		public static readonly SqlNumber NaN = new SqlNumber(NumericState.NotANumber, null);

		public static readonly SqlNumber NegativeInfinity = new SqlNumber(NumericState.NegativeInfinity, null);

		public static readonly SqlNumber PositiveInfinity = new SqlNumber(NumericState.PositiveInfinity, null);

		private SqlNumber(BigDecimal value)
			: this(NumericState.None, value) {
		}

		private SqlNumber(NumericState state, BigDecimal value)
			: this() {
			valueAsLong = 0;
			byteCount = 120;

			if (value != null &amp;&amp; value.Scale == 0) {
				BigInteger bint = value.ToBigInteger();
				int bitCount = bint.BitLength;
				if (bitCount &lt; 30) {
					valueAsLong = bint.ToInt64();
					byteCount = 4;
				} else if (bitCount &lt; 60) {
					valueAsLong = bint.ToInt64();
					byteCount = 8;
				}
			}

			innerValue = value;
			State = state;
		}

		public SqlNumber(byte[] bytes, int scale)
			: this(new BigDecimal(new BigInteger(bytes), scale)) {
		}

		public SqlNumber(byte[] bytes, int scale, int precision)
			: this(new BigDecimal(new BigInteger(bytes), scale, new MathContext(precision))) {
		}

		public SqlNumber(int value, int precision)
			: this(new BigDecimal(value, new MathContext(precision))) {
		}

		public SqlNumber(int value)
			: this(value, MathContext.Decimal32.Precision) {
		}

		public SqlNumber(long value, int precision)
			: this(new BigDecimal(value, new MathContext(precision))) {
		}

		public SqlNumber(long value)
			: this(value, MathContext.Decimal64.Precision) {
		}

		public SqlNumber(double value)
			: this(value, MathContext.Decimal128.Precision) {
		}

		public SqlNumber(double value, int precision)
			: this(new BigDecimal(value, new MathContext(precision))) {
		}

		public NumericState State { get; private set; }

		public bool CanBeInt64 {
			get { return byteCount &lt;= 8; }
		}

		public bool CanBeInt32 {
			get { return byteCount &lt;= 4; }
		}

		public int Scale {
			get { return State == NumericState.None ? innerValue.Scale : 0; }
		}

		public int Precision {
			get { return State == NumericState.None ? innerValue.Precision : 0; }
		}

		private MathContext MathContext {
			get { return State == NumericState.None ? new MathContext(Precision) : null; }
		}

		public int Sign {
			get { return State == NumericState.None ? innerValue.Sign : 0; }
		}

		int IComparable.CompareTo(object obj) {
			if (!(obj is SqlNumber))
				throw new ArgumentException();

			return CompareTo((SqlNumber) obj);
		}

		int IComparable&lt;ISqlObject&gt;.CompareTo(ISqlObject other) {
			if (!(other is SqlNumber))
				throw new ArgumentException();

			return CompareTo((SqlNumber) other);
		}

		public bool IsNull {
			get { return State == NumericState.None &amp;&amp; innerValue == null; }
		}

		private NumericState InverseState() {
			if (State == NumericState.NegativeInfinity)
				return NumericState.PositiveInfinity;
			if (State == NumericState.PositiveInfinity)
				return NumericState.NegativeInfinity;
			return State;
		}

		bool ISqlObject.IsComparableTo(ISqlObject other) {
			return other is SqlNumber;
		}

		public bool Equals(SqlNumber other) {
			if (State == NumericState.NegativeInfinity &amp;&amp;
			    other.State == NumericState.NegativeInfinity)
				return true;
			if (State == NumericState.PositiveInfinity &amp;&amp;
			    other.State == NumericState.PositiveInfinity)
				return true;
			if (State == NumericState.NotANumber &amp;&amp;
			    other.State == NumericState.NotANumber)
				return true;

			if (IsNull &amp;&amp; other.IsNull)
				return true;
			if (IsNull &amp;&amp; !other.IsNull)
				return false;
			if (!IsNull &amp;&amp; other.IsNull)
				return false;

			return innerValue.CompareTo(other.innerValue) == 0;
		}

		public override bool Equals(object obj) {
			if (!(obj is SqlNumber))
				throw new ArgumentException(&quot;The object is not a NUMBER.&quot;);

			return Equals((SqlNumber) obj);
		}

		public override int GetHashCode() {
			return innerValue.GetHashCode() ^ State.GetHashCode();
		}

		public int CompareTo(SqlNumber other) {
			if (Equals(this, other))
				return 0;

			// If this is a non-infinity number
			if (State == NumericState.None) {
				// If both values can be represented by a long value
				if (CanBeInt64 &amp;&amp; other.CanBeInt64) {
					// Perform a long comparison check,
					if (valueAsLong &gt; other.valueAsLong)
						return 1;
					if (valueAsLong &lt; other.valueAsLong)
						return -1;
					return 0;
				}

				// And the compared number is non-infinity then use the BigDecimal
				// compareTo method.
				if (other.State == NumericState.None)
					return innerValue.CompareTo(other.innerValue);

				// Comparing a regular number with a NaN number.
				// If positive infinity or if NaN
				if (other.State == NumericState.PositiveInfinity ||
				    other.State == NumericState.NotANumber) {
					return -1;
				}
					// If negative infinity
				if (other.State == NumericState.NegativeInfinity)
					return 1;

				throw new ApplicationException(&quot;Unknown number state.&quot;);
			}

			// This number is a NaN number.
			// Are we comparing with a regular number?
			if (other.State == NumericState.None) {
				// Yes, negative infinity
				if (State == NumericState.NegativeInfinity)
					return -1;

				// positive infinity or NaN
				if (State == NumericState.PositiveInfinity ||
				    State == NumericState.NotANumber)
					return 1;

				throw new ApplicationException(&quot;Unknown number state.&quot;);
			}

			// Comparing NaN number with a NaN number.
			// This compares -Inf less than Inf and NaN and NaN greater than
			// Inf and -Inf.  -Inf &lt; Inf &lt; NaN
			return (State - other.State);
		}

		TypeCode IConvertible.GetTypeCode() {
			if (CanBeInt32)
				return TypeCode.Int32;
			if (CanBeInt64)
				return TypeCode.Int64;

			return TypeCode.Object;
		}

				bool IConvertible.ToBoolean(IFormatProvider provider) {
			return ToBoolean();
		}

		char IConvertible.ToChar(IFormatProvider provider) {
			throw new InvalidCastException(&quot;Conversion of NUMERIC to Char is invalid.&quot;);
		}

		sbyte IConvertible.ToSByte(IFormatProvider provider) {
			throw new NotSupportedException(&quot;Conversion to Signed Byte numbers not supported yet.&quot;);
		}

		byte IConvertible.ToByte(IFormatProvider provider) {
			return ToByte();
		}

		short IConvertible.ToInt16(IFormatProvider provider) {
			return ToInt16();
		}

		ushort IConvertible.ToUInt16(IFormatProvider provider) {
			throw new NotSupportedException(&quot;Conversion to Unsigned numbers not supported yet.&quot;);
		}

		int IConvertible.ToInt32(IFormatProvider provider) {
			return ToInt32();
		}

		uint IConvertible.ToUInt32(IFormatProvider provider) {
			throw new NotSupportedException(&quot;Conversion to Unsigned numbers not supported yet.&quot;);
		}

		long IConvertible.ToInt64(IFormatProvider provider) {
			return ToInt64();
		}

		ulong IConvertible.ToUInt64(IFormatProvider provider) {
			throw new NotSupportedException(&quot;Conversion to Unsigned numbers not supported yet.&quot;);
		}

		float IConvertible.ToSingle(IFormatProvider provider) {
			return ToSingle();
		}

		double IConvertible.ToDouble(IFormatProvider provider) {
			return ToDouble();
		}

		decimal IConvertible.ToDecimal(IFormatProvider provider) {
			throw new NotSupportedException(&quot;Conversion to Decimal not supported yet.&quot;);
		}

		DateTime IConvertible.ToDateTime(IFormatProvider provider) {
			throw new InvalidCastException(&quot;Cannot cast NUMERIC to DateTime automatically.&quot;);
		}

		string IConvertible.ToString(IFormatProvider provider) {
			return ToString();
		}

		object IConvertible.ToType(Type conversionType, IFormatProvider provider) {
			if (conversionType == typeof (bool))
				return ToBoolean();
			if (conversionType == typeof (byte))
				return ToByte();
			if (conversionType == typeof (short))
				return ToInt16();
			if (conversionType == typeof (int))
				return ToInt32();
			if (conversionType == typeof (long))
				return ToInt64();
			if (conversionType == typeof (float))
				return ToSingle();
			if (conversionType == typeof (double))
				return ToDouble();

			if (conversionType == typeof (byte[]))
				return ToByteArray();

			if (conversionType == typeof (string))
				return ToString();

			if (conversionType == typeof (SqlBoolean))
				return new SqlBoolean(ToBoolean());
			if (conversionType == typeof (SqlBinary))
				return new SqlBinary(ToByteArray());
			if (conversionType == typeof (SqlString))
				return new SqlString(ToString());

			throw new InvalidCastException(System.String.Format(&quot;Cannot convert NUMERIC to {0}&quot;, conversionType));
		}

				public byte[] ToByteArray() {
			return State == NumericState.None
				? innerValue.MovePointRight(innerValue.Scale).ToBigInteger().ToByteArray()
				: new byte[0];
		}

		public override string ToString() {
			switch (State) {
				case (NumericState.None):
					return innerValue.ToString();
				case (NumericState.NegativeInfinity):
					return &quot;-Infinity&quot;;
				case (NumericState.PositiveInfinity):
					return &quot;Infinity&quot;;
				case (NumericState.NotANumber):
					return &quot;NaN&quot;;
				default:
					throw new ApplicationException(&quot;Unknown number state&quot;);
			}
		}

		public double ToDouble() {
			switch (State) {
				case (NumericState.None):
					return innerValue.ToDouble();
				case (NumericState.NegativeInfinity):
					return Double.NegativeInfinity;
				case (NumericState.PositiveInfinity):
					return Double.PositiveInfinity;
				case (NumericState.NotANumber):
					return Double.NaN;
				default:
					throw new ApplicationException(&quot;Unknown number state&quot;);
			}
		}

		public float ToSingle() {
			switch (State) {
				case (NumericState.None):
					return innerValue.ToSingle();
				case (NumericState.NegativeInfinity):
					return Single.NegativeInfinity;
				case (NumericState.PositiveInfinity):
					return Single.PositiveInfinity;
				case (NumericState.NotANumber):
					return Single.NaN;
				default:
					throw new ApplicationException(&quot;Unknown number state&quot;);
			}
		}

		public long ToInt64() {
			if (CanBeInt64)
				return valueAsLong;
			switch (State) {
				case (NumericState.None):
					return innerValue.ToInt64();
				default:
					return (long)ToDouble();
			}
		}

		public int ToInt32() {
			if (CanBeInt32)
				return (int)valueAsLong;
			switch (State) {
				case (NumericState.None):
					return innerValue.ToInt32();
				default:
					return (int)ToDouble();
			}
		}

		public short ToInt16() {
			if (!CanBeInt32)
				throw new InvalidCastException(&quot;The value of this numeric is over the maximum Int16.&quot;);

			var value = ToInt32();
			if (value &gt; Int16.MaxValue ||
				value &lt; Int16.MinValue)
				throw new InvalidCastException(&quot;The value of this numeric is out of range of a short integer.&quot;);

			return (short)value;
		}

		public byte ToByte() {
			if (!CanBeInt32)
				throw new InvalidCastException(&quot;The value of this numeric is over the maximum Byte.&quot;);

			var value = ToInt32();
			if (value &gt; Byte.MaxValue ||
				value &lt; Byte.MinValue)
				throw new InvalidCastException(&quot;The value of this numeric is out of range of a byte.&quot;);

			return (byte)value;
		}

		public bool ToBoolean() {
			if (Equals(One))
				return true;
			if (Equals(Zero))
				return false;

			throw new InvalidCastException(&quot;The value of this NUMERIC cannot be converted to a boolean.&quot;);
		}

		public SqlNumber XOr(SqlNumber value) {
			if (State == NumericState.NotANumber)
				return this;

			if (Scale == 0 &amp;&amp; value.Scale == 0) {
				BigInteger bi1 = innerValue.ToBigInteger();
				BigInteger bi2 = innerValue.ToBigInteger();
				return new SqlNumber(NumericState.None, new BigDecimal(bi1.Or(bi2)));
			}

			return Null;
		}

		public SqlNumber Add(SqlNumber value) {
			if (State == NumericState.None) {
				if (value.State == NumericState.None) {
					if (IsNull || value.IsNull)
						return Null;

					return new SqlNumber(NumericState.None, innerValue.Add(value.innerValue));
				}

				return new SqlNumber(value.State, null);
			}

			return new SqlNumber(State, null);
		}

		public SqlNumber Subtract(SqlNumber value) {
			if (State == NumericState.None) {
				if (value.State == NumericState.None) {
					if (IsNull || value.IsNull)
						return Null;

					return new SqlNumber(NumericState.None, innerValue.Subtract(value.innerValue));
				}
				return new SqlNumber(value.InverseState(), null);
			}
			
			return new SqlNumber(State, null);
		}

		public SqlNumber Multiply(SqlNumber value) {
			if (State == NumericState.None) {
				if (value.State == NumericState.None) {
					if (IsNull || value.IsNull)
						return Null;

					return new SqlNumber(NumericState.None, innerValue.Multiply(value.innerValue));
				}

				return new SqlNumber(value.State, null);
			}

			return new SqlNumber(State, null);
		}

		public SqlNumber Divide(SqlNumber value) {
			if (State == NumericState.None) {
				if (value.State == NumericState.None) {
					if (IsNull || value.IsNull)
						return Null;

					BigDecimal divBy = value.innerValue;
					if (divBy.CompareTo (BigDecimal.Zero) != 0) {
						return new SqlNumber(NumericState.None, innerValue.Divide(divBy, 10, RoundingMode.HalfUp));
					}
				}
			}

			// Return NaN if we can&#39;t divide
			return new SqlNumber(NumericState.NotANumber, null);
		}

		public SqlNumber Modulo(SqlNumber value) {
			if (State == NumericState.None) {
				if (value.State == NumericState.None) {
					if (IsNull || value.IsNull)
						return Null;

					BigDecimal divBy = value.innerValue;
					if (divBy.CompareTo(BigDecimal.Zero) != 0) {
						BigDecimal remainder = innerValue.Remainder(divBy);
						return new SqlNumber(NumericState.None, remainder);
					}
				}
			}

			return new SqlNumber(NumericState.NotANumber, null);
		}

		public SqlNumber Abs() {
			if (State == NumericState.None)
				return new SqlNumber(NumericState.None, innerValue.Abs());
			if (State == NumericState.NegativeInfinity)
				return new SqlNumber(NumericState.PositiveInfinity, null);
			return new SqlNumber(State, null);
		}

		public SqlNumber SetScale(int scale, RoundingMode mode) {
			if (State == NumericState.None)
				return new SqlNumber(innerValue.SetScale(scale, mode));

			// Can&#39;t round -inf, +inf and NaN
			return this;
		}

		public SqlNumber Negate() {
			if (State == NumericState.None)
				return new SqlNumber(innerValue.Negate());
			if (State == NumericState.NegativeInfinity ||
				State == NumericState.PositiveInfinity)
				return new SqlNumber(InverseState(), null);

			return this;
		}

		public SqlNumber Plus() {
			if (State == NumericState.None)
				return new SqlNumber(innerValue.Plus());
			if (State == NumericState.NegativeInfinity ||
				State == NumericState.PositiveInfinity)
				return new SqlNumber(InverseState(), null);

			return this;
		}

		public SqlNumber Sqrt() {
			if (State == NumericState.None)
				return new SqlNumber(BigMath.Sqrt(innerValue));

			return this;
		}

		public SqlNumber Root(int n) {
			if (State == NumericState.None)
				return new SqlNumber(BigMath.Root(n, innerValue));

			return this;
		}

		public SqlNumber Sin() {
			if (State == NumericState.None)
				return new SqlNumber(BigMath.Sin(innerValue));

			return this;
		}

		public SqlNumber Cos() {
			if (State == NumericState.None)
				return new SqlNumber(BigMath.Cos(innerValue));

			return this;
		}

		public SqlNumber Cot() {
			if (State == NumericState.None)
				return new SqlNumber(BigMath.Cot(innerValue));

			return this;
		}

		public SqlNumber Tan() {
			if (State == NumericState.None)
				return new SqlNumber(BigMath.Tan(innerValue));

			return this;
		}

		public SqlNumber Pow(SqlNumber exp) {
			if (State == NumericState.None)
				return new SqlNumber(BigMath.Pow(innerValue, exp.innerValue));

			return this;
		}

		public SqlNumber Log2() {
			if (State == NumericState.None)
				return new SqlNumber(BigMath.Log(innerValue));

			return this;
		}

		public SqlNumber Round() {
			return Round(MathContext.Precision);
		}

		public SqlNumber Round(int precision) {
			if (State == NumericState.None)
				return new SqlNumber(innerValue.Round(new MathContext(precision, RoundingMode.HalfUp)));

			return this;			
		}

		public static bool TryParse(string s, out SqlNumber value) {
			if (String.IsNullOrEmpty(s)) {
				value = Null;
				return false;
			}

			if (string.Equals(s, &quot;+Infinity&quot;, StringComparison.OrdinalIgnoreCase) ||
			    string.Equals(s, &quot;+Inf&quot;, StringComparison.OrdinalIgnoreCase) ||
				string.Equals(s, &quot;Infinity&quot;, StringComparison.OrdinalIgnoreCase)) {
				value = PositiveInfinity;
				return true;
			}

			if (string.Equals(s, &quot;-Infinity&quot;, StringComparison.OrdinalIgnoreCase) ||
			    string.Equals(s, &quot;-Inf&quot;, StringComparison.OrdinalIgnoreCase)) {
				value = NegativeInfinity;
				return true;
			}

			if (string.Equals(s, &quot;NaN&quot;, StringComparison.OrdinalIgnoreCase) ||
			    string.Equals(s, &quot;NotANumber&quot;, StringComparison.OrdinalIgnoreCase)) {
				value = NaN;
				return true;
			}

			BigDecimal decimalValue;

			try {
				decimalValue = new BigDecimal(s);
			} catch (Exception) {
				value = Null;
				return false;
			}

			value = new SqlNumber(NumericState.None, decimalValue);
			return true;
		}

		public static SqlNumber Parse(string s) {
			SqlNumber value;
			if (!TryParse(s, out value))
				throw new FormatException(string.Format(&quot;Cannot parse the string &#39;{0}&#39; to a valid Numeric object.&quot;, s));

			return value;
		}

				public static SqlNumber operator +(SqlNumber a, SqlNumber b) {
			return a.Add(b);
		}

		public static SqlNumber operator -(SqlNumber a, SqlNumber b) {
			return a.Subtract(b);
		}

		public static SqlNumber operator *(SqlNumber a, SqlNumber b) {
			return a.Multiply(b);
		}

		public static SqlNumber operator /(SqlNumber a, SqlNumber b) {
			return a.Divide(b);
		}

		public static SqlNumber operator %(SqlNumber a, SqlNumber b) {
			return a.Modulo(b);
		}

		public static SqlNumber operator |(SqlNumber a, SqlNumber b) {
			return a.XOr(b);
		}

		public static SqlNumber operator -(SqlNumber a) {
			return a.Negate();
		}

		public static SqlNumber operator +(SqlNumber a) {
			return a.Plus();
		}

		public static bool operator ==(SqlNumber a, SqlNumber b) {				
			return a.Equals(b);
		}

		public static bool operator !=(SqlNumber a, SqlNumber b) {
			return !(a == b);
		}

		public static bool operator &gt;(SqlNumber a, SqlNumber b) {
			return a.CompareTo(b) &lt; 0;
		}

		public static bool operator &lt;(SqlNumber a, SqlNumber b) {
			return a.CompareTo(b) &gt; 0;
		}

		public static bool operator &gt;=(SqlNumber a, SqlNumber b) {
			var i = a.CompareTo(b);
			return i == 0 || i &lt; 0;
		}

		public static bool operator &lt;=(SqlNumber a, SqlNumber b) {
			var i = a.CompareTo(b);
			return i == 0 || i &gt; 0;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[63,3,64,56,0],[65,3,65,4,0],[114,10,114,80,0],[122,4,122,28,0],[123,5,123,35,0],[125,4,125,38,0],[129,4,129,30,0],[130,5,130,35,0],[132,4,132,40,0],[140,4,140,47,0],[141,5,141,42,0],[142,4,142,47,0],[143,5,143,42,0],[144,4,144,17,0],[148,4,148,30,0],[154,5,154,17,0],[157,5,157,17,0],[160,5,160,17,0],[163,5,163,17,0],[165,5,165,18,0],[167,5,167,18,0],[174,5,174,64,0],[180,4,180,58,0],[196,6,196,15,0],[206,5,207,48,0],[208,6,208,16,0],[211,5,211,54,0],[212,6,212,15,0],[214,5,214,61,0],[219,4,219,41,0],[221,5,221,48,0],[222,6,222,16,0],[225,5,226,42,0],[227,6,227,15,0],[229,5,229,61,0],[235,4,235,33,0],[239,4,239,19,0],[240,5,240,27,0],[241,4,241,19,0],[242,5,242,27,0],[244,4,244,27,0],[248,4,248,23,0],[252,4,252,80,0],[256,4,256,92,0],[260,4,260,20,0],[264,4,264,21,0],[268,4,268,89,0],[272,4,272,21,0],[276,4,276,89,0],[280,4,280,21,0],[284,4,284,89,0],[288,4,288,22,0],[292,4,292,22,0],[296,4,296,80,0],[300,4,300,85,0],[304,4,304,22,0],[309,5,309,24,0],[311,5,311,21,0],[313,5,313,22,0],[315,5,315,22,0],[317,5,317,22,0],[319,5,319,23,0],[321,5,321,23,0],[324,5,324,26,0],[327,5,327,23,0],[331,4,331,45,0],[332,5,332,41,0],[333,4,333,45,0],[334,5,334,38,0],[336,4,336,106,0],[350,6,350,25,0],[352,6,352,24,0],[354,6,354,19,0],[356,6,356,61,0],[365,6,365,37,0],[367,6,367,37,0],[369,6,369,24,0],[371,6,371,61,0],[376,4,376,18,0],[378,6,378,35,0],[380,6,380,37,0],[382,6,382,37,0],[384,6,384,24,0],[386,6,386,61,0],[393,4,393,18,0],[395,6,395,34,0],[397,6,397,30,0],[404,4,404,18,0],[406,6,406,34,0],[408,6,408,29,0],[414,5,414,92,0],[419,5,419,101,0],[425,4,425,20,0],[426,5,426,91,0],[428,4,428,26,0],[429,4,430,27,0],[431,5,431,92,0],[433,4,433,23,0],[439,4,439,21,0],[440,5,440,18,0],[442,4,442,98,0],[446,4,446,41,0],[447,5,447,17,0],[449,4,449,39,0],[450,5,450,48,0],[451,5,451,48,0],[452,5,452,74,0],[455,4,455,16,0],[462,7,462,19,0],[467,5,467,45,0],[470,4,470,38,0],[477,7,477,19,0],[481,5,481,54,0],[484,4,484,38,0],[491,7,491,19,0],[496,5,496,45,0],[499,4,499,38,0],[503,4,503,35,0],[504,5,504,42,0],[505,6,505,33,0],[506,7,506,19,0],[508,6,508,42,0],[509,6,509,49,0],[510,7,510,98,0],[516,4,516,56,0],[520,4,520,35,0],[521,5,521,42,0],[522,6,522,33,0],[523,7,523,19,0],[525,6,525,42,0],[526,6,526,48,0],[527,7,527,58,0],[528,7,528,58,0],[533,4,533,56,0],[537,4,537,35,0],[538,5,538,63,0],[539,4,539,47,0],[540,5,540,63,0],[541,4,541,38,0],[545,4,545,35,0],[546,5,546,60,0],[549,4,549,16,0],[553,4,553,35,0],[554,5,554,47,0],[555,4,556,44,0],[557,5,557,48,0],[559,4,559,16,0],[563,4,563,35,0],[564,5,564,45,0],[565,4,566,44,0],[567,5,567,48,0],[569,4,569,16,0],[573,4,573,35,0],[574,5,574,52,0],[576,4,576,16,0],[580,4,580,35,0],[581,5,581,55,0],[583,4,583,16,0],[587,4,587,35,0],[588,5,588,51,0],[590,4,590,16,0],[594,4,594,35,0],[595,5,595,51,0],[597,4,597,16,0],[601,4,601,35,0],[602,5,602,51,0],[604,4,604,16,0],[608,4,608,35,0],[609,5,609,51,0],[611,4,611,16,0],[615,4,615,35,0],[616,5,616,67,0],[618,4,618,16,0],[622,4,622,35,0],[623,5,623,51,0],[625,4,625,16,0],[629,4,629,40,0],[636,4,636,16,0],[641,5,641,18,0],[642,5,642,18,0],[648,5,648,30,0],[649,5,649,17,0],[654,5,654,30,0],[655,5,655,17,0],[660,5,660,17,0],[661,5,661,17,0],[680,5,680,109,0],[690,4,690,25,0],[694,4,694,25,0],[698,4,698,23,0],[702,4,702,23,0],[706,4,706,20,0],[710,4,710,22,0],[714,4,714,20,0],[722,4,722,21,0],[734,4,734,27,0],[735,4,735,27,0],[739,4,739,27,0],[740,4,740,27,0],[38,3,39,36,1],[40,3,40,4,1],[43,6,43,12,1],[44,4,44,20,1],[45,4,45,20,1],[47,4,47,42,1],[48,5,48,44,1],[49,5,49,35,1],[50,5,50,23,1],[51,6,51,35,1],[52,6,52,20,1],[53,12,53,30,1],[54,6,54,35,1],[55,6,55,20,1],[59,4,59,23,1],[60,4,60,18,1],[61,3,61,4,1],[67,3,68,84,1],[69,3,69,4,1],[71,3,72,61,1],[73,3,73,4,1],[75,3,76,50,1],[77,3,77,4,1],[79,3,80,61,1],[81,3,81,4,1],[83,3,84,50,1],[85,3,85,4,1],[87,3,88,51,1],[89,3,89,4,1],[91,3,92,61,1],[93,3,93,4,1],[98,10,98,32,1],[102,10,102,32,1],[106,10,106,67,1],[110,10,110,71,1],[118,10,118,66,1],[136,10,136,66,1],[152,4,153,53,1],[155,4,156,53,1],[158,4,159,47,1],[162,4,162,31,1],[164,4,164,32,1],[166,4,166,32,1],[169,4,169,55,1],[173,4,173,28,1],[176,4,176,35,1],[184,4,184,28,1],[185,5,185,14,1],[188,4,188,35,1],[190,5,190,40,1],[192,6,192,42,1],[193,7,193,16,1],[194,6,194,42,1],[195,7,195,17,1],[201,5,201,42,1],[202,6,202,52,1],[308,4,308,40,1],[310,4,310,40,1],[312,4,312,41,1],[314,4,314,39,1],[316,4,316,40,1],[318,4,318,41,1],[320,4,320,42,1],[323,4,323,42,1],[326,4,326,42,1],[329,4,329,46,1],[330,5,330,40,1],[340,4,342,19,1],[346,4,346,18,1],[348,6,348,35,1],[361,4,361,18,1],[363,6,363,35,1],[391,4,391,19,1],[392,5,392,24,1],[402,4,402,19,1],[403,5,403,29,1],[413,4,413,20,1],[416,4,416,26,1],[417,4,418,28,1],[421,4,421,24,1],[437,4,437,20,1],[438,5,438,17,1],[459,4,459,35,1],[460,5,460,42,1],[461,6,461,33,1],[464,6,464,80,1],[474,4,474,35,1],[475,5,475,42,1],[476,6,476,33,1],[479,6,479,85,1],[488,4,488,35,1],[489,5,489,42,1],[490,6,490,33,1],[493,6,493,85,1],[633,4,633,35,1],[634,5,634,93,1],[640,4,640,32,1],[645,4,647,70,1],[652,4,653,69,1],[658,4,659,75,1],[667,5,667,38,1],[668,6,668,23,1],[669,5,669,18,1],[670,5,670,18,1],[673,4,673,59,1],[674,4,674,16,1],[675,3,675,4,1],[679,4,679,32,1],[682,4,682,17,1],[686,4,686,20,1],[718,4,718,23,1],[726,4,726,30,1],[730,4,730,30,1],[28,3,28,93,1],[29,3,29,91,1],[30,3,30,82,1],[32,3,32,87,1],[34,3,34,106,1],[36,3,36,106,1]]);
    </script>
  </body>
</html>