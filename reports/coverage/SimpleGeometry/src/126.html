<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.security\cryptohashextensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace Deveel.Data.Security {
	public static class CryptoHashExtenions {
		#region Pbkdf2

		private const int DefaultIterationCount = 10000;

		public static string MakePbkdf2String(this IKeyedHashFunction hash, string input, string salt, int length) {
			return MakePbkdf2String(hash, input, salt, length, DefaultIterationCount);
		}

		public static string MakePbkdf2String(this IKeyedHashFunction hash, string input, string salt, int length, int iterationCount) {
			return hash.MakePbkdf2String(input, Convert.FromBase64String(salt), length, iterationCount);
		}

		public static string MakePbkdf2String(this IKeyedHashFunction hash, string input, byte[] salt, int length) {
			return MakePbkdf2String(hash, input, salt, length, DefaultIterationCount);
		}

		public static string MakePbkdf2String(this IKeyedHashFunction hash, string input, byte[] salt, int length, int iterationCount) {
			var data = Encoding.UTF8.GetBytes(input);
			var result = hash.MakePbkdf2(data, salt, length, iterationCount);
			return Convert.ToBase64String(result);
		}

		public static byte[] MakePbkdf2(this IKeyedHashFunction hash, byte[] salt, int length, int iterationCount) {
			var hashKey = hash.Key;
			if (hashKey == null || hashKey.Length == 0)
				throw new InvalidOperationException(&quot;Key was not specified for the hash.&quot;);

			return MakePbkdf2(hash, hashKey, salt, length, iterationCount);
		}

		public static byte[] MakePbkdf2(this IKeyedHashFunction hash, byte[] data, byte[] salt, int length) {
			return MakePbkdf2(hash, data, salt, length, DefaultIterationCount);
		}

		public static byte[] MakePbkdf2(this IKeyedHashFunction hash, byte[] data, byte[] salt, int length, int iterationCount) {
			hash.Key = data;

			int hashLength = hash.HashSize/8;
			if ((hash.HashSize &amp; 7) != 0)
				hashLength++;

			int keyLength = length/hashLength;
			if (length &gt; (0xFFFFFFFFL*hashLength) || length &lt; 0)
				throw new ArgumentOutOfRangeException(&quot;length&quot;);

			if (length%hashLength != 0)
				keyLength++;

			byte[] extendedkey = new byte[salt.Length + 4];
			Buffer.BlockCopy(salt, 0, extendedkey, 0, salt.Length);

			using (var ms = new MemoryStream()) {
				for (int i = 0; i &lt; keyLength; i++) {
					extendedkey[salt.Length] = (byte) (((i + 1) &gt;&gt; 24) &amp; 0xFF);
					extendedkey[salt.Length + 1] = (byte) (((i + 1) &gt;&gt; 16) &amp; 0xFF);
					extendedkey[salt.Length + 2] = (byte) (((i + 1) &gt;&gt; 8) &amp; 0xFF);
					extendedkey[salt.Length + 3] = (byte) (((i + 1)) &amp; 0xFF);

					byte[] u = hash.Compute(extendedkey);
					Array.Clear(extendedkey, salt.Length, 4);

					byte[] f = u;
					for (int j = 1; j &lt; iterationCount; j++) {
						u = hash.Compute(u);
						for (int k = 0; k &lt; f.Length; k++) {
							f[k] ^= u[k];
						}
					}

					ms.Write(f, 0, f.Length);
					Array.Clear(u, 0, u.Length);
					Array.Clear(f, 0, f.Length);
				}

				byte[] dk = new byte[length];
				ms.Position = 0;
				ms.Read(dk, 0, length);
				ms.Position = 0;

				for (long i = 0; i &lt; ms.Length; i++) {
					ms.WriteByte(0);
				}

				Array.Clear(extendedkey, 0, extendedkey.Length);
				return dk;
			}
		}

		public static bool VerifyPbkdf2(this IKeyedHashFunction hash, byte[] hashed, byte[] otherData, byte[] salt) {
			return VerifyPbkdf2(hash, hashed, otherData, salt, DefaultIterationCount);
		}

		public static bool VerifyPbkdf2(this IKeyedHashFunction hash, byte[] hashed, byte[] otherData, byte[] salt, int iterationCount) {
			int length = hashed.Length;

			var otherHashed = hash.MakePbkdf2(otherData, salt, length, iterationCount);

			if (otherHashed.Length != hashed.Length)
				return false;

			return ByteArraysEqual(hashed, otherHashed);
		}

		public static bool VerifyPbkdf2String(this IKeyedHashFunction hash, string hashedString, string otherString, byte[] salt) {
			return VerifyPbkdf2String(hash, hashedString, otherString, salt, DefaultIterationCount);
		}

		public static bool VerifyPbkdf2String(this IKeyedHashFunction hash, string hashedString, string otherString, byte[] salt, int iterationCount) {
			return hash.VerifyPbkdf2String(hashedString, otherString, Convert.ToBase64String(salt), iterationCount);
		}

		public static bool VerifyPbkdf2String(this IKeyedHashFunction hash, string hashedString, string otherString, string saltString) {
			return VerifyPbkdf2String(hash, hashedString, otherString, saltString, DefaultIterationCount);
		}

		public static bool VerifyPbkdf2String(this IKeyedHashFunction hash, string hashedString, string otherString, string saltString, int iterationCount) {
			var hashed = Convert.FromBase64String(hashedString);
			var otherData = Encoding.UTF8.GetBytes(otherString);
			var salt = Convert.FromBase64String(saltString);

			return hash.VerifyPbkdf2(hashed, otherData, salt, iterationCount);
		}

		private static bool ByteArraysEqual(byte[] a, byte[] b) {
			if (ReferenceEquals(a, b)) {
				return true;
			}

			if (a == null || b == null || a.Length != b.Length) {
				return false;
			}

			bool areSame = true;
			for (int i = 0; i &lt; a.Length; i++) {
				areSame &amp;= (a[i] == b[i]);
			}
			return areSame;
		}

		#endregion

		public static string ComputeString(this IHashFunction hash, string s) {
			var data = Encoding.UTF8.GetBytes(s);
			return BinaryToHex(hash.Compute(data));
		}

		public static byte[] GenerateSalt(this IHashFunction hash) {
			int byteLength = (hash.HashSize / 2) / 8;
			byte[] buf = new byte[byteLength];
			var rng = new RNGCryptoServiceProvider();
			rng.GetBytes(buf);
			return buf;
		}

		public static string GenerateSaltString(this IHashFunction hash) {
			return Convert.ToBase64String(hash.GenerateSalt());
		}

		private static string BinaryToHex(byte[] data) {
			char[] hex = new char[data.Length * 2];

			for (int iter = 0; iter &lt; data.Length; iter++) {
				byte hexChar = ((byte)(data[iter] &gt;&gt; 4));
				hex[iter * 2] = (char)(hexChar &gt; 9 ? hexChar + 0x37 : hexChar + 0x30);
				hexChar = ((byte)(data[iter] &amp; 0xF));
				hex[(iter * 2) + 1] = (char)(hexChar &gt; 9 ? hexChar + 0x37 : hexChar + 0x30);
			}
			return new string(hex);
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[29,4,29,78,0],[33,4,33,96,0],[37,4,37,78,0],[41,4,41,45,0],[42,4,42,69,0],[43,4,43,42,0],[47,4,47,27,0],[48,4,48,47,0],[49,5,49,80,0],[51,4,51,67,0],[55,4,55,71,0],[59,4,59,20,0],[61,4,61,37,0],[62,4,62,33,0],[63,5,63,18,0],[65,4,65,38,0],[66,4,66,56,0],[67,5,67,53,0],[69,4,69,31,0],[70,5,70,17,0],[72,4,72,51,0],[73,4,73,59,0],[75,11,75,38,0],[76,10,76,20,0],[77,6,77,65,0],[78,6,78,69,0],[79,6,79,68,0],[80,6,80,63,0],[82,6,82,43,0],[83,6,83,47,0],[85,6,85,19,0],[86,11,86,21,0],[87,7,87,27,0],[88,12,88,22,0],[89,8,89,21,0],[88,37,88,40,0],[88,23,88,35,0],[86,42,86,45,0],[86,22,86,40,0],[93,6,93,31,0],[94,6,94,34,0],[95,6,95,34,0],[76,36,76,39,0],[76,21,76,34,0],[98,5,98,34,0],[99,5,99,21,0],[100,5,100,28,0],[101,5,101,21,0],[103,10,103,21,0],[104,6,104,22,0],[103,37,103,40,0],[103,22,103,35,0],[107,5,107,53,0],[108,5,108,15,0],[110,3,110,4,0],[113,4,113,78,0],[117,4,117,31,0],[119,4,119,79,0],[121,4,121,44,0],[122,5,122,18,0],[124,4,124,48,0],[128,4,128,92,0],[132,4,132,108,0],[136,4,136,98,0],[140,4,140,56,0],[141,4,141,56,0],[142,4,142,52,0],[144,4,144,70,0],[148,4,148,30,0],[149,5,149,17,0],[152,4,152,55,0],[153,5,153,18,0],[156,4,156,24,0],[157,9,157,19,0],[158,5,158,31,0],[157,34,157,37,0],[157,20,157,32,0],[160,4,160,19,0],[166,4,166,41,0],[167,4,167,43,0],[171,4,171,45,0],[172,4,172,38,0],[173,4,173,45,0],[174,4,174,22,0],[175,4,175,15,0],[179,4,179,55,0],[183,4,183,43,0],[185,9,185,22,0],[186,5,186,46,0],[187,5,187,75,0],[188,5,188,42,0],[189,5,189,81,0],[185,43,185,49,0],[185,23,185,41,0],[191,4,191,27,0]]);
    </script>
  </body>
</html>