<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.index\indexrangeset.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;

using Deveel.Data.Sql;
using Deveel.Data.Sql.Expressions;

namespace Deveel.Data.Index {
	public sealed class IndexRangeSet {
		private readonly List&lt;IndexRange&gt; ranges;

		public IndexRangeSet()
			: this(new[] {IndexRange.FullRange}) {
		}

		private IndexRangeSet(IEnumerable&lt;IndexRange&gt; ranges) {
			this.ranges = new List&lt;IndexRange&gt;(ranges);
		}

		private static IndexRange IntersectOn(IndexRange range, SqlExpressionType op, DataObject value, bool nullCheck) {
			var start = range.StartValue;
			var startPosition = range.StartOffset;
			var end = range.EndValue;
			var endPosition = range.EndOffset;

			bool inclusive = op == SqlExpressionType.Is ||
			                 op == SqlExpressionType.Equal ||
			                 op == SqlExpressionType.GreaterOrEqualThan ||
			                 op == SqlExpressionType.SmallerOrEqualThan;

			if (op == SqlExpressionType.Is ||
			    op == SqlExpressionType.Equal ||
			    op == SqlExpressionType.GreaterThan ||
			    op == SqlExpressionType.GreaterOrEqualThan) {
				// With this operator, NULL values must return null.
				if (nullCheck &amp;&amp; value.IsNull) {
					return IndexRange.Null;
				}

				if (start.Equals(IndexRange.FirstInSet)) {
					start = value;
					startPosition = inclusive ? RangeFieldOffset.FirstValue : RangeFieldOffset.AfterLastValue;
				} else {
					int c = value.CompareTo(start);
					if ((c == 0 &amp;&amp; startPosition == RangeFieldOffset.FirstValue) || c &gt; 0) {
						start = value;
						startPosition = inclusive ? RangeFieldOffset.FirstValue : RangeFieldOffset.AfterLastValue;
					}
				}
			}

			if (op == SqlExpressionType.Is ||
			    op == SqlExpressionType.Equal ||
			    op == SqlExpressionType.SmallerThan ||
			    op == SqlExpressionType.SmallerOrEqualThan) {
				// With this operator, NULL values must return null.
				if (nullCheck &amp;&amp; value.IsNull) {
					return IndexRange.Null;
				}

				// If start is first in set, then we have to change it to after NULL
				if (nullCheck &amp;&amp; start.Equals(IndexRange.FirstInSet)) {
					start = DataObject.Null();
					startPosition = RangeFieldOffset.AfterLastValue;
				}

				if (end.Equals(IndexRange.LastInSet)) {
					end = value;
					endPosition = inclusive ? RangeFieldOffset.LastValue : RangeFieldOffset.BeforeFirstValue;
				} else {
					int c = value.CompareTo(end);
					if ((c == 0 &amp;&amp; endPosition == RangeFieldOffset.LastValue) || c &lt; 0) {
						end = value;
						endPosition = inclusive ? RangeFieldOffset.LastValue : RangeFieldOffset.BeforeFirstValue;
					}
				}
			}

			// If start and end are not null types (if either are, then it means it
			// is a placeholder value meaning start or end of set).
			if (!start.Equals(IndexRange.FirstInSet) &amp;&amp; 
				!end.Equals(IndexRange.LastInSet)) {
				// If start is higher than end, return null
				int c = start.CompareTo(end);
				if ((c == 0 &amp;&amp; (startPosition == RangeFieldOffset.AfterLastValue ||
				                endPosition == RangeFieldOffset.BeforeFirstValue)) ||
				    c &gt; 0) {
					return IndexRange.Null;
				}
			}

			// The new intersected range
			return new IndexRange(startPosition, start, endPosition, end);
		}

		/// &lt;summary&gt;
		/// Returns true if the two SelectableRange ranges intersect.
		/// &lt;/summary&gt;
		private static bool IntersectedBy(IndexRange range1, IndexRange range2) {
			var startFlag1 = range1.StartOffset;
			var start1 = range1.StartValue;
			var endFlag1 = range1.EndOffset;
			var end1 = range1.EndValue;

			var startFlag2 = range2.StartOffset;
			var start2 = range2.StartValue;
			var endFlag2 = range2.EndOffset;
			var end2 = range2.EndValue;

			var startCell1 = start1.Equals(IndexRange.FirstInSet) ? null : start1;
			var endCell1 = end1.Equals(IndexRange.LastInSet) ? null : end1;
			var startCell2 = start2.Equals(IndexRange.FirstInSet) ? null : start2;
			var endCell2 = end2.Equals(IndexRange.LastInSet) ? null : end2;

			bool intersect1 = false;
			if (startCell1 != null &amp;&amp; endCell2 != null) {
				int c = startCell1.CompareTo(endCell2);
				if (c &lt; 0 ||
				    (c == 0 &amp;&amp; (startFlag1 == RangeFieldOffset.FirstValue ||
				                endFlag2 == RangeFieldOffset.LastValue))) {
					intersect1 = true;
				}
			} else {
				intersect1 = true;
			}

			bool intersect2 = false;
			if (startCell2 != null &amp;&amp; endCell1 != null) {
				int c = startCell2.CompareTo(endCell1);
				if (c &lt; 0 ||
				    (c == 0 &amp;&amp; (startFlag2 == RangeFieldOffset.FirstValue ||
				                endFlag1 == RangeFieldOffset.LastValue))) {
					intersect2 = true;
				}
			} else {
				intersect2 = true;
			}

			return (intersect1 &amp;&amp; intersect2);
		}

		/// &lt;summary&gt;
		/// Alters the first range so it encompasses the second range.
		/// &lt;/summary&gt;
		/// &lt;remarks&gt;
		/// This assumes that range1 intersects range2.
		/// &lt;/remarks&gt;
		private static IndexRange ChangeRangeSizeToEncompass(IndexRange range1, IndexRange range2) {
			var startPosition1 = range1.StartOffset;
			var start1 = range1.StartValue;
			var endPosition1 = range1.EndOffset;
			var end1 = range1.EndValue;

			var startPosition2 = range2.StartOffset;
			var start2 = range2.StartValue;
			var endPosition2 = range2.EndOffset;
			var end2 = range2.EndValue;

			if (!start1.Equals(IndexRange.FirstInSet)) {
				if (!start2.Equals(IndexRange.FirstInSet)) {
					var cell = start1;
					int c = cell.CompareTo(start2);
					if (c &gt; 0 ||
					    c == 0 &amp;&amp; startPosition1 == RangeFieldOffset.AfterLastValue &amp;&amp;
					    startPosition2 == RangeFieldOffset.FirstValue) {
						start1 = start2;
						startPosition1 = startPosition2;
					}
				} else {
					start1 = start2;
					startPosition1 = startPosition2;
				}
			}

			if (!end1.Equals(IndexRange.LastInSet)) {
				if (!end2.Equals(IndexRange.LastInSet)) {
					var cell = end1;
					int c = cell.CompareTo(end2);
					if (c &lt; 0 ||
					    c == 0 &amp;&amp; endPosition1 == RangeFieldOffset.BeforeFirstValue &amp;&amp;
					    endPosition2 == RangeFieldOffset.LastValue) {
						end1 = end2;
						endPosition1 = endPosition2;
					}
				} else {
					end1 = end2;
					endPosition1 = endPosition2;
				}
			}

			return new IndexRange(startPosition1, start1, endPosition1, end1);
		}

		public IndexRangeSet Intersect(SqlExpressionType op, DataObject value) {
			lock (this) {
				int sz = ranges.Count;
				var list = ranges.GetRange(0, sz);

				if (op.IsSubQuery())
					op = op.SubQueryPlainType();

				if (op == SqlExpressionType.Equal ||
				    op == SqlExpressionType.IsNot) {
					bool nullCheck = op == SqlExpressionType.NotEqual;
					int j = 0;
					while (j &lt; sz) {
						var range = list[j];
						var leftRange = IntersectOn(range, SqlExpressionType.SmallerThan, value, nullCheck);
						var rightRange = IntersectOn(range, SqlExpressionType.GreaterThan, value, nullCheck);
						list.RemoveAt(j);
						if (leftRange != IndexRange.Null) {
							list.Add(leftRange);
						}
						if (rightRange != IndexRange.Null) {
							list.Add(rightRange);
						}
						j++;
					}

					return new IndexRangeSet(list);
				} else {
					bool nullCheck = op != SqlExpressionType.Is;
					int j = 0;
					while (j &lt; sz) {
						var range = list[j];
						range = IntersectOn(range, op, value, nullCheck);
						if (range == IndexRange.Null) {
							list.RemoveAt(j);
						} else {
							list[j] = range;
						}
						j++;
					}

					return new IndexRangeSet(list);
				}
			}
		}

		/// &lt;summary&gt;
		/// Unions the current range set with the given range set.
		/// &lt;/summary&gt;
		public IndexRangeSet Union(IndexRangeSet unionTo) {
			lock (this) {
				var rangeSet = new List&lt;IndexRange&gt;(ranges);
				var inputSet = unionTo.ranges;

				int inSz = inputSet.Count;
				int n = 0;
				while (n &lt; inSz) {
					var inRange = inputSet[n];
					int sz = rangeSet.Count;
					var i = rangeSet.GetRange(0, sz);
					int j = 0;
					while (j &lt; i.Count) {
						var range = i[j];
						if (IntersectedBy(inRange, range)) {
							i.RemoveAt(j);
							inRange = ChangeRangeSizeToEncompass(inRange, range);
						}
						j++;
					}

					// Insert into sorted position
					var startPoint = inRange.StartOffset;
					var start = inRange.StartValue;
					var endPoint = inRange.EndOffset;
					var end = inRange.EndValue;

					if (start == IndexRange.FirstInSet) {
						rangeSet.Insert(0, inRange);
					} else {
						var startCell = start;
						i = rangeSet.GetRange(0, rangeSet.Count);
						j = 0;
						while (j &lt; i.Count) {
							var range = i[j];
							var curStart = range.StartValue;
							if (!curStart.Equals(IndexRange.FirstInSet)) {
								if (curStart.CompareTo(startCell) &gt; 0) {
									i[j] = i[j - 1];
									break;
								}
							}
							j++;
						}
						i.Add(inRange);
					}
					n++;
				}

				return new IndexRangeSet(rangeSet);
			}
		}

		public IndexRange[] ToArray() {
			lock (this) {
				return ranges.ToArray();
			}
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[27,3,28,40,0],[29,3,29,4,0],[31,3,31,56,0],[32,4,32,47,0],[33,3,33,4,0],[36,4,36,33,0],[37,4,37,42,0],[38,4,38,29,0],[39,4,39,38,0],[41,4,44,64,0],[46,4,49,51,0],[51,5,51,35,0],[52,6,52,29,0],[55,5,55,45,0],[56,6,56,20,0],[57,6,57,96,0],[59,6,59,37,0],[60,6,60,76,0],[61,7,61,21,0],[62,7,62,97,0],[67,4,70,51,0],[72,5,72,35,0],[73,6,73,29,0],[77,5,77,58,0],[78,6,78,32,0],[79,6,79,54,0],[82,5,82,42,0],[83,6,83,18,0],[84,6,84,95,0],[86,6,86,35,0],[87,6,87,73,0],[88,7,88,19,0],[89,7,89,96,0],[96,4,97,39,0],[99,5,99,34,0],[100,5,102,15,0],[103,6,103,29,0],[108,4,108,66,0],[115,4,115,40,0],[116,4,116,35,0],[117,4,117,36,0],[118,4,118,31,0],[120,4,120,40,0],[121,4,121,35,0],[122,4,122,36,0],[123,4,123,31,0],[125,4,125,74,0],[126,4,126,67,0],[127,4,127,74,0],[128,4,128,67,0],[130,4,130,28,0],[131,4,131,47,0],[132,5,132,44,0],[133,5,135,62,0],[136,6,136,24,0],[139,5,139,23,0],[142,4,142,28,0],[143,4,143,47,0],[144,5,144,44,0],[145,5,147,62,0],[148,6,148,24,0],[151,5,151,23,0],[154,4,154,38,0],[164,4,164,44,0],[165,4,165,35,0],[166,4,166,40,0],[167,4,167,31,0],[169,4,169,44,0],[170,4,170,35,0],[171,4,171,40,0],[172,4,172,31,0],[174,4,174,46,0],[175,5,175,47,0],[176,6,176,24,0],[177,6,177,37,0],[178,6,180,56,0],[181,7,181,23,0],[182,7,182,39,0],[185,6,185,22,0],[186,6,186,38,0],[190,4,190,43,0],[191,5,191,44,0],[192,6,192,22,0],[193,6,193,35,0],[194,6,196,53,0],[197,7,197,19,0],[198,7,198,35,0],[201,6,201,18,0],[202,6,202,34,0],[206,4,206,70,0],[210,4,210,15,0],[211,5,211,27,0],[212,5,212,39,0],[214,5,214,25,0],[215,6,215,34,0],[217,5,218,39,0],[219,6,219,56,0],[220,6,220,16,0],[222,7,222,27,0],[223,7,223,91,0],[224,7,224,92,0],[225,7,225,24,0],[226,7,226,40,0],[227,8,227,28,0],[229,7,229,41,0],[230,8,230,29,0],[232,7,232,11,0],[221,6,221,20,0],[235,6,235,37,0],[237,6,237,50,0],[238,6,238,16,0],[240,7,240,27,0],[241,7,241,56,0],[242,7,242,36,0],[243,8,243,25,0],[245,8,245,24,0],[247,7,247,11,0],[239,6,239,20,0],[250,6,250,37,0],[253,3,253,4,0],[259,4,259,15,0],[260,5,260,49,0],[261,5,261,35,0],[263,5,263,31,0],[264,5,264,15,0],[266,6,266,32,0],[267,6,267,30,0],[268,6,268,39,0],[269,6,269,16,0],[271,7,271,24,0],[272,7,272,41,0],[273,8,273,22,0],[274,8,274,61,0],[276,7,276,11,0],[270,6,270,25,0],[280,6,280,43,0],[281,6,281,37,0],[282,6,282,39,0],[283,6,283,33,0],[285,6,285,41,0],[286,7,286,35,0],[288,7,288,29,0],[289,7,289,48,0],[290,7,290,13,0],[292,8,292,25,0],[293,8,293,40,0],[294,8,294,52,0],[295,9,295,47,0],[296,10,296,26,0],[297,10,297,16,0],[300,8,300,12,0],[291,7,291,26,0],[302,7,302,22,0],[304,6,304,10,0],[265,5,265,21,0],[307,5,307,40,0],[309,3,309,4,0],[312,4,312,15,0],[313,5,313,29,0],[315,3,315,4,0]]);
    </script>
  </body>
</html>