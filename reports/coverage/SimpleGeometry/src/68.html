<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.dbsystem\tablesourcecomposite.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

using Deveel.Data.Index;
using Deveel.Data.Sql;
using Deveel.Data.Store;
using Deveel.Data.Transactions;

namespace Deveel.Data.DbSystem {
	class TableSourceComposite : IDisposable {
		private readonly object commitLock = new object();
		private Dictionary&lt;int, TableSource&gt; tableSources;

		private List&lt;TransactionObjectState&gt; objectStates; 

		private IStoreSystem tempStoreSystem;
		private IStore lobStore;
		private IStore stateStore;

		private const string StateStorePostfix = &quot;_sf&quot;;

		public const string ObjectStoreName = &quot;lob_store&quot;;

		public TableSourceComposite(Database database) {
			Database = database;

			tempStoreSystem = new InMemoryStorageSystem();
			objectStates = new List&lt;TransactionObjectState&gt;();

			StateStoreName = String.Format(&quot;{0}_{1}&quot;, database.Name(), StateStorePostfix);

			Setup();
		}

		~TableSourceComposite() {
			Dispose(false);
		}

		public Database Database { get; private set; }

		public IDatabaseContext DatabaseContext {
			get { return Database.Context; }
		}

		private IStoreSystem StoreSystem {
			get { return DatabaseContext.StoreSystem; }
		}

		public int CurrentCommitId { get; private set; }

		private bool IsReadOnly {
			get { return Database.Context.ReadOnly(); }
		}

		private bool IsClosed {
			get { return tableSources == null; }
		}

		private TableStateStore StateStore { get; set; }

		private string StateStoreName { get; set; }

		private IObjectStore LargeObjectStore { get; set; }

		private void ReadVisibleTables() {
			lock (commitLock) {
				var tables = StateStore.GetVisibleList();

				// For each visible table
				foreach (var resource in tables) {
					var tableId = resource.TableId;
					var sourceName = resource.SourceName;

					// TODO: add a table source type?

					// Load the master table from the resource information
					var source = LoadTableSource(tableId, sourceName);

					if (source == null)
						throw new InvalidOperationException(String.Format(&quot;Table {0} was not found.&quot;, sourceName));

					source.Open();

					tableSources.Add(tableId, source);
				}
			}
		}

		private void ReadDroppedTables() {
			lock (commitLock) {
				// The list of all dropped tables from the state file
				var tables = StateStore.GetDeleteList();

				// For each visible table
				foreach (var resource in tables) {
					int tableId =resource.TableId;
					string tableName = resource.SourceName;

					// Load the master table from the resource information
					var source = LoadTableSource(tableId, tableName);

					// File wasn&#39;t found so remove from the delete resources
					if (source == null) {
						StateStore.RemoveDeleteResource(tableName);
					} else {
						source.Open();

						// Add the table to the table list
						tableSources.Add(tableId, source);
					}
				}

				StateStore.Flush();
			}
		}

		private TableSource LoadTableSource(int tableId, string tableName) {
			var source = new TableSource(this, StoreSystem, LargeObjectStore, tableId, tableName);
			if (!source.Exists())
				return null;

			return source;
		}

		private void MarkUncommitted(int tableId) {
			var masterTable = GetTableSource(tableId);
			StateStore.AddDeleteResource(new TableStateStore.TableState(tableId, masterTable.SourceName));
		}

		//public ITransaction CreateTransaction(TransactionIsolation isolation) {
		//	var thisCommittedTables = new List&lt;TableSource&gt;();

		//	// Don&#39;t let a commit happen while we are looking at this.
		//	lock (commitLock) {
		//		long thisCommitId = CurrentCommitId;
		//		var committedTableList = StateStore.GetVisibleList();
		//		thisCommittedTables.AddRange(committedTableList.Select(resource =&gt; GetTableSource(resource.TableId)));

		//		// Create a set of IIndexSet for all the tables in this transaction.
		//		var indexInfo = (thisCommittedTables.Select(mtable =&gt; mtable.CreateIndexSet())).ToList();

		//		// Create the transaction and record it in the open transactions list.
		//		var t = new Transaction(this, thisCommitId, isolation, thisCommittedTables, indexInfo);
		//		openTransactions.AddTransaction(t);
		//		return t;
		//	}

		//}

		private void Dispose(bool disposing) {
			if (disposing) {
				Close();

				if (lobStore != null)
					lobStore.Dispose();
				if (stateStore != null)
					stateStore.Dispose();

				if (tempStoreSystem != null)
					tempStoreSystem.Dispose();

				tempStoreSystem = null;
				lobStore = null;
			}
		}

		public void Dispose() {
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		private void Setup() {
			lock (this) {
				CurrentCommitId = 0;
				tableSources = new Dictionary&lt;int, TableSource&gt;();				
			}
		}

		private void InitObjectStore() {
			// Does the file already exist?
			bool blobStoreExists = StoreSystem.StoreExists(ObjectStoreName);
			// If the blob store doesn&#39;t exist and we are read_only, we can&#39;t do
			// anything further so simply return.
			if (!blobStoreExists &amp;&amp; IsReadOnly) {
				return;
			}

			// The blob store,
			if (blobStoreExists) {
				lobStore = StoreSystem.OpenStore(ObjectStoreName);
			} else {
				lobStore = StoreSystem.CreateStore(ObjectStoreName);
			}

			try {
				lobStore.LockForWrite();

				// TODO: have multiple BLOB stores
				LargeObjectStore = new ObjectStore(0, lobStore);

				// Get the 64 byte fixed area
				var fixedArea = lobStore.GetArea(-1, false);
				// If the blob store didn&#39;t exist then we need to create it here,
				if (!blobStoreExists) {
					long headerP = LargeObjectStore.Create();
					fixedArea.WriteInt8(headerP);
					fixedArea.Flush();
				} else {
					// Otherwise we need to initialize the blob store
					long headerP = fixedArea.ReadInt8();
					LargeObjectStore.Open(headerP);
				}
			} finally {
				lobStore.UnlockForWrite();
			}
		}

		private void CleanUp() {
			lock (commitLock) {
				if (IsClosed)
					return;

				// If no open transactions on the database, then clean up.
				if (Database.OpenTransactions.Count == 0) {
					var deleteList = StateStore.GetDeleteList().ToArray();
					if (deleteList.Length &gt; 0) {
						int dropCount = 0;

						for (int i = deleteList.Length - 1; i &gt;= 0; --i) {
							var tableName = deleteList[i].SourceName;
							CloseTable(tableName, true);
						}

						for (int i = deleteList.Length - 1; i &gt;= 0; --i) {
							string tableName = deleteList[i].SourceName;
							bool dropped = CloseAndDropTable(tableName);
							// If we managed to drop the table, remove from the list.
							if (dropped) {
								StateStore.RemoveDeleteResource(tableName);
								++dropCount;
							}
						}

						// If we dropped a table, commit an update to the conglomerate state.
						if (dropCount &gt; 0)
							StateStore.Flush();
					}
				}
			}
		}

		private bool CloseAndDropTable(string tableFileName) {
			// Find the table with this file name.
			int? tableId = null;
			foreach (var source in tableSources.Values) {
				if (source.StoreIdentity.Equals(tableFileName)) {
					if (source.IsRootLocked)
						return false;

					if (!source.Drop())
						return false;

					tableId = source.TableId;
				}
			}

			if (tableId != null)
				tableSources.Remove(tableId.Value);

			return false;
		}

		private void CloseTable(string sourceName, bool pendingDrop) {
			// Find the table with this file name.
			foreach (var source in tableSources.Values) {
				if (source.SourceName.Equals(sourceName)) {
					if (source.IsRootLocked)
						break;

					source.Close(pendingDrop);
					break;
				}
			}
		}

		public bool Exists() {
			return StoreSystem.StoreExists(StateStoreName);
		}

		public void Open() {
			if (!Exists())
				throw new IOException(&quot;Table composite does not exist&quot;);

			// Check the file Lock
			if (!IsReadOnly) {
				// Obtain the Lock (generate error if this is not possible)
				StoreSystem.Lock(StateStoreName);
			}

			// Open the state store
			stateStore = StoreSystem.OpenStore(StateStoreName);
			StateStore = new TableStateStore(stateStore);

			// Get the fixed 64 byte area.
			var fixedArea = stateStore.GetArea(-1);
			long headP = fixedArea.ReadInt8();
			StateStore.Open(headP);

			Setup();

			InitObjectStore();

			ReadVisibleTables();
			ReadDroppedTables();

			CleanUp();
		}

		public void Create() {
			MinimalCreate();

			// Initialize the conglomerate system tables.
			InitSystemSchema();

			// Commit the state
			StateStore.Flush();
		}

		private void InitSystemSchema() {
			using (var transaction = Database.DoCreateTransaction(TransactionIsolation.Serializable)) {
				try {
					SystemSchema.Setup(transaction);
					transaction.Commit();
				} catch (Exception ex) {
					throw new ApplicationException(&quot;Transaction Exception initializing tables.&quot;, ex);
				}
			}
		}

		internal void MinimalCreate() {
			if (Exists())
				throw new IOException(&quot;Composite already exists&quot;);

			// Lock the store system (generates an IOException if exclusive Lock
			// can not be made).
			if (!IsReadOnly) {
				StoreSystem.Lock(StateStoreName);
			}

			// Create/Open the state store
			stateStore = StoreSystem.CreateStore(StateStoreName);
			try {
				stateStore.LockForWrite();

				StateStore = new TableStateStore(stateStore);
				long headP = StateStore.Create();
				// Get the fixed area
				var fixedArea = stateStore.GetArea(-1);
				fixedArea.WriteInt8(headP);
				fixedArea.Flush();
			} finally {
				stateStore.UnlockForWrite();
			}

			Setup();

			// Init the conglomerate blob store
			InitObjectStore();

			// Create the system table (but don&#39;t initialize)
			CreateSystemSchema();
		}

		private void CreateSystemSchema() {
			// Create the transaction
			ITransaction transaction = null;

			try {
				transaction = Database.DoCreateTransaction(TransactionIsolation.Serializable);
				transaction.CreateSystemSchema();

				// Commit and close the transaction.
				transaction.Commit();
				transaction = null;
			} catch (TransactionException e) {
				throw new ApplicationException(&quot;Transaction Exception creating composite.&quot;, e);
			} finally {
				if (transaction != null)
					transaction.Rollback();
			}
		}

		public void Close() {
			lock (commitLock) {
				CleanUp();

				StoreSystem.SetCheckPoint();

				// Go through and close all the committed tables.
				foreach (var source in tableSources.Values) {
					source.Close(false);
				}

				StateStore.Flush();
				StoreSystem.CloseStore(stateStore);

				tableSources = null;
			}

			// Release the storage system
			StoreSystem.Unlock(StateStoreName);

			if (LargeObjectStore != null)
				StoreSystem.CloseStore(lobStore);
		}

		public void Delete() {
			lock (commitLock) {
				// We possibly have things to clean up.
				CleanUp();

				// Go through and delete and close all the committed tables.
				foreach (var source in tableSources.Values)
					source.Drop();

				// Delete the state file
				StateStore.Flush();
				StoreSystem.CloseStore(stateStore);
				StoreSystem.DeleteStore(stateStore);

				// Delete the blob store
				if (LargeObjectStore != null) {
					StoreSystem.CloseStore(lobStore);
					StoreSystem.DeleteStore(lobStore);
				}

				tableSources = null;
			}

			// Release the storage system.
			StoreSystem.Unlock(StateStoreName);
		}

		internal TableSource CreateTableSource(TableInfo tableInfo, bool temporary) {
			lock (commitLock) {
				try {
					int tableId = NextTableId();

					// Create the object.
					var storeSystem = StoreSystem;
					if (temporary)
						storeSystem = tempStoreSystem;

					var source = new TableSource(this, storeSystem, LargeObjectStore, tableId, tableInfo.TableName.FullName);
					source.Create(tableInfo);

					tableSources.Add(tableId, source);

					if (!temporary) {
						MarkUncommitted(tableId);

						StateStore.Flush();
					}

					// And return it.
					return source;
				} catch (IOException e) {
					throw new ApplicationException(String.Format(&quot;Unable to create source for table &#39;{0}&#39;.&quot;, tableInfo.TableName), e);
				}
			}
		}

		internal TableSource GetTableSource(int tableId) {
			lock (commitLock) {
				if (tableSources == null)
					return null;

				TableSource source;
				if (!tableSources.TryGetValue(tableId, out source))
					throw new ObjectNotFoundException(
						String.Format(&quot;Could not find any source for table with id {0} in this composite.&quot;, tableId));

				return source;
			}
		}

		public int NextTableId() {
			return StateStore.NextTableId();
		}

		private void OnCommitModification(ObjectName objName, IEnumerable&lt;int&gt; addedRows, IEnumerable&lt;int&gt; removedRows) {
			
		}

		internal void Commit(Transaction transaction, IList&lt;TableSource&gt; visibleTables,
						   IEnumerable&lt;TableSource&gt; selectedFromTables,
						   IEnumerable&lt;IMutableTable&gt; touchedTables, TransactionRegistry journal, Action&lt;TableCommitInfo&gt; commitActions) {

			var state = new TransactionWork(this, transaction, selectedFromTables, touchedTables, journal);

			// Exit early if nothing changed (this is a Read-only transaction)
			if (!state.HasChanges) {
				CloseTransaction(state.Transaction);
				return;
			}

			lock (commitLock) {
				var changedTablesList = state.Commit(objectStates, commitActions);

				// Flush the journals up to the minimum commit id for all the tables
				// that this transaction changed.
				long minCommitId = Database.OpenTransactions.MinimumCommitId(null);
				foreach (var master in changedTablesList) {
					master.MergeChanges(minCommitId);
				}
				int nsjsz = objectStates.Count;
				for (int i = nsjsz - 1; i &gt;= 0; --i) {
					var namespaceJournal = objectStates[i];
					// Remove if the commit id for the journal is less than the minimum
					// commit id
					if (namespaceJournal.CommitId &lt; minCommitId) {
						objectStates.RemoveAt(i);
					}
				}

				// Set a check point in the store system.  This means that the
				// persistance state is now stable.
				StoreSystem.SetCheckPoint();
			}
		}

		internal void Rollback(Transaction transaction, IList&lt;IMutableTable&gt; touchedTables, TransactionRegistry journal) {
			// Go through the journal.  Any rows added should be marked as deleted
			// in the respective master table.

			// Get individual journals for updates made to tables in this
			// transaction.
			// The list MasterTableJournal
			var journalList = new List&lt;TableEventRegistry&gt;();
			for (int i = 0; i &lt; touchedTables.Count; ++i) {
				var tableJournal = touchedTables[i].EventRegistry;
				if (tableJournal.EventCount &gt; 0) // Check the journal has entries.
					journalList.Add(tableJournal);
			}

			var changedTables = journalList.ToArray();

			lock (commitLock) {
				try {
					// For each change to each table,
					foreach (var changeJournal in changedTables) {
						// The table the changes were made to.
						int tableId = changeJournal.TableId;
						// Get the master table with this table id.
						var master = GetTableSource(tableId);
						// Commit the rollback on the table.
						master.RollbackTransactionChange(changeJournal);
					}
				} finally {
					// Notify the conglomerate that this transaction has closed.
					CloseTransaction(transaction);
				}
			}
		}

		internal TableSource CopySourceTable(TableSource tableSource, IIndexSet indexSet) {
			lock (commitLock) {
				try {
					// The unique id that identifies this table,
					int tableId = NextTableId();
					var sourceName = tableSource.SourceName;

					// Create the object.
					var masterTable = new TableSource(this, StoreSystem, LargeObjectStore, tableId, sourceName);

					masterTable.CopyFrom(tableId, tableSource, indexSet);

					// Add to the list of all tables.
					tableSources.Add(tableId, masterTable);

					// Add this to the list of deleted tables,
					MarkUncommitted(tableId);

					// Commit this
					StateStore.Flush();

					// And return it.
					return masterTable;
				} catch (IOException e) {
					throw new Exception(String.Format(&quot;Unable to copy source table &#39;{0}&#39; because of an error.&quot;, tableSource.TableInfo.TableName), e);
				}
			}
		}

		internal ITransaction CreateTransaction(TransactionIsolation isolation) {
			var thisCommittedTables = new List&lt;TableSource&gt;();

			// Don&#39;t let a commit happen while we are looking at this.
			lock (commitLock) {
				long thisCommitId = CurrentCommitId;
				var committedTableList = StateStore.GetVisibleList();
				thisCommittedTables.AddRange(committedTableList.Select(resource =&gt; GetTableSource(resource.TableId)));

				// Create a set of IIndexSet for all the tables in this transaction.
				var indexInfo = (thisCommittedTables.Select(mtable =&gt; mtable.CreateIndexSet())).ToList();

				// Create the transaction and record it in the open transactions list.
				return new Transaction(Database, thisCommitId, isolation, thisCommittedTables, indexInfo);
			}
		}

		private Action&lt;TableCommitInfo&gt; tableCommitCallback; 

		internal void RegisterOnCommit(Action&lt;TableCommitInfo&gt; action) {
			if (tableCommitCallback == null) {
				tableCommitCallback = action;
			} else {
				tableCommitCallback = (Action&lt;TableCommitInfo&gt;) Delegate.Combine(tableCommitCallback, action);
			}
		}

		internal void UnregisterOnCommit(Action&lt;TableCommitInfo&gt; action) {
			tableCommitCallback = Delegate.Remove(tableCommitCallback, action) as Action&lt;TableCommitInfo&gt;;
		}

		internal void CloseTransaction(ITransaction transaction) {
			bool lastTransaction;
			// Closing must happen under a commit Lock.
			lock (commitLock) {
				Database.OpenTransactions.RemoveTransaction(transaction);
				// Increment the commit id.
				++CurrentCommitId;
				// Was that the last transaction?
				lastTransaction = Database.OpenTransactions.Count == 0;
			}

			// If last transaction then schedule a clean up event.
			if (lastTransaction) {
				try {
					CleanUp();
				} catch (IOException e) {
					// TODO: Register the error ...
				}
			}
		}

		internal void CommitToTables(IEnumerable&lt;int&gt; createdTables, IEnumerable&lt;int&gt; droppedTables) {
			// Add created tables to the committed tables list.
			foreach (int createdTable in createdTables) {
				// For all created tables, add to the visible list and remove from the
				// delete list in the state store.
				var t = GetTableSource(createdTable);
				var resource = new TableStateStore.TableState(t.TableId, t.SourceName);
				StateStore.AddVisibleResource(resource);
				StateStore.RemoveDeleteResource(resource.SourceName);
			}

			// Remove dropped tables from the committed tables list.
			foreach (int droppedTable in droppedTables) {
				// For all dropped tables, add to the delete list and remove from the
				// visible list in the state store.
				var t = GetTableSource(droppedTable);
				var resource = new TableStateStore.TableState(t.TableId, t.SourceName);
				StateStore.AddDeleteResource(resource);
				StateStore.RemoveVisibleResource(resource.SourceName);
			}

			try {
				StateStore.Flush();
			} catch (IOException e) {
				throw new ApplicationException(&quot;IO Error: &quot; + e.Message, e);
			}
		}

		internal bool ContainsVisibleResource(int resourceId) {
			return StateStore.ContainsVisibleResource(resourceId);
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[98,7,98,98,0],[113,14,113,26,0],[114,6,114,36,0],[115,6,115,45,0],[118,6,118,55,0],[121,6,121,25,0],[122,7,122,50,0],[124,7,124,21,0],[127,7,127,41,0],[138,5,138,17,0],[170,5,170,13,0],[172,5,172,26,0],[173,6,173,25,0],[174,5,174,28,0],[175,6,175,27,0],[177,5,177,33,0],[178,6,178,32,0],[180,5,180,28,0],[181,5,181,21,0],[186,4,186,18,0],[187,4,187,30,0],[188,3,188,4,0],[203,5,203,12,0],[239,6,239,13,0],[257,9,257,52,0],[258,9,258,21,0],[264,8,264,27,0],[275,6,275,30,0],[276,7,276,20,0],[278,6,278,25,0],[279,7,279,20,0],[281,6,281,31,0],[286,5,286,40,0],[289,3,289,4,0],[310,5,310,61,0],[352,7,352,27,0],[353,6,353,87,0],[360,5,360,55,0],[403,6,403,36,0],[404,5,404,84,0],[407,6,407,29,0],[436,4,436,21,0],[438,5,438,15,0],[441,28,441,47,0],[441,14,441,24,0],[442,6,442,20,0],[441,25,441,27,0],[445,5,445,24,0],[446,5,446,40,0],[447,5,447,41,0],[450,5,450,34,0],[451,6,451,39,0],[452,6,452,40,0],[455,5,455,25,0],[459,4,459,39,0],[460,3,460,4,0],[470,7,470,37,0],[485,7,485,28,0],[486,6,486,120,0],[494,6,494,18,0],[498,6,499,101,0],[511,3,511,4,0],[521,5,521,41,0],[522,5,522,12,0],[585,4,585,21,0],[588,6,588,34,0],[589,6,589,46,0],[592,6,592,98,0],[594,6,594,59,0],[597,6,597,45,0],[600,6,600,31,0],[603,6,603,25,0],[606,6,606,25,0],[607,7,607,28,0],[608,6,608,135,0],[611,3,611,4,0],[633,4,633,36,0],[634,5,634,34,0],[636,5,636,99,0],[638,3,638,4,0],[641,4,641,98,0],[642,3,642,4,0],[659,7,659,28,0],[677,13,677,29,0],[680,5,680,42,0],[681,5,681,76,0],[682,5,682,44,0],[683,5,683,59,0],[688,6,688,27,0],[689,5,689,65,0],[29,3,29,53,1],[42,3,42,49,1],[43,4,43,24,1],[45,4,45,50,1],[46,4,46,54,1],[48,4,48,82,1],[50,4,50,12,1],[51,3,51,4,1],[54,4,54,19,1],[55,3,55,4,1],[60,10,60,34,1],[64,10,64,45,1],[70,10,70,45,1],[74,10,74,38,1],[84,4,84,21,1],[85,5,85,46,1],[88,30,88,36,1],[88,14,88,26,1],[89,6,89,37,1],[90,6,90,43,1],[95,6,95,56,1],[97,6,97,25,1],[100,6,100,20,1],[102,6,102,40,1],[88,27,88,29,1],[105,3,105,4,1],[108,4,108,21,1],[110,5,110,45,1],[113,30,113,36,1],[113,27,113,29,1],[131,5,131,24,1],[133,3,133,4,1],[136,4,136,90,1],[137,4,137,25,1],[140,4,140,18,1],[144,4,144,46,1],[145,4,145,98,1],[146,3,146,4,1],[169,4,169,18,1],[183,3,183,4,1],[191,4,191,15,1],[192,5,192,25,1],[193,5,193,55,1],[195,3,195,4,1],[199,4,199,68,1],[202,4,202,39,1],[207,4,207,24,1],[208,5,208,55,1],[210,5,210,57,1],[214,5,214,29,1],[217,5,217,53,1],[220,5,220,49,1],[222,5,222,26,1],[223,6,223,47,1],[224,6,224,35,1],[225,6,225,24,1],[228,6,228,42,1],[229,6,229,37,1],[232,5,232,31,1],[234,3,234,4,1],[237,4,237,21,1],[238,5,238,18,1],[242,5,242,46,1],[243,6,243,60,1],[244,6,244,32,1],[245,7,245,25,1],[247,12,247,42,1],[248,8,248,49,1],[249,8,249,36,1],[247,51,247,54,1],[247,43,247,49,1],[252,12,252,42,1],[253,8,253,52,1],[254,8,254,52,1],[256,8,256,20,1],[252,51,252,54,1],[252,43,252,49,1],[263,7,263,25,1],[268,3,268,4,1],[272,4,272,24,1],[273,27,273,46,1],[273,13,273,23,1],[274,5,274,52,1],[273,24,273,26,1],[285,4,285,24,1],[288,4,288,17,1],[293,27,293,46,1],[293,13,293,23,1],[294,5,294,46,1],[295,6,295,30,1],[298,6,298,32,1],[299,6,299,12,1],[293,24,293,26,1],[302,3,302,4,1],[305,4,305,51,1],[309,4,309,18,1],[313,4,313,20,1],[315,5,315,38,1],[319,4,319,55,1],[320,4,320,49,1],[323,4,323,43,1],[324,4,324,38,1],[325,4,325,27,1],[327,4,327,12,1],[329,4,329,22,1],[331,4,331,24,1],[332,4,332,24,1],[334,4,334,14,1],[335,3,335,4,1],[338,4,338,20,1],[341,4,341,23,1],[344,4,344,23,1],[345,3,345,4,1],[348,11,348,92,1],[350,6,350,38,1],[351,6,351,27,1],[356,3,356,4,1],[359,4,359,17,1],[364,4,364,20,1],[365,5,365,38,1],[369,4,369,57,1],[371,5,371,31,1],[373,5,373,50,1],[374,5,374,38,1],[376,5,376,44,1],[377,5,377,32,1],[378,5,378,23,1],[380,5,380,33,1],[383,4,383,12,1],[386,4,386,22,1],[389,4,389,25,1],[390,3,390,4,1],[394,4,394,36,1],[397,5,397,83,1],[398,5,398,38,1],[401,5,401,26,1],[402,5,402,24,1],[406,5,406,29,1],[409,3,409,4,1],[412,4,412,21,1],[413,5,413,15,1],[415,5,415,33,1],[418,28,418,47,1],[418,14,418,24,1],[419,6,419,26,1],[418,25,418,27,1],[422,5,422,24,1],[423,5,423,40,1],[425,5,425,25,1],[429,4,429,39,1],[431,4,431,33,1],[432,5,432,38,1],[433,3,433,4,1],[463,4,463,21,1],[465,6,465,34,1],[468,6,468,36,1],[469,6,469,20,1],[472,6,472,111,1],[473,6,473,31,1],[475,6,475,40,1],[477,6,477,21,1],[478,7,478,32,1],[480,7,480,26,1],[484,6,484,20,1],[489,3,489,4,1],[492,4,492,21,1],[493,5,493,30,1],[497,5,497,56,1],[501,5,501,19,1],[503,3,503,4,1],[506,4,506,36,1],[517,4,517,99,1],[520,4,520,26,1],[525,4,525,21,1],[526,5,526,71,1],[530,5,530,72,1],[531,28,531,45,1],[531,14,531,24,1],[532,6,532,39,1],[531,25,531,27,1],[534,5,534,36,1],[535,10,535,28,1],[536,6,536,45,1],[539,6,539,50,1],[540,7,540,32,1],[535,37,535,40,1],[535,29,535,35,1],[546,5,546,33,1],[548,3,548,4,1],[557,4,557,53,1],[558,9,558,19,1],[559,5,559,55,1],[560,5,560,37,1],[561,6,561,36,1],[558,45,558,48,1],[558,20,558,43,1],[564,4,564,46,1],[566,4,566,21,1],[569,36,569,49,1],[569,15,569,32,1],[571,7,571,43,1],[573,7,573,44,1],[575,7,575,55,1],[569,33,569,35,1],[579,6,579,36,1],[582,3,582,4,1],[614,4,614,54,1],[617,4,617,21,1],[618,5,618,41,1],[619,5,619,58,1],[620,5,620,72,1],[620,104,620,107,1],[623,5,623,59,1],[623,82,623,94,1],[626,5,626,95,1],[628,3,628,4,1],[647,4,647,21,1],[648,5,648,62,1],[650,5,650,23,1],[652,5,652,60,1],[656,4,656,24,1],[658,6,658,16,1],[663,3,663,4,1],[667,33,667,46,1],[667,13,667,29,1],[670,5,670,42,1],[671,5,671,76,1],[672,5,672,45,1],[673,5,673,58,1],[667,30,667,32,1],[677,33,677,46,1],[677,30,677,32,1],[687,5,687,24,1],[691,3,691,4,1],[694,4,694,58,1],[620,72,620,104,1],[623,59,623,82,1]]);
    </script>
  </body>
</html>