<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.objects\sqlstring.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Deveel.Data.Sql.Objects {
	[Serializable]
	public struct SqlString : ISqlString, IEquatable&lt;SqlString&gt;, IConvertible {
		public const int MaxLength = Int16.MaxValue;

		public static readonly SqlString Null = new SqlString((char[])null);
		public static readonly SqlString Empty = new SqlString(new char[0]);

		private readonly char[] source;

		private SqlString(int codePage, char[] chars)
			: this(codePage, chars, chars == null ? 0 : chars.Length) {
		}

		private SqlString(int codePage, char[] chars, int length)
			: this() {
			CodePage = codePage;

			if (chars == null) {
				source = null;
			} else {
				if (length &gt; MaxLength)
					throw new ArgumentOutOfRangeException(&quot;length&quot;);

				source = new char[length];
				Array.Copy(chars, 0, source, 0, length);
			}			
		}

		public SqlString(char[] chars)
			: this(Encoding.Unicode.CodePage, chars, chars == null ? 0 : chars.Length) {
		}

		public SqlString(string s)
			: this(s == null ? null : s.ToCharArray()) {
		}

		int IComparable.CompareTo(object obj) {
			return CompareTo((ISqlString) obj);
		}

		int IComparable&lt;ISqlObject&gt;.CompareTo(ISqlObject other) {
			return CompareTo((ISqlString) other);
		}

		public bool IsNull {
			get { return source == null; }
		}

		public string Value {
			get { return source == null ? null : new string(source); }
		}

		public char this[long index] {
			get {
				if (index &gt; Int32.MaxValue)
					throw new ArgumentOutOfRangeException(&quot;index&quot;);

				if (source == null)
					return &#39;\0&#39;;
				if (index &gt;= Length)
					throw new ArgumentOutOfRangeException(&quot;index&quot;);

				return source[index];
			}
		}

		bool ISqlObject.IsComparableTo(ISqlObject other) {
			return other is ISqlString;
		}

		public int CompareTo(ISqlString other) {
			if (other == null)
				throw new ArgumentNullException(&quot;other&quot;);

			if (CodePage != other.CodePage)
				throw new ArgumentException(&quot;The codepage value of the other string is different.&quot;);

			if (IsNull &amp;&amp; other.IsNull)
				return 0;
			if (IsNull)
				return 1;
			if (other.IsNull)
				return -1;

			if (other is SqlString) {
				var otherString = (SqlString) other;
				return String.Compare(Value, otherString.Value, StringComparison.Ordinal);
			}

			throw new NotImplementedException(&quot;Comparison with long strng not implemented yet.&quot;);
		}

		public IEnumerator&lt;char&gt; GetEnumerator() {
			return new StringEnumerator(this);
		}

		IEnumerator IEnumerable.GetEnumerator() {
			return GetEnumerator();
		}

		public long Length {
			get { return source == null ? 0 : source.LongLength; }
		}

		public int CodePage { get; private set; }

		public TextReader GetInput() {
			var encoding = Encoding.GetEncoding(CodePage);
			var bytes = new byte[0];
			if (source != null)
				bytes = encoding.GetBytes(source);

			return new StreamReader(new MemoryStream(bytes), encoding);
		}

		public bool Equals(SqlString other) {
			if (source == null &amp;&amp; other.source == null)
				return true;

			if (source == null)
				return false;

			if (source.Length != other.source.Length)
				return false;

			for (int i = 0; i &lt; source.Length; i++) {
				var c1 = source[i];
				var c2 = other.source[i];
				if (!c1.Equals(c2))
					return false;
			}

			return true;
		}

		public override bool Equals(object obj) {
			if (obj is SqlNull &amp;&amp; IsNull)
				return true;

			return Equals((SqlString) obj);
		}

		public override int GetHashCode() {
			if (source == null)
				return 0;

			unchecked {
				int hash = 17;

				// get hash code for all items in array
				foreach (var item in source) {
					hash = hash*23 + item.GetHashCode();
				}

				return hash;
			}
		}

		public static SqlString Unicode(byte[] bytes) {
			return new SqlString(Encoding.Unicode.CodePage, Encoding.Unicode.GetChars(bytes));
		}

		public static SqlString Unicode(string s) {
			return Unicode(Encoding.Unicode.GetBytes(s));
		}

		public static SqlString BigEndianUnicode(byte[] bytes) {
			return new SqlString(Encoding.BigEndianUnicode.CodePage, Encoding.BigEndianUnicode.GetChars(bytes));
		}

		public static SqlString Ascii(byte[] bytes) {
			return new SqlString(Encoding.ASCII.CodePage, Encoding.ASCII.GetChars(bytes));
		}

		public static SqlString Ascii(string s) {
			return Ascii(Encoding.ASCII.GetBytes(s));
		}

		public static SqlString Decode(int codePage, byte[] bytes) {
			var encoding = Encoding.GetEncoding(codePage);
			return new SqlString(codePage, encoding.GetChars(bytes));
		}

		public byte[] ToByteArray() {
			if (source == null)
				return new byte[0];

			return Encoding.GetEncoding(CodePage).GetBytes(source);
		}

		public SqlString Concat(ISqlString other) {
			if (other == null || other.IsNull)
				return this;

			if (other.CodePage != CodePage)
				throw new ArgumentException(&quot;The other string belongs to a different encoding.&quot;);

			if (other is SqlString) {
				var otheString = (SqlString) other;
				var length = (int) (Length + otheString.Length);
				if (length &gt;= MaxLength)
					throw new ArgumentException(&quot;The final string will be over the maximum length&quot;);

				var destChars = new char[length];
				Array.Copy(source, 0, destChars, 0, Length);
				Array.Copy(otheString.source, 0, destChars, Length, otheString.Length);
				return new SqlString(CodePage, destChars, length);
			}

			var sb = new StringBuilder(Int16.MaxValue);
			using (var output = new StringWriter(sb)) {
				// First read the current stream
				using (var reader = GetInput()) {
					var buffer = new char[2048];
					int count;
					while ((count = reader.Read(buffer, 0, buffer.Length)) != 0) {
						output.Write(buffer, 0, count);
					}
				}

				// Then read the second stream
				using (var reader = other.GetInput()) {
					var buffer = new char[2048];
					int count;
					while ((count = reader.Read(buffer, 0, buffer.Length)) != 0) {
						output.Write(buffer, 0, count);
					}
				}

				output.Flush();
			}

			var outChars = new char[sb.Length];
			sb.CopyTo(0, outChars, 0, sb.Length);
			return new SqlString(CodePage, outChars, outChars.Length);
		}

		#region StringEnumerator

		class StringEnumerator : IEnumerator&lt;char&gt; {
			private readonly SqlString sqlString;
			private int index = -1;
			private readonly int length;

			public StringEnumerator(SqlString sqlString) {
				this.sqlString = sqlString;
				length = (int) sqlString.Length;
			}

			public void Dispose() {
			}

			public bool MoveNext() {
				return ++index &lt; length;
			}

			public void Reset() {
				index = -1;
			}

			public char Current {
				get {
					if (index &gt;= length)
						throw new InvalidOperationException();

					return sqlString[index];
				}
			}

			object IEnumerator.Current {
				get { return Current; }
			}
		}

		#endregion

		public override string ToString() {
			return Value;
		}

		TypeCode IConvertible.GetTypeCode() {
			return TypeCode.String;
		}

		bool IConvertible.ToBoolean(IFormatProvider provider) {
			return Convert.ToBoolean(Value, provider);
		}

		char IConvertible.ToChar(IFormatProvider provider) {
			return Convert.ToChar(Value, provider);
		}

		sbyte IConvertible.ToSByte(IFormatProvider provider) {
			return Convert.ToSByte(Value, provider);
		}

		byte IConvertible.ToByte(IFormatProvider provider) {
			return Convert.ToByte(Value, provider);
		}

		short IConvertible.ToInt16(IFormatProvider provider) {
			return Convert.ToInt16(Value, provider);
		}

		ushort IConvertible.ToUInt16(IFormatProvider provider) {
			return Convert.ToUInt16(Value, provider);
		}

		int IConvertible.ToInt32(IFormatProvider provider) {
			return Convert.ToInt32(Value, provider);
		}

		uint IConvertible.ToUInt32(IFormatProvider provider) {
			return Convert.ToUInt32(Value, provider);
		}

		long IConvertible.ToInt64(IFormatProvider provider) {
			return Convert.ToInt64(Value, provider);
		}

		ulong IConvertible.ToUInt64(IFormatProvider provider) {
			return Convert.ToUInt64(Value, provider);
		}

		float IConvertible.ToSingle(IFormatProvider provider) {
			return Convert.ToSingle(Value, provider);
		}

		double IConvertible.ToDouble(IFormatProvider provider) {
			return Convert.ToDouble(Value, provider);
		}

		decimal IConvertible.ToDecimal(IFormatProvider provider) {
			return Convert.ToDecimal(Value, provider);
		}

		DateTime IConvertible.ToDateTime(IFormatProvider provider) {
			return Convert.ToDateTime(Value, provider);
		}

		string IConvertible.ToString(IFormatProvider provider) {
			return Convert.ToString(Value, provider);
		}

		object IConvertible.ToType(Type conversionType, IFormatProvider provider) {
			if (conversionType == typeof (bool))
				return Convert.ToBoolean(Value, provider);
			if (conversionType == typeof (byte))
				return Convert.ToByte(Value, provider);
			if (conversionType == typeof (sbyte))
				return Convert.ToSByte(Value, provider);
			if (conversionType == typeof (short))
				return Convert.ToInt16(Value, provider);
			if (conversionType == typeof (ushort))
				return Convert.ToUInt16(Value, provider);
			if (conversionType == typeof (int))
				return Convert.ToInt32(Value, provider);
			if (conversionType == typeof (uint))
				return Convert.ToUInt32(Value, provider);
			if (conversionType == typeof (long))
				return Convert.ToInt64(Value, provider);
			if (conversionType == typeof (ulong))
				return Convert.ToUInt64(Value, provider);
			if (conversionType == typeof (float))
				return Convert.ToSingle(Value, provider);
			if (conversionType == typeof (double))
				return Convert.ToDouble(Value, provider);
			if (conversionType == typeof (decimal))
				return Convert.ToDecimal(Value, provider);
			if (conversionType == typeof (string))
				return Convert.ToString(Value, provider);

			if (conversionType == typeof (char[]))
				return ToCharArray();

			if (conversionType == typeof (SqlNumber))
				return ToNumber();
			if (conversionType == typeof (SqlBoolean))
				return ToBoolean();
			if (conversionType == typeof (SqlDateTime))
				return ToDateTime();
			if (conversionType == typeof (SqlBinary))
				return ToBinary();

			throw new InvalidCastException(String.Format(&quot;Cannot convet SQL STRING to {0}&quot;, conversionType.FullName));
		}

		public static bool operator ==(SqlString a, SqlString b) {
			return a.Equals(b);
		}

		public static bool operator !=(SqlString a, SqlString b) {
			return !(a == b);
		}

		public static SqlString operator +(SqlString a, SqlString b) {
			return a.Concat(b);
		}

		public static SqlString operator +(SqlString a, string b) {
			var chars = new char[0];
			if (!String.IsNullOrEmpty(b))
				chars = b.ToCharArray();

			return a.Concat(new SqlString(a.CodePage, chars));
		}

		public SqlBoolean ToBoolean() {
			SqlBoolean value;
			if (!SqlBoolean.TryParse(Value, out value))
				return SqlBoolean.Null;			// TODO: Should we throw an exception?

			return value;
		}

		public SqlNumber ToNumber() {
			SqlNumber value;
			if (!SqlNumber.TryParse(Value, out value))
				return SqlNumber.Null;			// TODO: Shoudl we throw an exception?

			return value;
		}

		public SqlDateTime ToDateTime() {
			SqlDateTime value;
			if (!SqlDateTime.TryParse(Value, out value))
				return SqlDateTime.Null;		// TODO: Shoudl we throw an exception?

			return value;
		}

		public SqlBinary ToBinary() {
			var bytes = ToByteArray();
			return new SqlBinary(bytes);
		}

		public char[] ToCharArray() {
			if (source == null)
				return new char[0];

			var chars = new char[Length];
			Array.Copy(source, 0, chars, 0, Length);
			return chars;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[45,6,45,54,0],[61,4,61,39,0],[65,4,65,41,0],[79,6,79,53,0],[82,6,82,18,0],[84,6,84,53,0],[91,4,91,31,0],[96,5,96,46,0],[99,5,99,89,0],[102,5,102,14,0],[104,5,104,14,0],[106,5,106,15,0],[113,4,113,89,0],[131,4,131,50,0],[132,4,132,28,0],[133,4,133,23,0],[134,5,134,39,0],[136,4,136,63,0],[141,5,141,17,0],[144,5,144,18,0],[147,5,147,18,0],[153,6,153,19,0],[163,4,163,35,0],[168,5,168,14,0],[191,4,191,104,0],[209,5,209,24,0],[216,5,216,17,0],[225,6,225,86,0],[233,4,233,47,0],[234,11,234,44,0],[236,12,236,35,0],[237,6,237,34,0],[240,7,240,38,0],[239,6,239,66,0],[245,12,245,41,0],[246,6,246,34,0],[249,7,249,38,0],[248,6,248,66,0],[253,5,253,20,0],[256,4,256,39,0],[257,4,257,41,0],[258,4,258,62,0],[305,4,305,27,0],[309,4,309,46,0],[313,4,313,43,0],[317,4,317,44,0],[321,4,321,43,0],[325,4,325,44,0],[329,4,329,45,0],[333,4,333,44,0],[337,4,337,45,0],[341,4,341,44,0],[345,4,345,45,0],[349,4,349,45,0],[353,4,353,45,0],[357,4,357,46,0],[361,4,361,47,0],[365,4,365,45,0],[370,5,370,47,0],[372,5,372,44,0],[374,5,374,45,0],[376,5,376,45,0],[378,5,378,46,0],[380,5,380,45,0],[382,5,382,46,0],[384,5,384,45,0],[386,5,386,46,0],[388,5,388,46,0],[390,5,390,46,0],[392,5,392,47,0],[394,5,394,46,0],[397,5,397,26,0],[405,4,405,45,0],[406,5,406,23,0],[408,4,408,110,0],[412,4,412,23,0],[416,4,416,21,0],[420,4,420,23,0],[424,4,424,28,0],[425,4,425,33,0],[426,5,426,29,0],[428,4,428,54,0],[442,5,442,27,0],[450,5,450,29,0],[456,4,456,30,0],[457,4,457,32,0],[461,4,461,23,0],[462,5,462,24,0],[464,4,464,33,0],[465,4,465,44,0],[466,4,466,17,0],[274,4,274,5,0],[281,5,281,16,0],[282,4,282,5,0],[287,7,287,45,0],[33,3,34,61,1],[35,3,35,4,1],[38,6,38,12,1],[39,4,39,24,1],[41,4,41,22,1],[42,5,42,19,1],[44,5,44,28,1],[47,5,47,31,1],[48,5,48,45,1],[50,3,50,4,1],[52,3,53,78,1],[54,3,54,4,1],[56,3,57,46,1],[58,3,58,4,1],[69,10,69,32,1],[73,10,73,60,1],[78,5,78,32,1],[81,5,81,24,1],[83,5,83,25,1],[86,5,86,26,1],[95,4,95,22,1],[98,4,98,35,1],[101,4,101,31,1],[103,4,103,15,1],[105,4,105,21,1],[108,4,108,27,1],[109,5,109,41,1],[110,5,110,79,1],[117,4,117,38,1],[121,4,121,27,1],[125,10,125,56,1],[140,4,140,47,1],[143,4,143,23,1],[146,4,146,45,1],[149,9,149,19,1],[150,5,150,24,1],[151,5,151,30,1],[152,5,152,24,1],[149,39,149,42,1],[149,20,149,37,1],[156,4,156,16,1],[160,4,160,33,1],[161,5,161,17,1],[167,4,167,23,1],[171,5,171,19,1],[174,26,174,32,1],[174,14,174,22,1],[175,6,175,42,1],[174,23,174,25,1],[178,5,178,17,1],[183,4,183,86,1],[187,4,187,49,1],[195,4,195,82,1],[199,4,199,45,1],[203,4,203,50,1],[204,4,204,61,1],[208,4,208,23,1],[211,4,211,59,1],[215,4,215,38,1],[218,4,218,35,1],[219,5,219,86,1],[221,4,221,27,1],[222,5,222,40,1],[223,5,223,53,1],[224,5,224,29,1],[227,5,227,38,1],[228,5,228,49,1],[229,5,229,76,1],[230,5,230,55,1],[301,4,301,17,1],[369,4,369,40,1],[371,4,371,40,1],[373,4,373,41,1],[375,4,375,41,1],[377,4,377,42,1],[379,4,379,39,1],[381,4,381,40,1],[383,4,383,40,1],[385,4,385,41,1],[387,4,387,41,1],[389,4,389,42,1],[391,4,391,43,1],[393,4,393,42,1],[396,4,396,42,1],[399,4,399,45,1],[400,5,400,23,1],[401,4,401,46,1],[402,5,402,24,1],[403,4,403,47,1],[404,5,404,25,1],[433,4,433,47,1],[434,5,434,28,1],[436,4,436,17,1],[441,4,441,46,1],[444,4,444,17,1],[449,4,449,48,1],[452,4,452,17,1],[28,3,28,71,1],[29,3,29,71,1],[265,4,265,27,1],[268,4,268,48,1],[269,5,269,32,1],[270,5,270,37,1],[271,4,271,5,1],[277,5,277,29,1],[286,6,286,26,1],[289,6,289,30,1],[294,11,294,26,1]]);
    </script>
  </body>
</html>