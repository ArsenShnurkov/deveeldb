<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.compile\sqlgrammarbase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;

using Irony.Parsing;

namespace Deveel.Data.Sql.Compile {
	abstract class SqlGrammarBase : Grammar {
		// cached most used non-terminal
		private NonTerminal sqlExpression;
		private NonTerminal objectname;
		private NonTerminal datatype;

		protected SqlGrammarBase()
			: base(false) {
			SetupGrammar();
		}

		public abstract string Dialect { get; }

		protected StringLiteral StringLiteral { get; private set; }

		protected NumberLiteral NumberLiteral { get; private set; }

		protected NumberLiteral PositiveLiteral { get; private set; }

		protected IdentifierTerminal Identifier { get; private set; }

		protected KeyTerm Comma { get; private set; }

		protected KeyTerm Dot { get; private set; }

		protected KeyTerm Colon { get; private set; }

		protected KeyTerm As { get; private set; }

		protected abstract NonTerminal MakeRoot();

		private void Comments() {
			var comment = new CommentTerminal(&quot;multiline_comment&quot;, &quot;/*&quot;, &quot;*/&quot;);
			var lineComment = new CommentTerminal(&quot;singleline_comment&quot;, &quot;--&quot;, &quot;\n&quot;, &quot;\r\n&quot;);
			NonGrammarTerminals.Add(comment);
			NonGrammarTerminals.Add(lineComment);
		}

		private void Literals() {
			StringLiteral = new StringLiteral(&quot;string&quot;, &quot;&#39;&quot;, StringOptions.AllowsAllEscapes, typeof(StringLiteralNode));
			NumberLiteral = new NumberLiteral(&quot;number&quot;, NumberOptions.DisableQuickParse | NumberOptions.AllowSign, typeof(NumberLiteralNode));
			PositiveLiteral = new NumberLiteral(&quot;positive&quot;, NumberOptions.IntOnly, typeof(IntegerLiteralNode));
		}

		private void MakeSimpleId() {
			Identifier = new IdentifierTerminal(&quot;simple_id&quot;);
			var idStringLiteral = new StringLiteral(&quot;simple_id_quoted&quot;);
			idStringLiteral.AddStartEnd(&quot;\&quot;&quot;, StringOptions.NoEscapes);
			idStringLiteral.AstConfig.NodeType = typeof(IdentifierNode);
			idStringLiteral.SetOutputTerminal(this, Identifier);
		}

		private void Operators() {
			RegisterOperators(10, &quot;*&quot;, &quot;/&quot;, &quot;%&quot;);
			RegisterOperators(9, &quot;+&quot;, &quot;-&quot;);
			RegisterOperators(8, &quot;=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;&lt;&gt;&quot;, &quot;!=&quot;);
			RegisterOperators(8, Key(&quot;LIKE&quot;), Key(&quot;IN&quot;));
			RegisterOperators(7, &quot;^&quot;, &quot;&amp;&quot;, &quot;|&quot;);
			RegisterOperators(6, Key(&quot;NOT&quot;));
			RegisterOperators(5, Key(&quot;AND&quot;));
			RegisterOperators(4, Key(&quot;OR&quot;));
		}

		private void SetupGrammar() {
			Comma = ToTerm(&quot;,&quot;);
			Dot = ToTerm(&quot;.&quot;);
			Colon = ToTerm(&quot;:&quot;);
			As = ToTerm(&quot;AS&quot;);

			MakeSimpleId();

			Comments();
			Keywords();
			ReservedWords();
			Literals();

			Operators();

			MarkPunctuation(&quot;,&quot;, &quot;(&quot;, &quot;)&quot;, &quot;AS&quot;);

			Root = MakeRoot();
		}

		protected KeyTerm Key(string term) {
			KeyTerm keyTerm;
			if (!KeyTerms.TryGetValue(term, out keyTerm))
				KeyTerms[term] = keyTerm = ToTerm(term);

			return keyTerm;
		}

		protected virtual void Keywords() {
			
		}

		protected virtual void ReservedWords() {
			
		}

		protected NonTerminal ObjectName() {
			if (objectname != null)
				return objectname;

			objectname = new NonTerminal(&quot;object_name&quot;, typeof(ObjectNameNode));
			objectname.Rule = MakePlusRule(objectname, Dot, Identifier);
			return objectname;
		}

		protected NonTerminal DataType() {
			if (datatype != null)
				return datatype;

			datatype = new NonTerminal(&quot;datatype&quot;, typeof (DataTypeNode));
			var numberPrecision = new NonTerminal(&quot;number_precision&quot;);
			var characterType = new NonTerminal(&quot;character_type&quot;);
			var localeOpt = new NonTerminal(&quot;locale_opt&quot;);
			var integerType = new NonTerminal(&quot;integer_type&quot;);
			var decimalType = new NonTerminal(&quot;decimal_type&quot;);
			var floatType = new NonTerminal(&quot;float_type&quot;);
			var dateType = new NonTerminal(&quot;date_type&quot;);
			var intervalType = new NonTerminal(&quot;interval_type&quot;);
			var intervalFormatOpt = new NonTerminal(&quot;interval_format_opt&quot;);
			var datatypeSize = new NonTerminal(&quot;datatype_size&quot;);
			var longVarchar = new NonTerminal(&quot;long_varchar&quot;);
			var binaryType = new NonTerminal(&quot;binary_type&quot;);
			var longVarbinary = new NonTerminal(&quot;long_varbinary&quot;);
			var userType = new NonTerminal(&quot;user_type&quot;);
			var rowType = new NonTerminal(&quot;row_type&quot;);
			var geometryType = new NonTerminal(&quot;geometry_type&quot;);
			var xmlType = new NonTerminal(&quot;xml_type&quot;);

			datatype.Rule = characterType |
			                dateType |
			                integerType |
			                decimalType |
			                floatType |
			                binaryType |
			                rowType |
			                userType |
			                geometryType |
			                xmlType;

			characterType.Rule = Key(&quot;CHAR&quot;) + datatypeSize + localeOpt |
			                     Key(&quot;VARCHAR&quot;) + datatypeSize + localeOpt |
			                     longVarchar + datatypeSize + localeOpt;
			localeOpt.Rule = Empty | Key(&quot;LOCALE&quot;) + StringLiteral;
			dateType.Rule = Key(&quot;DATE&quot;) | Key(&quot;TIME&quot;) | Key(&quot;TIMESTAMP&quot;);
			integerType.Rule = Key(&quot;INT&quot;) |
			                   Key(&quot;INTEGER&quot;) |
			                   Key(&quot;BIGINT&quot;) |
			                   Key(&quot;SMALLINT&quot;) |
			                   Key(&quot;TINYINT&quot;);
			decimalType.Rule = Key(&quot;DECIMAL&quot;) + numberPrecision |
			                   Key(&quot;NUMERIC&quot;) + numberPrecision |
			                   Key(&quot;NUMBER&quot;) + numberPrecision;
			floatType.Rule = Key(&quot;FLOAT&quot;) |
			                 Key(&quot;REAL&quot;) |
			                 Key(&quot;DOUBLE&quot;);
			binaryType.Rule = Key(&quot;BINARY&quot;) + datatypeSize |
			                  Key(&quot;VARBINARY&quot;) + datatypeSize |
			                  Key(&quot;BLOB&quot;) |
			                  longVarbinary + datatypeSize;
			longVarchar.Rule = Key(&quot;LONG&quot;) + Key(&quot;VARCHAR&quot;);
			longVarbinary.Rule = Key(&quot;LONG&quot;) + Key(&quot;VARBINARY&quot;);
			rowType.Rule = ObjectName() + &quot;%&quot; + Key(&quot;ROWTYPE&quot;);
			userType.Rule = ObjectName();
			intervalType.Rule = Key(&quot;INTERVAL&quot;) + intervalFormatOpt;
			intervalFormatOpt.Rule = Key(&quot;YEAR&quot;) + Key(&quot;TO&quot;) + Key(&quot;MONTH&quot;) |
			                         Key(&quot;DAY&quot;) + Key(&quot;TO&quot;) + Key(&quot;SECOND&quot;);
			geometryType.Rule = Key(&quot;GEOMETRY&quot;) + datatypeSize;
			xmlType.Rule = Key(&quot;XML&quot;);

			datatypeSize.Rule = Empty | &quot;(&quot; + PositiveLiteral + &quot;)&quot;;

			numberPrecision.Rule = Empty |
			                       &quot;(&quot; + PositiveLiteral + &quot;)&quot; |
			                       &quot;(&quot; + PositiveLiteral + &quot;,&quot; + PositiveLiteral + &quot;)&quot;;

			return datatype;
		}

		protected NonTerminal SqlExpressionList() {
			var list = new NonTerminal(&quot;sql_expression_list&quot;);
			list.Rule = MakePlusRule(list, Comma, SqlExpression());
			return list;
		}

		protected NonTerminal SqlQueryExpression() {
			var selectIntoOpt = new NonTerminal(&quot;select_into_opt&quot;);
			var selectSet = new NonTerminal(&quot;select_set&quot;);
			var selectRestrictOpt = new NonTerminal(&quot;select_restrict_opt&quot;);
			var selectItem = new NonTerminal(&quot;select_item&quot;, typeof(SelectItemNode));
			var selectAsOpt = new NonTerminal(&quot;select_as_opt&quot;);
			var selectSource = new NonTerminal(&quot;select_source&quot;);
			var selectItemList = new NonTerminal(&quot;select_item_list&quot;);
			var fromClauseOpt = new NonTerminal(&quot;from_clause_opt&quot;);
			var fromClause = new NonTerminal(&quot;from_clause&quot;, typeof(FromClauseNode));
			var fromSource = new NonTerminal(&quot;from_source&quot;);
			var fromTableSource = new NonTerminal(&quot;from_table_source&quot;, typeof(FromTableSourceNode));
			var fromQuerySource = new NonTerminal(&quot;from_query_source&quot;, typeof(FromQuerySourceNode));
			var joinOpt = new NonTerminal(&quot;join_opt&quot;);
			var joinType = new NonTerminal(&quot;join_type&quot;);
			var join = new NonTerminal(&quot;join&quot;, typeof (JoinNode));
			var onOpt = new NonTerminal(&quot;on_opt&quot;);
			var whereClauseOpt = new NonTerminal(&quot;where_clause_opt&quot;);
			var groupByOpt = new NonTerminal(&quot;group_by_opt&quot;);
			var groupBy = new NonTerminal(&quot;group_by&quot;, typeof(GroupByNode));
			var havingClauseOpt = new NonTerminal(&quot;having_clause_opt&quot;);
			var orderOpt = new NonTerminal(&quot;order_opt&quot;);
			var sortedDef = new NonTerminal(&quot;sorted_def&quot;, typeof(OrderByNode));
			var sortedDefList = new NonTerminal(&quot;sorted_def_list&quot;);
			var sortOrder = new NonTerminal(&quot;sort_order&quot;);
			var queryCompositeOpt = new NonTerminal(&quot;query_composite_opt&quot;);
			var queryComposite = new NonTerminal(&quot;query_composite&quot;, typeof(QueryCompositeNode));
			var expression = new NonTerminal(&quot;sql_query_expression&quot;, typeof(SqlQueryExpressionNode));
			var allOpt = new NonTerminal(&quot;all_opt&quot;);
			var asOpt = new NonTerminal(&quot;as_opt&quot;);

			expression.Rule = Key(&quot;SELECT&quot;) + selectRestrictOpt +
							  selectIntoOpt +
							  selectSet +
							  fromClauseOpt +
							  whereClauseOpt +
							  groupByOpt +
							  queryCompositeOpt;

			selectRestrictOpt.Rule = Empty | Key(&quot;ALL&quot;) | Key(&quot;DISTINCT&quot;);
			selectIntoOpt.Rule = Empty | Key(&quot;INTO&quot;) + ObjectName();
			selectSet.Rule = selectItemList | &quot;*&quot;;
			selectItemList.Rule = MakePlusRule(selectItemList, Comma, selectItem);
			selectItem.Rule = selectSource + selectAsOpt;
			selectAsOpt.Rule = Empty |
			                   As + Identifier |
			                   Identifier;
			selectSource.Rule = SqlExpression() | ObjectName();
			fromClauseOpt.Rule = Empty | fromClause;
			fromClause.Rule = Key(&quot;FROM&quot;) + fromSource + joinOpt;
			fromSource.Rule = fromTableSource |
			                  fromQuerySource;
			fromTableSource.Rule = ObjectName() + selectAsOpt;
			fromQuerySource.Rule = &quot;(&quot; + expression + &quot;)&quot; + selectAsOpt;

			joinOpt.Rule = Empty | join;
			join.Rule = joinType + fromSource + onOpt;
			onOpt.Rule = Empty | Key(&quot;ON&quot;) + SqlExpression() + joinOpt;
			joinType.Rule = Key(&quot;INNER&quot;) + Key(&quot;JOIN&quot;)|
							Key(&quot;OUTER&quot;) + Key(&quot;JOIN&quot;) |
							Key(&quot;LEFT&quot;) + Key(&quot;JOIN&quot;) |
							Key(&quot;LEFT&quot;) + Key(&quot;OUTER&quot;) + Key(&quot;JOIN&quot;) |
							Key(&quot;RIGHT&quot;) + Key(&quot;JOIN&quot;) |
							Key(&quot;RIGHT&quot;) + Key(&quot;OUTER&quot;) + Key(&quot;JOIN&quot;) |
							Comma;
			whereClauseOpt.Rule = Empty | Key(&quot;WHERE&quot;) + SqlExpression();
			groupByOpt.Rule = Empty | groupBy;
			groupBy.Rule = Key(&quot;GROUP&quot;) + Key(&quot;BY&quot;) + SqlExpressionList() + havingClauseOpt;
			havingClauseOpt.Rule = Empty | Key(&quot;HAVING&quot;) + SqlExpression();
			queryCompositeOpt.Rule = Empty | queryComposite;
			queryComposite.Rule = Key(&quot;UNION&quot;) + allOpt + expression |
								   Key(&quot;INTERSECT&quot;) + allOpt + expression |
								   Key(&quot;EXCEPT&quot;) + allOpt + expression;
			orderOpt.Rule = Empty | Key(&quot;ORDER&quot;) + Key(&quot;BY&quot;) + sortedDefList;
			sortedDef.Rule = SqlExpression() + sortOrder;
			sortOrder.Rule = Key(&quot;ASC&quot;) | Key(&quot;DESC&quot;);
			allOpt.Rule = Empty | Key(&quot;ALL&quot;);
			asOpt.Rule = Empty | As;
			sortedDefList.Rule = MakePlusRule(sortedDefList, Comma, sortedDef);

			MarkTransient(selectSource);

			return expression;
		}

		protected NonTerminal SqlExpression() {
			if (sqlExpression != null)
				return sqlExpression;

			sqlExpression = new NonTerminal(&quot;sql_expression&quot;);

			var sqlUnaryExpression = new NonTerminal(&quot;sql_unary_expression&quot;, typeof(SqlUnaryExpressionNode));
			var sqlBinaryExpression = new NonTerminal(&quot;sql_binary_expression&quot;, typeof(SqlBinaryExpressionNode));
			var sqlBetweenExpression = new NonTerminal(&quot;sql_between_expression&quot;, typeof(SqlBetweenExpressionNode));
			var sqlCaseExpression = new NonTerminal(&quot;sql_case_expression&quot;, typeof(SqlCaseExpressionNode));
			var sqlReferenceExpression = new NonTerminal(&quot;sql_reference_expression&quot;, typeof(SqlReferenceExpressionNode));
			var term = new NonTerminal(&quot;term&quot;);
			var sqlSimpleExpression = new NonTerminal(&quot;sql_simple_expression&quot;);
			var unaryOp = new NonTerminal(&quot;unary_op&quot;);
			var binaryOp = new NonTerminal(&quot;binary_op&quot;);
			var binaryOpSimple = new NonTerminal(&quot;binary_op_simple&quot;);
			var logicalOp = new NonTerminal(&quot;logical_op&quot;);
			var subqueryOp = new NonTerminal(&quot;subquery_op&quot;);
			var caseTestExpressionOpt = new NonTerminal(&quot;case_test_expression_opt&quot;);
			var caseWhenThenList = new NonTerminal(&quot;case_when_then_list&quot;);
			var caseWhenThen = new NonTerminal(&quot;case_when_then&quot;, typeof(CaseSwitchNode));
			var caseElseOpt = new NonTerminal(&quot;case_else_opt&quot;);
			var sqlVarefExpression = new NonTerminal(&quot;sql_varef_expression&quot;, typeof(SqlVariableRefExpressionNode));
			var sqlConstantExpression = new NonTerminal(&quot;sql_constant_expression&quot;, typeof(SqlConstantExpressionNode));
			var functionCallExpression = new NonTerminal(&quot;function_call_expression&quot;, typeof(SqlFunctionCallExpressionNode));
			var functionCallArgsOpt = new NonTerminal(&quot;function_call_args_opt&quot;);
			var functionCallArgsList = new NonTerminal(&quot;function_call_args_list&quot;);
			var notOpt = new NonTerminal(&quot;not_op&quot;);
			var tuple = new NonTerminal(&quot;tuple&quot;, typeof(SqlExpressionTupleNode));
			var anyOp = new NonTerminal(&quot;any_op&quot;);
			var allOp = new NonTerminal(&quot;all_op&quot;);

			sqlExpression.Rule = sqlSimpleExpression |
								  sqlBetweenExpression |
								  sqlCaseExpression |
								  SqlQueryExpression();
			sqlConstantExpression.Rule = StringLiteral | NumberLiteral | Key(&quot;TRUE&quot;) | Key(&quot;FALSE&quot;) | Key(&quot;NULL&quot;);
			sqlSimpleExpression.Rule = term | sqlUnaryExpression | sqlBinaryExpression;
			term.Rule = sqlReferenceExpression |
						sqlVarefExpression |
						sqlConstantExpression |
						functionCallExpression |
						tuple;
			sqlReferenceExpression.Rule = ObjectName();
			tuple.Rule = &quot;(&quot; + SqlExpressionList() + &quot;)&quot;;
			sqlUnaryExpression.Rule = unaryOp + term;
			unaryOp.Rule = Key(&quot;NOT&quot;) | &quot;+&quot; | &quot;-&quot; | &quot;~&quot;;
			sqlBinaryExpression.Rule = sqlSimpleExpression + binaryOp + sqlSimpleExpression;
			binaryOpSimple.Rule = ToTerm(&quot;+&quot;) | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&gt;&quot; | &quot;&lt;&quot; | &quot;=&quot; | &quot;&lt;&gt;&quot;;
			binaryOp.Rule = binaryOpSimple | allOp | anyOp | logicalOp | subqueryOp;
			logicalOp.Rule = Key(&quot;AND&quot;) | Key(&quot;OR&quot;) | &quot;&amp;&quot; | &quot;|&quot;;
			subqueryOp.Rule = Key(&quot;IN&quot;) | Key(&quot;NOT&quot;) + Key(&quot;IN&quot;);
			anyOp.Rule = Key(&quot;ANY&quot;) + binaryOpSimple;
			allOp.Rule = Key(&quot;ALL&quot;) + binaryOpSimple;
			sqlBetweenExpression.Rule = sqlSimpleExpression + notOpt + Key(&quot;BETWEEN&quot;) + sqlSimpleExpression + Key(&quot;AND&quot;) +
										sqlSimpleExpression;
			sqlCaseExpression.Rule = Key(&quot;CASE&quot;) + caseTestExpressionOpt + caseWhenThenList + caseElseOpt + Key(&quot;END&quot;);
			caseTestExpressionOpt.Rule = Empty | sqlExpression;
			caseElseOpt.Rule = Empty | Key(&quot;ELSE&quot;) + sqlExpression;
			caseWhenThenList.Rule = MakePlusRule(caseWhenThenList, caseWhenThen);
			caseWhenThen.Rule = Key(&quot;WHEN&quot;) + sqlExpression + Key(&quot;THEN&quot;) + sqlExpression;

			functionCallExpression.Rule = ObjectName() + functionCallArgsOpt;
			functionCallArgsOpt.Rule = Empty | &quot;(&quot; + functionCallArgsList + &quot;)&quot;;
			functionCallArgsList.Rule = MakeStarRule(functionCallArgsList, Comma, sqlExpression);

			sqlVarefExpression.Rule = Colon + Identifier;

			notOpt.Rule = Empty | Key(&quot;NOT&quot;);

			MarkTransient(sqlExpression, term, sqlSimpleExpression, functionCallArgsOpt);

			return sqlExpression;
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[28,3,29,17,1],[30,4,30,19,1],[31,3,31,4,1],[54,4,54,71,1],[55,4,55,84,1],[56,4,56,37,1],[57,4,57,41,1],[58,3,58,4,1],[61,4,61,112,1],[62,4,62,134,1],[63,4,63,103,1],[64,3,64,4,1],[67,4,67,53,1],[68,4,68,64,1],[69,4,69,63,1],[70,4,70,64,1],[71,4,71,56,1],[72,3,72,4,1],[75,4,75,41,1],[76,4,76,35,1],[77,4,77,64,1],[78,4,78,49,1],[79,4,79,40,1],[80,4,80,37,1],[81,4,81,37,1],[82,4,82,36,1],[83,3,83,4,1],[86,4,86,24,1],[87,4,87,22,1],[88,4,88,24,1],[89,4,89,22,1],[91,4,91,19,1],[93,4,93,15,1],[94,4,94,15,1],[95,4,95,20,1],[96,4,96,15,1],[98,4,98,16,1],[100,4,100,41,1],[102,4,102,22,1],[103,3,103,4,1],[107,4,107,49,1],[108,5,108,45,1],[110,4,110,19,1],[115,3,115,4,1],[119,3,119,4,1],[122,4,122,27,1],[123,5,123,23,1],[125,4,125,72,1],[126,4,126,64,1],[127,4,127,22,1],[131,4,131,25,1],[132,5,132,21,1],[134,4,134,66,1],[135,4,135,62,1],[136,4,136,58,1],[137,4,137,50,1],[138,4,138,54,1],[139,4,139,54,1],[140,4,140,50,1],[141,4,141,48,1],[142,4,142,56,1],[143,4,143,67,1],[144,4,144,56,1],[145,4,145,54,1],[146,4,146,52,1],[147,4,147,58,1],[148,4,148,48,1],[149,4,149,46,1],[150,4,150,56,1],[151,4,151,46,1],[153,4,162,28,1],[164,4,166,64,1],[167,4,167,59,1],[168,4,168,65,1],[169,4,173,38,1],[174,4,176,55,1],[177,4,179,35,1],[180,4,183,51,1],[184,4,184,52,1],[185,4,185,56,1],[186,4,186,55,1],[187,4,187,33,1],[188,4,188,60,1],[189,4,190,68,1],[191,4,191,55,1],[192,4,192,30,1],[194,4,194,60,1],[196,4,198,79,1],[200,4,200,20,1],[204,4,204,54,1],[205,4,205,59,1],[206,4,206,16,1],[210,4,210,59,1],[211,4,211,50,1],[212,4,212,67,1],[213,4,213,76,1],[214,4,214,55,1],[215,4,215,56,1],[216,4,216,61,1],[217,4,217,59,1],[218,4,218,76,1],[219,4,219,52,1],[220,4,220,92,1],[221,4,221,92,1],[222,4,222,46,1],[223,4,223,48,1],[224,4,224,58,1],[225,4,225,42,1],[226,4,226,61,1],[227,4,227,53,1],[228,4,228,67,1],[229,4,229,63,1],[230,4,230,48,1],[231,4,231,71,1],[232,4,232,59,1],[233,4,233,50,1],[234,4,234,67,1],[235,4,235,88,1],[236,4,236,93,1],[237,4,237,44,1],[238,4,238,42,1],[240,4,246,28,1],[248,4,248,66,1],[249,4,249,60,1],[250,4,250,42,1],[251,4,251,74,1],[252,4,252,49,1],[253,4,255,34,1],[256,4,256,55,1],[257,4,257,44,1],[258,4,258,57,1],[259,4,260,38,1],[261,4,261,54,1],[262,4,262,64,1],[264,4,264,32,1],[265,4,265,46,1],[266,4,266,63,1],[267,4,273,14,1],[274,4,274,65,1],[275,4,275,38,1],[276,4,276,84,1],[277,4,277,67,1],[278,4,278,52,1],[279,4,281,48,1],[282,4,282,69,1],[283,4,283,49,1],[284,4,284,46,1],[285,4,285,37,1],[286,4,286,28,1],[287,4,287,71,1],[289,4,289,32,1],[291,4,291,22,1],[295,4,295,30,1],[296,5,296,26,1],[298,4,298,54,1],[300,4,300,101,1],[301,4,301,104,1],[302,4,302,107,1],[303,4,303,98,1],[304,4,304,113,1],[305,4,305,39,1],[306,4,306,71,1],[307,4,307,46,1],[308,4,308,48,1],[309,4,309,61,1],[310,4,310,50,1],[311,4,311,52,1],[312,4,312,76,1],[313,4,313,66,1],[314,4,314,81,1],[315,4,315,55,1],[316,4,316,107,1],[317,4,317,110,1],[318,4,318,116,1],[319,4,319,72,1],[320,4,320,74,1],[321,4,321,43,1],[322,4,322,73,1],[323,4,323,42,1],[324,4,324,42,1],[326,4,329,32,1],[330,4,330,106,1],[331,4,331,79,1],[332,4,336,13,1],[337,4,337,47,1],[338,4,338,49,1],[339,4,339,45,1],[340,4,340,48,1],[341,4,341,84,1],[342,4,342,87,1],[343,4,343,76,1],[344,4,344,56,1],[345,4,345,57,1],[346,4,346,45,1],[347,4,347,45,1],[348,4,349,31,1],[350,4,350,111,1],[351,4,351,55,1],[352,4,352,59,1],[353,4,353,73,1],[354,4,354,82,1],[356,4,356,69,1],[357,4,357,72,1],[358,4,358,89,1],[360,4,360,49,1],[362,4,362,37,1],[364,4,364,81,1],[366,4,366,25,1]]);
    </script>
  </body>
</html>