<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.sql.objects\sqlboolean.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;

namespace Deveel.Data.Sql.Objects {
	/// &lt;summary&gt;
	/// An SQL object handling a single-byte value that represents
	/// the concept of boolean &lt;c&gt;true&lt;/c&gt; and &lt;c&gt;false&lt;/c&gt;.
	/// &lt;/summary&gt;
	/// &lt;remarks&gt;
	/// On a byte level, this object handles only &lt;c&gt;0&lt;/c&gt; or &lt;c&gt;1&lt;/c&gt;, that
	/// represents respectively the concepts of &lt;c&gt;false&lt;/c&gt; and &lt;c&gt;true&lt;/c&gt;.
	/// &lt;para&gt;
	/// Additionally, a boolean object can be represented as &lt;c&gt;NULL&lt;/c&gt;, when the
	/// state cannot be determined.
	/// &lt;/para&gt;
	/// &lt;/remarks&gt;
	[Serializable]
	public struct SqlBoolean : ISqlObject, IEquatable&lt;SqlBoolean&gt;, IComparable&lt;SqlBoolean&gt;, IConvertible {
		private readonly byte? value;

		/// &lt;summary&gt;
		/// Represents the materialization of a &lt;c&gt;true&lt;/c&gt; boolean.
		/// &lt;/summary&gt;
		public static readonly SqlBoolean True = new SqlBoolean(1);

		/// &lt;summary&gt;
		/// Rapresents the materialization of a &lt;c&gt;false&lt;/c&gt; boolean.
		/// &lt;/summary&gt;
		public static readonly SqlBoolean False = new SqlBoolean(0);

		/// &lt;summary&gt;
		/// Defines a &lt;c&gt;null&lt;/c&gt; boolean.
		/// &lt;/summary&gt;
		public static readonly SqlBoolean Null = new SqlBoolean(null);

		/// &lt;summary&gt;
		/// Constructs a given boolean object with a defined byte value.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;value&quot;&gt;The single byte representing the boolean.&lt;/param&gt;
		/// &lt;exception cref=&quot;ArgumentOutOfRangeException&quot;&gt;
		/// If the &lt;paramref name=&quot;value&quot;/&gt; specified is not equivalent to
		/// &lt;c&gt;0&lt;/c&gt; or &lt;c&gt;1&lt;/c&gt;.
		/// &lt;/exception&gt;
		public SqlBoolean(byte value)
			: this() {
			if (value != 0 &amp;&amp;
				value != 1)
				throw new ArgumentOutOfRangeException(&quot;value&quot;);

			this.value = value;
		}

		/// &lt;summary&gt;
		/// Constructs an object from a runtime boolean object.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;value&quot;&gt;The native boolean value that represents the object.&lt;/param&gt;
		public SqlBoolean(bool value)
			: this((byte)(value ? 1 : 0)) {
		}

		private SqlBoolean(byte? value)
			: this() {
			this.value = value;
		}

		int IComparable.CompareTo(object obj) {
			if (!(obj is ISqlObject))
				throw new ArgumentException();

			return CompareTo((ISqlObject) obj);
		}

		/// &lt;inheritdoc/&gt;
		public int CompareTo(ISqlObject other) {
			if (other is SqlNull) {
				if (IsNull)
					return 0;
				return 1;
			}

			SqlBoolean otherBoolean;
			if (other is SqlNumber) {
				var num = (SqlNumber) other;
				if (num.IsNull) {
					otherBoolean = Null;
				} else if (num == SqlNumber.One) {
					otherBoolean = True;
				} else if (num == SqlNumber.Zero) {
					otherBoolean = False;
				} else {
					throw new ArgumentOutOfRangeException(&quot;other&quot;, other, &quot;The given numeric value is out of range for a comparison with SQL BOOLEAN.&quot;);
				}
			} else if (other is SqlBoolean) {
				otherBoolean = (SqlBoolean) other;
			} else {
				throw new ArgumentException(String.Format(&quot;Object of type {0} cannot be compared to SQL BOOLEAN&quot;, other.GetType().FullName));
			}

			return CompareTo(otherBoolean);
		}

		/// &lt;inheritdoc/&gt;
		public bool IsNull {
			get { return value == null; }
		}

		/// &lt;summary&gt;
		/// Indicates if the given &lt;see cref=&quot;ISqlObject&quot;/&gt; can be compared to this
		/// &lt;see cref=&quot;SqlBoolean&quot;/&gt;.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;other&quot;&gt;The other object to verifiy compatibility.&lt;/param&gt;
		/// &lt;remarks&gt;
		/// Comparable objects are &lt;see cref=&quot;SqlBoolean&quot;/&gt;, &lt;see cref=&quot;SqlNull&quot;/&gt; or
		/// &lt;see cref=&quot;SqlNumber&quot;/&gt; with a value equals to &lt;see cref=&quot;SqlNumber.One&quot;/&gt;,
		/// &lt;see cref=&quot;SqlNumber.Zero&quot;/&gt; or &lt;see cref=&quot;SqlNumber.Null&quot;/&gt;.
		/// &lt;/remarks&gt;
		/// &lt;returns&gt;
		/// Returns &lt;c&gt;true&lt;/c&gt; if the given object can be compared to this boolean
		/// instance, or &lt;c&gt;false&lt;/c&gt; otherwise.
		/// &lt;/returns&gt;
		public bool IsComparableTo(ISqlObject other) {
			if (other is SqlBoolean || other is SqlNull)
				return true;

			if (other is SqlNumber) {
				var num = (SqlNumber) other;
				return num == SqlNumber.Zero || num == SqlNumber.One;
			}

			return false;
		}

		/// &lt;inheritdoc/&gt;
		public override bool Equals(object obj) {
			if (obj is SqlNull &amp;&amp; IsNull)
				return true;

			if (!(obj is SqlBoolean))
				return false;

			return Equals((SqlBoolean) obj);
		}

		/// &lt;inheritdoc/&gt;
		public bool Equals(SqlBoolean other) {
			if (IsNull &amp;&amp; other.IsNull)
				return true;
			if (IsNull &amp;&amp; !other.IsNull)
				return false;
			if (!IsNull &amp;&amp; other.IsNull)
				return false;

			return value.Equals(other.value);
		}

		/// &lt;inheritdoc/&gt;
		public override int GetHashCode() {
			return value == null ? 0 : value.Value.GetHashCode();
		}

		TypeCode IConvertible.GetTypeCode() {
			return TypeCode.Boolean;
		}

		bool IConvertible.ToBoolean(IFormatProvider provider) {
			return this;
		}

		char IConvertible.ToChar(IFormatProvider provider) {
			throw new InvalidCastException();
		}

		sbyte IConvertible.ToSByte(IFormatProvider provider) {
			return (sbyte) (this as IConvertible).ToInt32(provider);
		}

		byte IConvertible.ToByte(IFormatProvider provider) {
			if (value == null)
				throw new NullReferenceException();

			return value.Value;
		}

		short IConvertible.ToInt16(IFormatProvider provider) {
			return (short) (this as IConvertible).ToInt32(provider);
		}

		ushort IConvertible.ToUInt16(IFormatProvider provider) {
			return (ushort) (this as IConvertible).ToInt32(provider);
		}

		int IConvertible.ToInt32(IFormatProvider provider) {
			if (value == null)
				throw new NullReferenceException();

			return value.Value;
		}

		uint IConvertible.ToUInt32(IFormatProvider provider) {
			return (uint) (this as IConvertible).ToInt32(provider);
		}

		long IConvertible.ToInt64(IFormatProvider provider) {
			return (this as IConvertible).ToInt64(provider);
		}

		ulong IConvertible.ToUInt64(IFormatProvider provider) {
			return (this as IConvertible).ToUInt64(provider);
		}

		float IConvertible.ToSingle(IFormatProvider provider) {
			return (this as IConvertible).ToInt32(provider);
		}

		double IConvertible.ToDouble(IFormatProvider provider) {
			return (this as IConvertible).ToInt32(provider);
		}

		decimal IConvertible.ToDecimal(IFormatProvider provider) {
			return (this as IConvertible).ToInt32(provider);
		}

		DateTime IConvertible.ToDateTime(IFormatProvider provider) {
			throw new InvalidCastException();
		}

		string IConvertible.ToString(IFormatProvider provider) {
			return ToString();
		}

		object IConvertible.ToType(Type conversionType, IFormatProvider provider) {
			if (conversionType == typeof (bool))
				return (bool) this;

			throw new InvalidCastException(String.Format(&quot;Cannot convert a SQL BOOLEAN to {0}&quot;, conversionType.FullName));
		}

		/// &lt;inheritdoc/&gt;
		public int CompareTo(SqlBoolean other) {
			if (other.IsNull &amp;&amp; IsNull)
				return 0;

			if (IsNull &amp;&amp; !other.IsNull)
				return -1;
			if (!IsNull &amp;&amp; other.IsNull)
				return 1;

			return value.Value.CompareTo(other.value.Value);
		}

		/// &lt;summary&gt;
		/// Operates an equality check between the two SQL boolean objects.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;a&quot;&gt;The left term of comparison.&lt;/param&gt;
		/// &lt;param name=&quot;b&quot;&gt;The right term of comparison.&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		/// &lt;seealso cref=&quot;Equals(SqlBoolean)&quot;/&gt;
		/// &lt;seealso cref=&quot;Equals(object)&quot;/&gt;
		public static SqlBoolean operator ==(SqlBoolean a, SqlBoolean b) {
			return a.Equals(b);
		}

		/// &lt;summary&gt;
		/// Operates an inequality check between the two SQL booleans
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;a&quot;&gt;The left term of comparison.&lt;/param&gt;
		/// &lt;param name=&quot;b&quot;&gt;The right term of comparison.&lt;/param&gt;
		/// &lt;returns&gt;&lt;/returns&gt;
		public static SqlBoolean operator !=(SqlBoolean a, SqlBoolean b) {
			return !(a == b);
		}

		public static SqlBoolean operator ==(SqlBoolean a, ISqlObject b) {
			return a.Equals(b);
		}

		public static SqlBoolean operator !=(SqlBoolean a, ISqlObject b) {
			return !(a == b);
		}

		/// &lt;summary&gt;
		/// Implicitly converts the SQL boolean object to a native boolean.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;value&quot;&gt;The SQL boolean to convert.&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns an instance of &lt;see cref=&quot;bool&quot;/&gt; which is equivalent to 
		/// this object.
		/// &lt;/returns&gt;
		public static implicit operator bool(SqlBoolean value) {
			if (value.IsNull)
				throw new InvalidCastException();

			return value.value == 1;
		}

		/// &lt;summary&gt;
		/// Implicitly converts a given native boolean to the SQL object equivalent.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;value&quot;&gt;The boolean value to convert.&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns an instance of &lt;see cref=&quot;SqlBoolean&quot;/&gt; that is equivalent
		/// to the boolean value given.
		/// &lt;/returns&gt;
		public static implicit operator SqlBoolean(bool value) {
			return new SqlBoolean(value);
		}

		/// &lt;summary&gt;
		/// Parses the given string to extract a boolean value equivalent.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;s&quot;&gt;The string to parse.&lt;/param&gt;
		/// &lt;returns&gt;
		/// Returns an instance of &lt;see cref=&quot;SqlBoolean&quot;/&gt; as defined by the 
		/// given string.
		/// &lt;/returns&gt;
		/// &lt;exception cref=&quot;ArgumentNullException&quot;&gt;
		/// If the string argument &lt;paramref name=&quot;s&quot;/&gt; is &lt;c&gt;null&lt;/c&gt; or empty.
		/// &lt;/exception&gt;
		/// &lt;exception cref=&quot;FormatException&quot;&gt;
		/// If the given string argument cannot be parsed to a valid SQL boolean.
		/// &lt;/exception&gt;
		/// &lt;seealso cref=&quot;TryParse&quot;/&gt;
		public static SqlBoolean Parse(string s) {
			if (String.IsNullOrEmpty(s))
				throw new ArgumentNullException(&quot;s&quot;);

			SqlBoolean value;
			if (!TryParse(s, out value))
				throw new FormatException();

			return value;
		}

		/// &lt;summary&gt;
		/// Attempts to parse a given string to an instance of &lt;see cref=&quot;SqlBoolean&quot;/&gt;.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;s&quot;&gt;The string to parse.&lt;/param&gt;
		/// &lt;param name=&quot;value&quot;&gt;The output &lt;see cref=&quot;SqlBoolean&quot;/&gt; that will be emitted
		/// if the given string represents a valid boolean.&lt;/param&gt;
		/// &lt;remarks&gt;
		/// A valid SQL boolean is either a numeric value, expressed by &lt;c&gt;1&lt;/c&gt; or &lt;c&gt;0&lt;/c&gt;,
		/// or alternatively a string value expressed as &lt;c&gt;true&lt;/c&gt; or &lt;c&gt;false&lt;/c&gt;.
		/// &lt;para&gt;
		/// The case of the string is insensitive (as for general SQL syntax rule).
		/// &lt;/para&gt;
		/// &lt;/remarks&gt;
		/// &lt;returns&gt;
		/// Returns &lt;c&gt;true&lt;/c&gt; if the string passed is a valid SQL boolean and the value
		/// was set to a valid &lt;see cref=&quot;SqlBoolean&quot;/&gt;, or &lt;c&gt;false&lt;/c&gt; otherwise.
		/// &lt;/returns&gt;
		public static bool TryParse(string s, out SqlBoolean value) {
			value = new SqlBoolean();

			if (String.IsNullOrEmpty(s))
				return false;

			if (String.Equals(s, &quot;true&quot;, StringComparison.OrdinalIgnoreCase) ||
				String.Equals(s, &quot;1&quot;)) {
				value = True;
				return true;
			}
			if (String.Equals(s, &quot;false&quot;, StringComparison.OrdinalIgnoreCase) ||
				String.Equals(s, &quot;0&quot;)) {
				value = False;
				return true;
			}

			return false;
		}

		/// &lt;inheritdoc/&gt;
		public override string ToString() {
			if (value == null)
				return &quot;NULL&quot;;
			if (value == 1)
				return &quot;true&quot;;
			if (value == 0)
				return &quot;false&quot;;

			throw new InvalidOperationException(&quot;Should never happen!&quot;);
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[63,5,63,52,0],[82,4,82,29,0],[83,5,83,35,0],[85,4,85,39,0],[92,6,92,15,0],[100,6,100,26,0],[108,11,108,35,0],[109,5,109,39,0],[111,5,111,130,0],[145,4,145,17,0],[153,4,153,29,0],[154,5,154,18,0],[156,4,156,36,0],[164,5,164,18,0],[173,4,173,57,0],[177,4,177,28,0],[181,4,181,16,0],[185,4,185,37,0],[189,4,189,60,0],[193,4,193,22,0],[194,5,194,40,0],[196,4,196,23,0],[200,4,200,60,0],[204,4,204,61,0],[208,4,208,22,0],[209,5,209,40,0],[211,4,211,23,0],[215,4,215,59,0],[219,4,219,52,0],[223,4,223,53,0],[227,4,227,52,0],[231,4,231,52,0],[235,4,235,52,0],[239,4,239,37,0],[243,4,243,22,0],[247,4,247,40,0],[248,5,248,24,0],[250,4,250,114,0],[256,5,256,14,0],[259,5,259,15,0],[293,4,293,21,0],[306,5,306,38,0],[339,4,339,32,0],[340,5,340,42,0],[343,4,343,32,0],[344,5,344,33,0],[346,4,346,17,0],[383,4,383,17,0],[395,4,395,64,0],[60,6,60,12,1],[61,4,62,16,1],[65,4,65,23,1],[66,3,66,4,1],[72,3,73,33,1],[74,3,74,4,1],[77,6,77,12,1],[78,4,78,23,1],[79,3,79,4,1],[90,4,90,25,1],[91,5,91,16,1],[93,5,93,14,1],[97,4,97,27,1],[98,5,98,33,1],[99,5,99,20,1],[101,12,101,37,1],[102,6,102,26,1],[103,12,103,38,1],[104,6,104,27,1],[106,6,106,138,1],[114,4,114,35,1],[119,10,119,31,1],[137,4,137,48,1],[138,5,138,17,1],[140,4,140,27,1],[141,5,141,33,1],[142,5,142,58,1],[150,4,150,33,1],[151,5,151,17,1],[161,4,161,31,1],[162,5,162,17,1],[163,4,163,32,1],[165,4,165,32,1],[166,5,166,18,1],[168,4,168,37,1],[255,4,255,31,1],[258,4,258,32,1],[260,4,260,32,1],[261,5,261,14,1],[263,4,263,52,1],[275,4,275,23,1],[285,4,285,21,1],[289,4,289,23,1],[305,4,305,21,1],[308,4,308,28,1],[320,4,320,33,1],[367,4,367,29,1],[369,4,369,32,1],[370,5,370,18,1],[372,4,373,27,1],[374,5,374,18,1],[375,5,375,17,1],[377,4,378,27,1],[379,5,379,19,1],[380,5,380,17,1],[388,4,388,22,1],[389,5,389,19,1],[390,4,390,19,1],[391,5,391,19,1],[392,4,392,19,1],[393,5,393,20,1],[39,3,39,62,1],[44,3,44,63,1],[49,3,49,65,1]]);
    </script>
  </body>
</html>