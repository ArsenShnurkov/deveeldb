<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>c:\dev\deveel\deveeldb\src\deveeldb\deveel.data.security\securityqueryextensions.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
// 
//  Copyright 2010-2015 Deveel
// 
//    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at
// 
//        http://www.apache.org/licenses/LICENSE-2.0
// 
//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.
//

using System;

using Deveel.Data.DbSystem;
using Deveel.Data.Protocol;
using Deveel.Data.Routines;
using Deveel.Data.Sql;
using Deveel.Data.Sql.Expressions;
using Deveel.Data.Transactions;

namespace Deveel.Data.Security {
	public static class SecurityQueryExtensions {
		private static bool UserCanAccessFromHost(this IQueryContext queryContext, string username, ConnectionEndPoint endPoint) {
			// The system user is not allowed to login
			if (String.Equals(username, User.SystemName, StringComparison.OrdinalIgnoreCase))
				return false;

			// What&#39;s the protocol?
			string protocol = endPoint.Protocol;
			string host = endPoint.Address;

			// The table to check
			var connectPriv = queryContext.GetTable(SystemSchema.UserConnectPrivilegesTableName);
			var unCol = connectPriv.GetResolvedColumnName(0);
			var protoCol = connectPriv.GetResolvedColumnName(1);
			var hostCol = connectPriv.GetResolvedColumnName(2);
			var accessCol = connectPriv.GetResolvedColumnName(3);

			// Query: where UserName = %username%
			var t = connectPriv.SimpleSelect(queryContext, unCol, SqlExpressionType.Equal, SqlExpression.Constant(username));
			// Query: where %protocol% like Protocol
			var exp = SqlExpression.Binary(SqlExpression.Constant(protocol), SqlExpressionType.Like, SqlExpression.Reference(protoCol));
			t = t.ExhaustiveSelect(queryContext, exp);
			// Query: where %host% like Host
			exp = SqlExpression.Binary(SqlExpression.Constant(host), SqlExpressionType.Like, SqlExpression.Reference(hostCol));
			t = t.ExhaustiveSelect(queryContext, exp);

			// Those that are DENY
			var t2 = t.SimpleSelect(queryContext, accessCol, SqlExpressionType.Equal, SqlExpression.Constant(DataObject.BooleanFalse));
			if (t2.RowCount &gt; 0)
				return false;

			// Those that are ALLOW
			var t3 = t.SimpleSelect(queryContext, accessCol, SqlExpressionType.Equal, SqlExpression.Constant(DataObject.BooleanTrue));
			if (t3.RowCount &gt; 0)
				return true;

			// No DENY or ALLOW entries for this host so deny access.
			return false;
		}

		public static bool UserBelongsToGroup(this IQueryContext queryContext, string username, string group) {
			// This is a special query that needs to access the lowest level of ITable, skipping
			// other security controls
			var table = queryContext.Session.Transaction.GetTable(SystemSchema.UserPrivilegesTableName);
			var c1 = table.GetResolvedColumnName(0);
			var c2 = table.GetResolvedColumnName(1);
			// All &#39;user_priv&#39; where UserName = %username%
			var t = table.SimpleSelect(queryContext, c1, SqlExpressionType.Equal, SqlExpression.Constant(username));
			// All from this set where PrivGroupName = %group%
			t = t.SimpleSelect(queryContext, c2, SqlExpressionType.Equal, SqlExpression.Constant(group));
			return t.RowCount &gt; 0;
		}

		public static void AddUserToGroup(this IQueryContext queryContext, string username, string group) {
			if (String.IsNullOrEmpty(group))
				throw new ArgumentNullException(&quot;group&quot;);
			if (String.IsNullOrEmpty(username))
				throw new ArgumentNullException(&quot;username&quot;);

			char c = group[0];
			if (c == &#39;@&#39; || c == &#39;&amp;&#39; || c == &#39;#&#39; || c == &#39;$&#39;)
				throw new ArgumentException(String.Format(&quot;Group name &#39;{0}&#39; is invalid: cannot start with {1}&quot;, group, c), &quot;group&quot;);

			if (!queryContext.UserBelongsToGroup(username, group)) {
				var table = queryContext.GetMutableTable(SystemSchema.UserPrivilegesTableName);
				var row = table.NewRow();
				row.SetValue(0, username);
				row.SetValue(1, group);
				table.AddRow(row);
			}
		}

		public static void SetUserLock(this IQueryContext queryContext, string username, bool lockStatus) {
			// Internally we implement this by adding the user to the #locked group.
			var table = queryContext.GetMutableTable(SystemSchema.UserPrivilegesTableName);
			var c1 = table.GetResolvedColumnName(0);
			var c2 = table.GetResolvedColumnName(1);
			// All &#39;user_priv&#39; where UserName = %username%
			var t = table.SimpleSelect(queryContext, c1, SqlExpressionType.Equal, SqlExpression.Constant(username));
			// All from this set where PrivGroupName = %group%
			t = t.SimpleSelect(queryContext, c2, SqlExpressionType.Equal, SqlExpression.Constant(SystemGroupNames.LockGroup));

			bool userBelongsToLockGroup = t.RowCount &gt; 0;
			if (lockStatus &amp;&amp; !userBelongsToLockGroup) {
				// Lock the user by adding the user to the Lock group
				// Add this user to the locked group.
				var rdat = new Row(table);
				rdat.SetValue(0, username);
				rdat.SetValue(1, SystemGroupNames.LockGroup);
				table.AddRow(rdat);
			} else if (!lockStatus &amp;&amp; userBelongsToLockGroup) {
				// Unlock the user by removing the user from the Lock group
				// Remove this user from the locked group.
				table.Delete(t);
			}
		}

		public static void GrantHostAccessToUser(this IQueryContext queryContext, string user, string protocol, string host) {
			// The user connect priv table
			var table = queryContext.GetMutableTable(SystemSchema.UserConnectPrivilegesTableName);
			// Add the protocol and host to the table
			var rdat = new Row(table);
			rdat.SetValue(0, user);
			rdat.SetValue(1, protocol);
			rdat.SetValue(2, host);
			rdat.SetValue(3, true);
			table.AddRow(rdat);
		}

		public static bool UserExists(this IQueryContext context, string userName) {
			var table = context.GetTable(SystemSchema.UserTableName);
			var c1 = table.GetResolvedColumnName(0);

			// All password where UserName = %username%
			var t = table.SimpleSelect(context, c1, SqlExpressionType.Equal, SqlExpression.Constant(userName));
			return t.RowCount &gt; 0;
		}

		public static void GrantToUserOn(this IQueryContext context, DbObjectType objectType, ObjectName objectName,
			User user, Privileges privileges, bool withOption = false) {
			GrantToUserOn(context, objectType, objectName, user, context.User(), privileges, withOption);
		}

		public static void GrantToUserOn(this IQueryContext context, DbObjectType objectType, ObjectName objectName,
			User user, User granter, Privileges privileges, bool withOption = false) {
			if (!context.ObjectExists(objectType, objectName))
				throw new ObjectNotFoundException(objectName);

			Privileges oldPrivs = context.GetUserGrants(user, objectType, objectName);
			privileges |= oldPrivs;

			if (!oldPrivs.Equals(privileges))
				context.UpdateUserGrants(objectType, objectName, user, granter, privileges, withOption);
		}

		public static void GrantToUserOnSchemaTables(this IQueryContext context, string schemaName, User user, User granter,
			Privileges privileges) {
			context.GrantToUserOnSchemaObjects(schemaName, DbObjectType.Table, user, granter, privileges);
		}

		public static void GrantToUserOnSchemaObjects(this IQueryContext context, string schemaName, DbObjectType objectType, User user,
			User granter, Privileges privileges) {
			// TODO: Query for all objects of the given type in the schema
 			//       and grant the given privileges..
		}

		private static void UpdateUserGrants(this IQueryContext context, DbObjectType objectType, ObjectName objectName,
			User user, User granter, Privileges privileges, bool withOption) {
			// Revoke existing privs on this object for this grantee
			context.RevokeAllFromUserOn(objectType, objectName, user, granter, withOption);

			if (privileges != Privileges.None) {
				// The system grants table.
				var grantTable = context.GetMutableTable(SystemSchema.UserGrantsTableName);

				// Add the grant to the grants table.
				var rdat = grantTable.NewRow();
				rdat.SetValue(0, (int)privileges);
				rdat.SetValue(1, (int)objectType);
				rdat.SetValue(2, objectName.FullName);
				rdat.SetValue(3, user.Name);
				rdat.SetValue(4, withOption);
				rdat.SetValue(5, granter.Name);
				grantTable.AddRow(rdat);

				user.CacheObjectGrant(objectName, privileges);
			}
		}

		public static void RevokeAllFromUserOn(this IQueryContext context, DbObjectType objectType, ObjectName objectName,
			User user, User revoker, bool withOption = false) {
			context.RevokeAllGrants(objectType, objectName, user, revoker, withOption);
		}

		private static void RevokeAllGrants(this IQueryContext context, DbObjectType objectType, ObjectName objectName,
			User user, User revoker, bool withOption = false) {
			var grantTable = context.GetMutableTable(SystemSchema.UserGrantsTableName);

			var objectCol = grantTable.GetResolvedColumnName(1);
			var paramCol = grantTable.GetResolvedColumnName(2);
			var granteeCol = grantTable.GetResolvedColumnName(3);
			var grantOptionCol = grantTable.GetResolvedColumnName(4);
			var granterCol = grantTable.GetResolvedColumnName(5);

			ITable t1 = grantTable;

			// All that match the given object parameter
			// It&#39;s most likely this will reduce the search by the most so we do
			// it first.
			t1 = t1.SimpleSelect(context, paramCol, SqlExpressionType.Equal,
									   SqlExpression.Constant(DataObject.String(objectName.FullName)));

			// The next is a single exhaustive select through the remaining records.
			// It finds all grants that match either public or the grantee is the
			// username, and that match the object type.

			// Expression: (&quot;grantee_col&quot; = username)
			var userCheck = SqlExpression.Equal(SqlExpression.Reference(granteeCol),
				SqlExpression.Constant(DataObject.String(user.Name)));

			// Expression: (&quot;object_col&quot; = object AND
			//              &quot;grantee_col&quot; = username)
			// All that match the given username or public and given object
			var expr =
				SqlExpression.And(
					SqlExpression.Equal(SqlExpression.Reference(objectCol),
						SqlExpression.Constant(DataObject.BigInt((int) objectType))), userCheck);

			// Are we only searching for grant options?
			var grantOptionCheck = SqlExpression.Equal(SqlExpression.Reference(grantOptionCol),
				SqlExpression.Constant(DataObject.Boolean(withOption)));
			expr = SqlExpression.And(expr, grantOptionCheck);

			// Make sure the granter matches up also
			var granterCheck = SqlExpression.Equal(SqlExpression.Reference(granterCol),
				SqlExpression.Constant(DataObject.String(revoker.Name)));
			expr = SqlExpression.And(expr, granterCheck);

			t1 = t1.ExhaustiveSelect(context, expr);

			// Remove these rows from the table
			grantTable.Delete(t1);

			user.ClearGrantCache(objectName);
		}

		public static void GrantToUserOnSchema(this IQueryContext context, string schemaName, User user, Privileges privileges, bool withOption = false) {
			GrantToUserOnSchema(context, schemaName, user, context.User(), privileges, withOption);
		}

		public static void GrantToUserOnSchema(this IQueryContext context, string schemaName, User user, User granter, Privileges privileges, bool withOption = false) {
			context.GrantToUserOn(DbObjectType.Schema, new ObjectName(schemaName), user, granter, privileges, withOption);
		}

		public static Privileges GetUserGrants(this IQueryContext context, User user, DbObjectType objectType,
			ObjectName objectName, bool includePublic = false, bool onlyOption = false) {
			Privileges privileges;
			if (!user.TryGetObjectGrant(objectName, out privileges)) {
				privileges = context.GetUserGrants(user.Name, objectType, objectName);
				user.CacheObjectGrant(objectName, privileges);
			}

			return privileges;
		}

		public static Privileges GetUserGrants(this IQueryContext context, string userName, DbObjectType objType, ObjectName objName, bool includePublicPrivs = false, bool onlyGrantOptions = false) {
			// The system grants table.
			var grantTable = context.GetTable(SystemSchema.UserGrantsTableName);

			var objectCol = grantTable.GetResolvedColumnName(1);
			var paramCol = grantTable.GetResolvedColumnName(2);
			var granteeCol = grantTable.GetResolvedColumnName(3);
			var grantOptionCol = grantTable.GetResolvedColumnName(4);

			ITable t1 = grantTable;

			// All that match the given object parameter
			// It&#39;s most likely this will reduce the search by the most so we do
			// it first.
			t1 = t1.SimpleSelect(context, paramCol, SqlExpressionType.Equal, SqlExpression.Constant(DataObject.String(objName.FullName)));

			// The next is a single exhaustive select through the remaining records.
			// It finds all grants that match either public or the grantee is the
			// username, and that match the object type.

			// Expression: (&quot;grantee_col&quot; = username OR &quot;grantee_col&quot; = &#39;public&#39;)
			var userCheck = SqlExpression.Equal(SqlExpression.Reference(granteeCol), SqlExpression.Constant(DataObject.String(userName)));
			if (includePublicPrivs) {
				userCheck = SqlExpression.Or(userCheck, SqlExpression.Equal(SqlExpression.Reference(granteeCol),
					SqlExpression.Constant(DataObject.String(User.PublicName))));
			}

			// Expression: (&quot;object_col&quot; = object AND
			//              (&quot;grantee_col&quot; = username OR &quot;grantee_col&quot; = &#39;public&#39;))
			// All that match the given username or public and given object
			var expr = SqlExpression.And(SqlExpression.Equal(SqlExpression.Reference(objectCol),
				SqlExpression.Constant(DataObject.BigInt((int)objType))), userCheck);

			// Are we only searching for grant options?
			if (onlyGrantOptions) {
				var grantOptionCheck = SqlExpression.Equal(SqlExpression.Reference(grantOptionCol),
					SqlExpression.Constant(DataObject.BooleanTrue));
				expr = SqlExpression.And(expr, grantOptionCheck);
			}

			t1 = t1.ExhaustiveSelect(context, expr);

			// For each grant, merge with the resultant priv object
			Privileges privs = Privileges.None;

			foreach (var row in t1) {
				var priv = (int)row.GetValue(0).AsBigInt();
				privs |= (Privileges)priv;
			}

			return privs;
		}

		public static User CreateUser(this IQueryContext context, string userName, string password) {
			if (String.IsNullOrEmpty(userName))
				throw new ArgumentNullException(&quot;userName&quot;);
			if (String.IsNullOrEmpty(password))
				throw new ArgumentNullException(&quot;password&quot;);

			// TODO: make these rules configurable?

			if (userName.Length &lt;= 1)
				throw new ArgumentException(&quot;User name must be at least one character.&quot;, &quot;userName&quot;);
			if (password.Length &lt;= 1)
				throw new ArgumentException(&quot;The password must be at least one character.&quot;, &quot;password&quot;);

			if (String.Equals(userName, User.PublicName, StringComparison.OrdinalIgnoreCase))
				throw new ArgumentException(String.Format(&quot;User name &#39;{0}&#39; is reserved and cannot be registered.&quot;, User.PublicName), &quot;userName&quot;);

			var c = userName[0];
			if (c == &#39;#&#39; || c == &#39;@&#39; || c == &#39;$&#39; || c == &#39;&amp;&#39;)
				throw new ArgumentException(String.Format(&quot;User name &#39;{0}&#39; is invalid: cannot start with &#39;{1}&#39; character.&quot;, userName, c), &quot;userName&quot;);
			if (context.UserExists(userName))
				throw new DatabaseSystemException(String.Format(&quot;User &#39;{0}&#39; is already registered.&quot;, userName));

			// Add to the key &#39;user&#39; table
			var table = context.GetMutableTable(SystemSchema.UserTableName);
			var row = table.NewRow();
			row[0] = DataObject.String(userName);
			table.AddRow(row);

			// TODO: get the hash algorithm and hash ...

			table = context.GetMutableTable(SystemSchema.PasswordTableName);
			row = table.NewRow();
			row.SetValue(0, userName);
			row.SetValue(1, 1);
			row.SetValue(2, password);
			table.AddRow(row);

			return new User(userName);
		}

		public static User Authenticate(this IQueryContext queryContext, string username, string password,
			ConnectionEndPoint endPoint) {
			try {
				var table = queryContext.GetTable(SystemSchema.PasswordTableName);
				var unameColumn = table.GetResolvedColumnName(0);
				var typeColumn = table.GetResolvedColumnName(1);
				var passwColumn = table.GetResolvedColumnName(2);
				var saltColumn = table.GetResolvedColumnName(3);
				var hashColumn = table.GetResolvedColumnName(4);

				var t = table.SimpleSelect(queryContext, unameColumn, SqlExpressionType.Equal, SqlExpression.Constant(username));
				if (t.RowCount == 0)
					return null;

				var type = t.GetValue(0, typeColumn);
				if (type == 1) {
					// Clear-text password ...
					var pass = t.GetValue(0, passwColumn);
					if (pass.IsNull || !pass.Equals(DataObject.String(password)))
						return null;

				} else if (type == 2) {
					// Hashed password ...
					var pass = t.GetValue(0, passwColumn);
					var salt = t.GetValue(0, saltColumn);
					var hash = t.GetValue(0, hashColumn);

					if (pass == null || salt == null || hash == null)
						return null;

					var crypto = PasswordCrypto.Parse(hash);
					if (!crypto.Verify(pass, password, salt))
						return null;
				} else if (type == 3) {
					// External authenticator ...
					// TODO:
				}

				// Now check if this user is permitted to connect from the given
				// host.
				if (!UserCanAccessFromHost(queryContext, username, endPoint))
					return null;

				// Successfully authenticated...
				return new User(username);
			} catch (Exception ex) {
				throw new DatabaseSystemException(&quot;Could not authenticate user.&quot;, ex);
			}
		}

		public static bool UserHasPrivilege(this IQueryContext context, DbObjectType objectType, ObjectName objectName,
	Privileges privileges) {
			return context.Session.UserHasPrivilege(objectType, objectName, privileges);
		}

		public static bool UserHasSchemaPrivilege(this IQueryContext context, string schemaName, Privileges privileges) {
			return context.UserHasPrivilege(DbObjectType.Schema, new ObjectName(schemaName), privileges);
		}

		public static bool UserCanCreateInSchema(this IQueryContext context, string schemaName) {
			return context.UserHasSchemaPrivilege(schemaName, Privileges.Create);
		}

		public static bool UserCanCreateTable(this IQueryContext context, ObjectName tableName) {
			var schema = tableName.Parent;
			if (schema == null)
				return false;

			return context.UserCanCreateInSchema(schema.FullName);
		}

		public static bool UserCanExecute(this IQueryContext context, RoutineType routineType, ObjectName routineName) {
			var objectType = routineType == RoutineType.Procedure ? DbObjectType.Procedure : DbObjectType.Function;
			return context.UserHasPrivilege(objectType, routineName, Privileges.Execute);
		}

		public static bool UserCanExecuteFunction(this IQueryContext context, ObjectName functionName) {
			return context.UserCanExecute(RoutineType.Function, functionName);
		}

		public static bool UserCanExecuteProcedure(this IQueryContext context, ObjectName procedureName) {
			return context.UserCanExecute(RoutineType.Procedure, procedureName);
		}

		public static void GrantToUserOn(this IQueryContext context, DbObjectType objectType, ObjectName objectName, Privileges privileges) {
			using (var systemContext = context.ForSystemUser()) {
				systemContext.GrantToUserOn(objectType, objectName, context.User(), privileges);
			}
		}

		public static void GrantToUserOnTable(this IQueryContext context, ObjectName tableName, Privileges privileges) {
			context.GrantToUserOn(DbObjectType.Table, tableName, privileges);
		}

		public static void GrantToUserOnTable(this IQueryContext context, ObjectName tableName, User grantee, Privileges privileges) {
			context.GrantToUserOn(DbObjectType.Table, tableName, grantee, privileges);
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[31,5,31,18,0],[56,5,56,18,0],[64,4,64,17,0],[82,5,82,46,0],[84,5,84,49,0],[88,5,88,121,0],[101,4,101,83,0],[102,4,102,44,0],[103,4,103,44,0],[105,4,105,108,0],[107,4,107,118,0],[109,4,109,49,0],[110,4,110,46,0],[113,5,113,31,0],[114,5,114,32,0],[115,5,115,50,0],[116,5,116,24,0],[117,11,117,53,0],[120,5,120,21,0],[122,3,122,4,0],[153,5,153,51,0],[254,4,254,91,0],[255,3,255,4,0],[295,5,296,67,0],[307,5,308,54,0],[309,5,309,54,0],[317,13,317,20,0],[318,5,318,48,0],[319,5,319,31,0],[327,5,327,49,0],[329,5,329,49,0],[334,5,334,90,0],[336,5,336,93,0],[339,5,339,134,0],[343,5,343,139,0],[345,5,345,101,0],[377,6,377,18,0],[384,7,384,19,0],[386,12,386,26,0],[388,6,388,44,0],[389,6,389,43,0],[390,6,390,43,0],[392,6,392,55,0],[393,7,393,19,0],[395,6,395,46,0],[396,6,396,47,0],[397,7,397,19,0],[398,12,398,26,0],[406,6,406,18,0],[410,6,410,26,0],[411,5,411,75,0],[431,5,431,18,0],[446,4,446,72,0],[460,4,460,78,0],[461,3,461,4,0],[30,4,30,85,1],[34,4,34,40,1],[35,4,35,35,1],[38,4,38,89,1],[39,4,39,53,1],[40,4,40,56,1],[41,4,41,55,1],[42,4,42,57,1],[45,4,45,117,1],[47,4,47,128,1],[48,4,48,46,1],[50,4,50,119,1],[51,4,51,46,1],[54,4,54,127,1],[55,4,55,24,1],[59,4,59,126,1],[60,4,60,24,1],[61,5,61,17,1],[70,4,70,96,1],[71,4,71,44,1],[72,4,72,44,1],[74,4,74,108,1],[76,4,76,97,1],[77,4,77,26,1],[81,4,81,36,1],[83,4,83,39,1],[86,4,86,22,1],[87,4,87,53,1],[90,4,90,58,1],[91,5,91,84,1],[92,5,92,30,1],[93,5,93,31,1],[94,5,94,28,1],[95,5,95,23,1],[97,3,97,4,1],[126,4,126,90,1],[128,4,128,30,1],[129,4,129,27,1],[130,4,130,31,1],[131,4,131,27,1],[132,4,132,27,1],[133,4,133,23,1],[134,3,134,4,1],[137,4,137,61,1],[138,4,138,44,1],[141,4,141,103,1],[142,4,142,26,1],[147,4,147,97,1],[148,3,148,4,1],[152,4,152,54,1],[155,4,155,78,1],[156,4,156,27,1],[158,4,158,37,1],[159,5,159,93,1],[160,3,160,4,1],[164,4,164,98,1],[165,3,165,4,1],[171,3,171,4,1],[176,4,176,83,1],[178,4,178,38,1],[180,5,180,80,1],[183,5,183,36,1],[184,5,184,39,1],[185,5,185,39,1],[186,5,186,43,1],[187,5,187,33,1],[188,5,188,34,1],[189,5,189,36,1],[190,5,190,29,1],[192,5,192,51,1],[194,3,194,4,1],[198,4,198,79,1],[199,3,199,4,1],[203,4,203,79,1],[205,4,205,56,1],[206,4,206,55,1],[207,4,207,57,1],[208,4,208,61,1],[209,4,209,57,1],[211,4,211,27,1],[216,4,217,77,1],[224,4,225,59,1],[230,4,233,80,1],[236,4,237,61,1],[238,4,238,53,1],[241,4,242,62,1],[243,4,243,49,1],[245,4,245,44,1],[248,4,248,26,1],[250,4,250,37,1],[251,3,251,4,1],[258,4,258,114,1],[259,3,259,4,1],[264,4,264,60,1],[265,5,265,75,1],[266,5,266,51,1],[269,4,269,22,1],[274,4,274,72,1],[276,4,276,56,1],[277,4,277,55,1],[278,4,278,57,1],[279,4,279,61,1],[281,4,281,27,1],[286,4,286,130,1],[293,4,293,130,1],[294,4,294,27,1],[302,4,303,74,1],[306,4,306,25,1],[312,4,312,44,1],[315,4,315,39,1],[317,24,317,26,1],[317,21,317,23,1],[322,4,322,17,1],[326,4,326,39,1],[328,4,328,39,1],[333,4,333,29,1],[335,4,335,29,1],[338,4,338,85,1],[341,4,341,24,1],[342,4,342,53,1],[344,4,344,37,1],[348,4,348,68,1],[349,4,349,29,1],[350,4,350,41,1],[351,4,351,22,1],[355,4,355,68,1],[356,4,356,25,1],[357,4,357,30,1],[358,4,358,23,1],[359,4,359,30,1],[360,4,360,22,1],[362,4,362,30,1],[368,5,368,71,1],[369,5,369,54,1],[370,5,370,53,1],[371,5,371,54,1],[372,5,372,53,1],[373,5,373,53,1],[375,5,375,118,1],[376,5,376,25,1],[379,5,379,42,1],[380,5,380,19,1],[382,6,382,44,1],[383,6,383,67,1],[405,5,405,66,1],[409,5,409,31,1],[413,3,413,4,1],[417,4,417,80,1],[421,4,421,97,1],[425,4,425,73,1],[429,4,429,34,1],[430,4,430,23,1],[433,4,433,58,1],[437,4,437,107,1],[438,4,438,81,1],[442,4,442,70,1],[450,11,450,54,1],[451,5,451,85,1],[453,3,453,4,1],[456,4,456,69,1],[457,3,457,4,1]]);
    </script>
  </body>
</html>