//  
//  DatabaseConnection.cs
//  
//  Author:
//       Antonello Provenzano <antonello@deveel.com>
//       Tobias Downer <toby@mckoi.com>
// 
//  Copyright (c) 2009 Deveel
// 
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
// 
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
// 
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.

using System;
using System.Collections;
using System.Data;

using Deveel.Data.Client;
using Deveel.Diagnostics;

namespace Deveel.Data {
	/// <summary>
	/// An object that represents a connection to a <see cref="Data.Database"/>.
	/// </summary>
	/// <remarks>
	/// This object handles all transactional queries and modifications to 
	/// the database.
	/// </remarks>
	public class DatabaseConnection : ITriggerListener, IDisposable {
		/// <summary>
		/// The User that this connection has been made by.
		/// </summary>
		private User user;

		/// <summary>
		/// The Database object that this connection is on.
		/// </summary>
		private readonly Database database;

		/// <summary>
		///  A loop-back object that is managing this connection.  This typically is
		/// the session protocol.  This is notified of all connection events, such as
		/// triggers.
		/// </summary>
		private readonly CallBack call_back;

		/// <summary>
		/// The locking mechanism within this connection.
		/// </summary>
		private readonly LockingMechanism locking_mechanism;

		/// <summary>
		/// The <see cref="TableDataConglomerate"/> object that is used for 
		/// transactional access to the data.
		/// </summary>
		private readonly TableDataConglomerate conglomerate;

		/// <summary>
		/// The current Transaction that this connection is operating within.
		/// </summary>
		private Transaction transaction;

		/// <summary>
		/// The current <see cref="IDbConnection"/> object that can be used 
		/// to access the transaction internally.
		/// </summary>
		private DeveelDbConnection db_connection;

		/// <summary>
		/// A Hashtable of DataTable objects that have been created within this connection.
		/// </summary>
		private readonly Hashtable tables_cache;

		/// <summary>
		/// A buffer of triggers.  This contains triggers that can't fire until
		/// the current transaction has closed.  These triggers were generated by
		/// external actions outside of the context of this transaction.
		/// </summary>
		private readonly ArrayList trigger_event_buffer;

		/// <summary>
		/// A list of triggers that are fired by actions taken on tables in this
		/// transaction.  When the transaction is successfully committed, these
		/// trigger events need to be propogated to other connections in the database
		/// listening for trigger events on the triggered objects.
		/// </summary>
		private readonly ArrayList trigger_event_list;

		/// <summary>
		/// If this is true then the database connection is in 'auto-commit' mode.
		/// This implies a COMMIT instruction is executed after every complete
		/// statement in the language grammar.  By default this is true.
		/// </summary>
		private bool auto_commit;

		/// <summary>
		/// The current transaction isolation level this connect is operating under.
		/// </summary>
		private IsolationLevel transaction_isolation;

		/// <summary>
		/// A flag which if set to true, will not allow 'commit' or 'rollback'
		/// commands on the transaction to occur and therefore prevent any open
		/// transaction from closing.  This is useful for restricting the ability
		/// of a stored procedure to close.
		/// </summary>
		private bool close_transaction_disabled;

		/// <summary>
		/// The name of the schema that this connection is currently in.  If the
		/// schema is "" then this connection is in the default schema (effectively
		/// no schema).
		/// </summary>
		private String current_schema;

		/// <summary>
		/// The GrantManager object for this connection.
		/// </summary>
		private GrantManager grant_manager;

		/// <summary>
		/// The procedure manager object for this connection.
		/// </summary>
		private ProcedureManager procedure_manager;

		/// <summary>
		/// The connection trigger manager that handles actions that cause triggers
		/// to fire on this connection.
		/// </summary>
		private ConnectionTriggerManager connection_trigger_manager;

		/// <summary>
		/// The connection view manager that handles view information through this
		/// connection.
		/// </summary>
		private ViewManager view_manager;

		/// <summary>
		/// The list of all TableBackedCache objects that have been attached to this
		/// DatabaseConnection and are to be notified of transaction start/end
		/// events.
		/// </summary>
		private ArrayList table_backed_cache_list;

		/// <summary>
		/// A local member that represents the static list of internal tables
		/// that represent connection specific properties such as username,
		/// connection, statistics, etc.
		/// </summary>
		private readonly ConnectionInternalTableInfo connection_internal_table_info;

		// ----- Local flags -----

		/// <summary>
		/// True if transactions through this connection generate an error when
		/// there is a dirty select on a table.
		/// </summary>
		private bool error_on_dirty_select;

		/// <summary>
		/// True if this connection resolves identifiers case insensitive.
		/// </summary>
		private bool case_insensitive_identifiers;

		// ----- OLD and NEW table information for triggers -----

		/// <summary>
		/// A local member that represents the OLD and NEW system tables that
		/// represent the OLD and NEW data in a triggered action.
		/// </summary>
		private readonly OldAndNewInternalTableInfo old_new_table_info;

		/// <summary>
		/// The current state of the OLD and NEW system tables including any cached
		/// information about the tables.
		/// </summary>
		private OldNewTableState current_old_new_state = new OldNewTableState();


		internal DatabaseConnection(Database database, User user, CallBack call_back) {
			this.database = database;
			this.user = user;
			this.call_back = call_back;
			conglomerate = database.Conglomerate;
			locking_mechanism = new LockingMechanism();
			trigger_event_buffer = new ArrayList();
			trigger_event_list = new ArrayList();
			tables_cache = new Hashtable();
			auto_commit = true;

			current_schema = Database.DefaultSchema;
			close_transaction_disabled = false;

			table_backed_cache_list = new ArrayList();

			connection_internal_table_info = new ConnectionInternalTableInfo(this);
			old_new_table_info = new OldAndNewInternalTableInfo(this);

			error_on_dirty_select = database.System.TransactionErrorOnDirtySelect;
			case_insensitive_identifiers = database.System.IgnoreIdentifierCase;

		}

		/// <summary>
		/// Initializes this <see cref="DatabaseConnection"/> (possibly by initializing 
		/// state from the database).
		/// </summary>
		internal void Init() {
			// Create the grant manager for this connection.
			grant_manager = new GrantManager(this);
			// Create the procedure manager for this connection.
			procedure_manager = new ProcedureManager(this);
			// Create the connection trigger manager object
			connection_trigger_manager = new ConnectionTriggerManager(this);
			// Create the view manager
			view_manager = new ViewManager(this);
		}

		/// <summary>
		/// Gets the underlying transaction.
		/// </summary>
		/// <remarks>
		/// If none transaction was already open, it opens a new one
		/// with the underlying conglomerate.
		/// </remarks>
		private Transaction Transaction {
			get {
				lock (this) {
					if (transaction == null) {
						transaction = conglomerate.CreateTransaction();
						transaction.TransactionErrorOnDirtySelect = error_on_dirty_select;
						// Internal tables (connection statistics, etc)
						transaction.AddInternalTableInfo(connection_internal_table_info);
						// OLD and NEW system tables (if applicable)
						transaction.AddInternalTableInfo(old_new_table_info);
						// Model views as tables (obviously)
						transaction.AddInternalTableInfo(
							ViewManager.CreateInternalTableInfo(view_manager, transaction));
						// Model procedures as tables
						transaction.AddInternalTableInfo(
							ProcedureManager.CreateInternalTableInfo(transaction));
						// Model sequences as tables
						transaction.AddInternalTableInfo(
							SequenceManager.CreateInternalTableInfo(transaction));
						// Model triggers as tables
						transaction.AddInternalTableInfo(
							ConnectionTriggerManager.CreateInternalTableInfo(transaction));

						// Notify any table backed caches that this transaction has started.
						int sz = table_backed_cache_list.Count;
						for (int i = 0; i < sz; ++i) {
							TableBackedCache cache =
								(TableBackedCache) table_backed_cache_list[i];
							cache.OnTransactionStarted();
						}
					}
				}
				return transaction;
			}
		}

		/// <summary>
		/// Returns a freshly deserialized IQueryPlanNode object for the given view
		/// object.
		/// </summary>
		/// <param name="table_name">Name of the view to return the query plan node.</param>
		/// <returns></returns>
		internal IQueryPlanNode CreateViewQueryPlanNode(TableName table_name) {
			return view_manager.CreateViewQueryPlanNode(table_name);
		}

		/// <summary>
		/// Creates a <see cref="IDbConnection"/> object that can be 
		/// used as an ADO.NET interface to access the current transaction 
		/// of this <see cref="DatabaseConnection"/>.
		/// </summary>
		/// <remarks>
		/// There are a few important considerations when using the ADO.NET connection:
		/// <list type="bullet">
		///		<item>The returned <see cref="IDbConnection"/> does not allow 
		///		auto-commit to be set. It is intended to be used to issue commands 
		///		to this <see cref="DatabaseConnection"/> from inside a transaction so 
		///		auto-commit does not make sense.</item>
		///		<item>The returned object must only be accessed from the same worker
		///		thread that is currently accessing this <see cref="DatabaseConnection"/>.
		///		The returned <see cref="IDbConnection"/> is <b>not</b> multi-thread 
		///		capable.</item>
		///		<item>The <see cref="IDbConnection"/> returned here is invalidated 
		///		(disposed) when the current transaction is closed (committed or rolled 
		///		back).</item>
		///		<item>This method returns the same <see cref="IDbConnection"/> on multiple 
		///		calls to this method (while a transaction is open).</item>
		///		<item>The <see cref="DatabaseConnection"/> must be locked in 
		///		<see cref="LockingMode.EXCLUSIVE_MODE"/> mode or the queries will fail.</item>
		/// </list>
		/// </remarks>
		/// <returns></returns>
		public DeveelDbConnection GetDbConnection() {
			if (db_connection == null)
				db_connection = InternalDbHelper.CreateDbConnection(User, this);
			return db_connection;
		}

		/// <summary>
		/// Creates an object that implements <see cref="IProcedureConnection"/> 
		/// that provides access to this connection.
		/// </summary>
		/// <param name="user"></param>
		/// <remarks>
		/// Note that this session is set to the user of the privileges that the
		/// procedure executes under when this method returns.
		/// <para>
		/// There must be a 100% guarentee that after this method is called, a call to
		/// <see cref="DisposeProcedureConnection"/> is called which cleans up the state of this
		/// object.
		/// </para>
		/// </remarks>
		/// <returns></returns>
		internal IProcedureConnection CreateProcedureConnection(User user) {
			// Create the IProcedureConnection object,
			DCProcedureConnection c = new DCProcedureConnection(this);
			// Record the current user
			c.previous_user = User;
			// Record the current 'close_transaction_disabled' flag
			c.transaction_disabled_flag = close_transaction_disabled;
			// Set the new user
			SetUser(user);
			// Disable the ability to close a transaction
			close_transaction_disabled = true;
			// Return
			return c;
		}

		/// <summary>
		/// Disposes a <see cref="IProcedureConnection"/> previously created 
		/// by <see cref="CreateProcedureConnection"/>.
		/// </summary>
		/// <param name="connection"></param>
		internal void DisposeProcedureConnection(IProcedureConnection connection) {
			DCProcedureConnection c = (DCProcedureConnection)connection;
			// Revert back to the previous user.
			SetUser(c.previous_user);
			// Revert back to the previous transaction disable status.
			close_transaction_disabled = c.transaction_disabled_flag;
			// Dispose of the connection
			c.dispose();
		}

		/// <summary>
		/// Gets the database system object for this session.
		/// </summary>
		public DatabaseSystem System {
			get { return database.System; }
		}

		/// <summary>
		/// Gets the database object for this session.
		/// </summary>
		public Database Database {
			get { return database; }
		}

		/// <summary>
		/// Gets the conglomerate of this connection.
		/// </summary>
		internal TableDataConglomerate Conglomerate {
			get { return conglomerate; }
		}

		/// <summary>
		/// Sets the user object for this connection.
		/// </summary>
		/// <param name="user">User to set.</param>
		/// <remarks>
		/// This is necessary because we may want to temporarily change the 
		/// user on this session to allow top level queries in a different 
		/// privilege space.
		/// </remarks>
		internal void SetUser(User user) {
			this.user = user;
		}

		/// <summary>
		/// Returns the user for this session.
		/// </summary>
		public User User {
			get { return user; }
		}

		/// <summary>
		/// Returns the connection trigger manager for this connection.
		/// </summary>
		public ConnectionTriggerManager ConnectionTriggerManager {
			get { return connection_trigger_manager; }
		}

		/// <summary>
		/// Returns the GrantManager object that manages grants for tables in the
		/// database for this connection/user.
		/// </summary>
		public GrantManager GrantManager {
			get { return grant_manager; }
		}

		/// <summary>
		/// Returns the ProcedureManager object that manages database functions and
		/// procedures in the database for this connection/user.
		/// </summary>
		public ProcedureManager ProcedureManager {
			get { return procedure_manager; }
		}


		/// <summary>
		/// Gets or sets the <see cref="IsolationLevel"/> for the 
		/// session.
		/// </summary>
		public IsolationLevel TransactionIsolation {
			get { return transaction_isolation; }
			set {
				if (value != IsolationLevel.Serializable)
					throw new ApplicationException("Can not set transaction isolation to " + value);
				transaction_isolation = value;
			}
		}

		/// <summary>
		/// Assigns a variable to the expression for the session.
		/// </summary>
		/// <param name="name"></param>
		/// <param name="exp"></param>
		/// <remarks>
		/// This is a generic way of setting properties of the session.
		/// <para>
		/// Currently supported variables are:
		/// <list type="bullet">
		/// <item><c>ERROR_ON_DIRTY_SELECT</c>: set to <b>true</b> for turning 
		/// the transaction conflict off on the session.</item>
		/// <item><c>CASE_INSENSITIVE_IDENTIFIERS</c>: <b>true</b> means the grammar 
		/// becomes case insensitive for identifiers resolved by the 
		/// grammar.</item>
		/// </list>
		/// </para>
		/// </remarks>
		public void SetVariable(String name, Expression exp) {
			if (name.ToUpper().Equals("ERROR_ON_DIRTY_SELECT")) {
				error_on_dirty_select = ToBooleanValue(exp);
			} else if (name.ToUpper().Equals("CASE_INSENSITIVE_IDENTIFIERS")) {
				case_insensitive_identifiers = ToBooleanValue(exp);
			}
		}

		/// <summary>
		/// Evaluates the expression to a bool value (true or false).
		/// </summary>
		/// <param name="exp"></param>
		/// <returns></returns>
		private static bool ToBooleanValue(Expression exp) {
			bool isNull;
			Boolean b = exp.Evaluate(null, null, null).ToBoolean(out isNull);
			if (isNull)
				throw new StatementException("Expression does not evaluate to a bool (true or false).");
			return b;
		}

		/// <summary>
		/// Gets or sets the auto-commit mode.
		/// </summary>
		/// <remarks>
		/// If this is <b>true</b> then the language layer must execute 
		/// a <c>COMMIT</c> after every statement.
		/// </remarks>
		public bool AutoCommit {
			get { return auto_commit; }
			set { auto_commit = value; }
		}

		/// <summary>
		/// Gets or sets the name of the schema that this connection is within.
		/// </summary>
		public string CurrentSchema {
			get { return current_schema; }
			set { current_schema = value; }
		}

		/// <summary>
		/// Gets or sets a flag indicating if the session must ignore the case
		/// of the identifiers specified in queries.
		/// </summary>
		/// <remarks>
		/// In case insensitive mode the case of identifier strings is 
		/// not important.
		/// </remarks>
		public bool IsInCaseInsensitiveMode {
			get { return case_insensitive_identifiers; }
		}

		/// <summary>
		/// Returns the locking mechanism within the context of the
		/// database session used to manages read/write locking.
		/// </summary>
		public LockingMechanism LockingMechanism {
			get { return locking_mechanism; }
		}

		/// <summary>
		/// Attaches a <see cref="TableBackedCache"/> to 
		/// the session which is notified when a transaction is started and stopped, 
		/// and when the table being backed has changes made to it.
		/// </summary>
		/// <param name="cache">Cache to attach to the session.</param>
		internal void AttachTableBackedCache(TableBackedCache cache) {
			cache.AttachTo(conglomerate);
			table_backed_cache_list.Add(cache);
		}

		/// <summary>
		/// Gets an array of <see cref="TableName"/> that contains the 
		/// list of database tables visible by the underlying transaction.
		/// </summary>
		/// <remarks>
		/// The list returned represents all the queriable tables in
		/// the database.
		/// </remarks>
		public TableName[] Tables {
			get { return Transaction.GetTables(); }
		}

		/// <summary>
		/// Checks the existence of a table within the underlying transaction.
		/// </summary>
		/// <param name="table_name">Name of the table to check.</param>
		/// <remarks>
		/// This method checks if the table exists within the <see cref="CurrentSchema"/>
		/// of the session.
		/// </remarks>
		/// <returns>
		/// Returns <b>true</b> if a table with the given <paramref name="table_name"/>
		/// exists within the underlying transaction, otherwise <b>false</b>.
		/// </returns>
		public bool TableExists(String table_name) {
			return TableExists(new TableName(current_schema, table_name));
		}

		/// <summary>
		/// Checks the existence of a table within the underlying transaction.
		/// </summary>
		/// <param name="table_name">Name of the table to check.</param>
		/// <returns>
		/// Returns <b>true</b> if a table with the given <paramref name="table_name"/>
		/// exists within the underlying transaction, otherwise <b>false</b>.
		/// </returns>
		public bool TableExists(TableName table_name) {
			table_name = SubstituteReservedTableName(table_name);
			return Transaction.TableExists(table_name);
		}

		/// <summary>
		/// Gets the type of he given table.
		/// </summary>
		/// <param name="table_name">Name of the table to get the type.</param>
		/// <remarks>
		/// Currently this is either <i>TABLE</i> or <i>VIEW</i>.
		/// </remarks>
		/// <returns>
		/// Returns a string describing the type of the table identified by the
		/// given <paramref name="table_name"/>.
		/// </returns>
		/// <exception cref="StatementException">
		/// If none table with the given <paramref name="table_name"/> was found 
		/// in the underlying transaction.</exception>
		public String GetTableType(TableName table_name) {
			table_name = SubstituteReservedTableName(table_name);
			return Transaction.GetTableType(table_name);
		}

		/// <summary>
		/// Attempts to resolve the given table name to its correct case assuming
		/// the table name represents a case insensitive version of the name.
		/// </summary>
		/// <param name="table_name">Table name to resolve.</param>
		/// <remarks>
		/// For example, <c>aPP.CuSTOMer</c> may resolve to <c>default.Customer</c>.
		/// If the table name can not resolve to a valid identifier it returns 
		/// the input table name
		/// The actual presence of the table should always be checked by 
		/// calling <see cref="TableExists(TableName)"/> after the  method 
		/// returns.
		/// </remarks>
		/// <returns>
		/// Returns a properly formatted <see cref="TableName"/> if was able to
		/// resolve the given <paramref name="table_name"/>, otherwise returns
		/// the input table name.
		/// </returns>
		public TableName TryResolveCase(TableName table_name) {
			table_name = SubstituteReservedTableName(table_name);
			table_name = Transaction.TryResolveCase(table_name);
			return table_name;
		}

		/// <summary>
		/// Resolves a table name.
		/// </summary>
		/// <param name="name">Name of the table to resolve.</param>
		/// <remarks>
		/// If the schema part of the table name is not present then it is set 
		/// to the <see cref="CurrentSchema"/> of the database session.
		/// If the database is ignoring the case then this will correctly resolve 
		/// the table to the cased version of the table name.
		/// </remarks>
		/// <returns>
		/// Returns a <see cref="TableName"/> representing the properly
		/// formatted table name.
		/// </returns>
		public TableName ResolveTableName(String name) {
			TableName table_name = TableName.Resolve(CurrentSchema, name);
			table_name = SubstituteReservedTableName(table_name);
			if (IsInCaseInsensitiveMode) {
				// Try and resolve the case of the table name,
				table_name = TryResolveCase(table_name);
			}
			return table_name;
		}

		/// <summary>
		/// Resolves the given string to a table name
		/// </summary>
		/// <param name="name">Table name to resolve.</param>
		/// <returns></returns>
		/// <exception cref="StatementException">
		/// If the reference is ambigous or
		/// </exception>
		public TableName ResolveToTableName(String name) {
			TableName table_name = TableName.Resolve(CurrentSchema, name);
			if (String.Compare(table_name.Name, "OLD", true) == 0) {
				return Database.OldTriggerTable;
			} else if (String.Compare(table_name.Name, "NEW", true) == 0) {
				return Database.NewTriggerTable;
			}

			return Transaction.ResolveToTableName(CurrentSchema, name, IsInCaseInsensitiveMode);

		}

		/// <summary>
		/// Gets the meta informations for the given table.
		/// </summary>
		/// <param name="name">Name of the table to return the 
		/// meta informations.</param>
		/// <returns>
		/// Returns the <see cref="DataTableDef"/> representing the meta 
		/// informations for the tabl identified by <paramref name="name"/> 
		/// if found, otherwise <b>null</b>.
		/// </returns>
		public DataTableDef GetDataTableDef(TableName name) {
			name = SubstituteReservedTableName(name);
			return Transaction.GetDataTableDef(name);
		}

		/// <summary>
		/// Gets the table for the given name.
		/// </summary>
		/// <param name="name">Name of the table to return.</param>
		/// <returns>
		/// Returns a <see cref="DataTable"/> that represents the table 
		/// identified by <paramref name="name"/>, otherwise returns 
		/// <b>null</b>.
		/// </returns>
		/// <exception cref="DatabaseException">
		/// If none table was found for the given <paramref name="name"/>.
		/// </exception>
		public DataTable GetTable(TableName name) {
			name = SubstituteReservedTableName(name);

			try {
				// Special handling of NEW and OLD table, we cache the DataTable in the
				// OldNewTableState object,
				if (name.Equals(Database.OldTriggerTable)) {
					if (current_old_new_state.OLD_data_table == null) {
						current_old_new_state.OLD_data_table =
										new DataTable(this, Transaction.GetTable(name));
					}
					return current_old_new_state.OLD_data_table;
				} else if (name.Equals(Database.NewTriggerTable)) {
					if (current_old_new_state.NEW_data_table == null) {
						current_old_new_state.NEW_data_table =
										new DataTable(this, Transaction.GetTable(name));
					}
					return current_old_new_state.NEW_data_table;
				}

				// Ask the transaction for the table
				IMutableTableDataSource table = Transaction.GetTable(name);

				// Is this table in the tables_cache?
				DataTable dtable = (DataTable)tables_cache[table];
				// No, so wrap it around a Datatable and WriteByte it in the cache
				if (dtable == null) {
					dtable = new DataTable(this, table);
					tables_cache[table] = dtable;
				}
				// Return the DataTable
				return dtable;

			} catch (DatabaseException e) {
				Debug.WriteException(e);
				throw new ApplicationException("Database Exception: " + e.Message);
			}

		}

		/// <summary>
		/// Gets the table for the given name.
		/// </summary>
		/// <param name="table_name">Name of the table to return.</param>
		/// <remarks>
		/// This method uses the <see cref="CurrentSchema"/> to get the table.
		/// </remarks>
		/// <returns>
		/// Returns a <see cref="DataTable"/> that represents the table 
		/// identified by <paramref name="table_name"/>, otherwise returns <b>null</b>.
		/// </returns>
		/// <exception cref="DatabaseException">
		/// If none table was found for the given <paramref name="table_name"/>.
		/// </exception>
		public DataTable GetTable(String table_name) {
			return GetTable(new TableName(current_schema, table_name));
		}

		/// <summary>
		/// Creates a new table within the context of the transaction.
		/// </summary>
		/// <param name="table_def">Table meta informations for creating the table.</param>
		/// <exception cref="StatementException">
		/// If the name of the table is reserved and the creation of the table 
		/// should be prevented.
		/// </exception>
		public void CreateTable(DataTableDef table_def) {
			CheckAllowCreate(table_def.TableName);
			Transaction.CreateTable(table_def);
		}

		/// <summary>
		/// Creates a new table within this transaction with the given 
		/// sector size.
		/// </summary>
		/// <param name="table_def">Meta informations used to create the table.</param>
		/// <param name="data_sector_size">Size of data sectors of the table.</param>
		/// <param name="index_sector_size">Size of the index sectors of the table.</param>
		/// <remarks>
		/// This should only be used as very fine grain optimization for 
		/// creating tables. 
		/// If in the future the underlying table model is changed so that the given
		/// <paramref name="data_sector_size"/> value is unapplicable, then the value 
		/// will be ignored.
		/// </remarks>
		/// <exception cref="StatementException">
		/// If a table with the same name (specified by <paramref name="table_def"/>) 
		/// already exists.
		/// </exception>
		public void CreateTable(DataTableDef table_def, int data_sector_size, int index_sector_size) {
			CheckAllowCreate(table_def.TableName);
			Transaction.CreateTable(table_def, data_sector_size, index_sector_size);
		}

		/// <summary>
		/// Creates a new view.
		/// </summary>
		/// <param name="command"></param>
		/// <param name="view">View meta informations used to create the view.</param>
		/// <remarks>
		/// Note that this is a transactional operation. You need to commit for 
		/// the view to be visible to other transactions.
		/// </remarks>
		/// <exception cref="DatabaseException"/>
		public void CreateView(SqlCommand command, ViewDef view) {
			CheckAllowCreate(view.DataTableDef.TableName);

			try {
				view_manager.DefineView(view, command, User);
			} catch (DatabaseException e) {
				Debug.WriteException(e);
				throw new Exception("Database Exception: " + e.Message);
			}

		}

		/// <summary>
		/// Drops a view with the given name.
		/// </summary>
		/// <param name="view_name">Name of the view to drop.</param>
		/// <remarks>
		/// Note that this is a transactional operation. You need to commit 
		/// for the change to be visible to other transactions.
		/// </remarks>
		/// <returns>
		/// Returns <b>true</b> if the drop succeeded, otherwise <b>false</b> if 
		/// the view was not found.
		/// </returns>
		public bool DropView(TableName view_name) {
			try {
				return view_manager.DeleteView(view_name);
			} catch (DatabaseException e) {
				Debug.WriteException(e);
				throw new Exception("Database Exception: " + e.Message);
			}

		}

		/// <summary>
		/// Alters a table within the underlying transaction.
		/// </summary>
		/// <param name="table_def">Table metadata informations for aletring the table</param>
		/// <exception cref="StatementException">
		/// If the name of the table is reserved and the creation of the table 
		/// should be prevented.
		/// </exception>
		public void UpdateTable(DataTableDef table_def) {
			CheckAllowCreate(table_def.TableName);
			Transaction.AlterTable(table_def.TableName, table_def);
		}

		/// <summary>
		/// Alters a table within the underlying transaction.
		/// </summary>
		/// <param name="table_def">Table metadata informations for altering 
		/// the table.</param>
		/// <param name="data_sector_size"></param>
		/// <param name="index_sector_size"></param>
		/// <remarks>
		/// This should only be used as very fine grain optimization
		/// for creating tables. If in the future the underlying table model is
		/// changed so that the given <paramref name="data_sector_size"/> value 
		/// is unapplicable, then the value will be ignored.
		/// </remarks>
		public void UpdateTable(DataTableDef table_def, int data_sector_size, int index_sector_size) {
			CheckAllowCreate(table_def.TableName);
			Transaction.AlterTable(table_def.TableName, table_def, data_sector_size, index_sector_size);
		}

		/// <summary>
		/// If a table exists with the given table name (defined by <paramref name="table_def"/>)
		/// alters its the structure, otherwise creates a new table.
		/// </summary>
		/// <param name="table_def">Meta informations for altering or creating a table.</param>
		/// <param name="data_sector_size">Size of data sectors of the table.</param>
		/// <param name="index_sector_size">Size of the index sectors of the table.</param>
		/// <remarks>
		/// This should only be used as very fine grain optimization for creating or
		/// altering tables.
		/// If in the future the underlying table model is changed so that the given 
		/// <paramref name="data_sector_size"/> and <paramref name="index_sector_size"/> 
		/// values are unapplicable and will be ignored.
		/// </remarks>
		public void AlterCreateTable(DataTableDef table_def, int data_sector_size, int index_sector_size) {
			if (!TableExists(table_def.TableName)) {
				CreateTable(table_def, data_sector_size, index_sector_size);
			} else {
				UpdateTable(table_def, data_sector_size, index_sector_size);
			}
		}

		/// <summary>
		/// If a table exists with the given table name (defined by <paramref name="table_def"/>)
		/// alters its the structure, otherwise creates a new table.
		/// </summary>
		/// <param name="table_def">Meta informations for altering or creating a table.</param>
		/// <exception cref="StatementException"></exception>
		public void AlterCreateTable(DataTableDef table_def) {
			if (!TableExists(table_def.TableName)) {
				CreateTable(table_def);
			} else {
				UpdateTable(table_def);
			}
		}

		/// <summary>
		/// Notifies this transaction that a database object with the given name 
		/// has successfully been created.
		/// </summary>
		/// <param name="table_name"></param>
		internal void DatabaseObjectCreated(TableName table_name) {
			Transaction.OnDatabaseObjectCreated(table_name);
		}

		/// <summary>
		/// Notifies this transaction that a database object with the given name 
		/// has successfully been dropped.
		/// </summary>
		/// <param name="table_name"></param>
		internal void DatabaseObjectDropped(TableName table_name) {
			Transaction.OnDatabaseObjectDropped(table_name);
		}

		/// <summary>
		/// Checks all the rows in the table for immediate constraint violations
		/// and when the transaction is next committed check for all deferred
		/// constraint violations.
		/// </summary>
		/// <param name="table_name">Name of the table to check the constraints.</param>
		/// <remarks>
		/// This method is used when the constraints on a table changes and we 
		/// need to determine if any constraint violations occurred.
		/// <para>
		/// To the constraint checking system, this is like adding all the 
		/// rows to the given table.
		/// </para>
		/// </remarks>
		/// <exception cref="StatementException">
		/// If none table with the given <paramref name="table_name"/> was found.
		/// </exception>
		public void CheckAllConstraints(TableName table_name) {
			// Assert
			CheckExclusive();
			Transaction.CheckAllConstraints(table_name);
		}

		/// <summary>
		/// Drops a table within the transaction.
		/// </summary>
		/// <param name="table_name">Name of the table to drop.</param>
		/// <exception cref="TransactionException">
		/// If none tables was found for the given <paramref name="table_name"/>.
		/// </exception>
		public void DropTable(String table_name) {
			DropTable(new TableName(current_schema, table_name));
		}

		/// <summary>
		/// Drops a table within the transaction.
		/// </summary>
		/// <param name="table_name">Name of the table to drop.</param>
		/// <exception cref="TransactionException">
		/// If none tables was found for the given <paramref name="table_name"/>.
		/// </exception>
		public void DropTable(TableName table_name) {
			Transaction.DropTable(table_name);
		}

		/// <summary>
		/// Compacts a table with the given name.
		/// </summary>
		/// <param name="table_name">The name of the table to compact.</param>
		/// <exception cref="StatementException">
		/// If none table was found for the given <paramref name="table_name"/> 
		/// in the <see cref="CurrentSchema"/>.
		/// </exception>
		public void CompactTable(String table_name) {
			CompactTable(new TableName(current_schema, table_name));
		}

		/// <summary>
		/// Compacts a table with the given name.
		/// </summary>
		/// <param name="table_name">The name of the table to compact.</param>
		/// <exception cref="StatementException">
		/// If none table was found for the given <paramref name="table_name"/>.
		/// </exception>
		public void CompactTable(TableName table_name) {
			Transaction.CompactTable(table_name);
		}

		///<summary>
		/// Adds the given table name to the list of tables that are selected from
		/// within the transaction in this connection.
		///</summary>
		///<param name="table_name"></param>
		public void AddSelectedFromTable(String table_name) {
			AddSelectedFromTable(new TableName(current_schema, table_name));
		}

		///<summary>
		/// Adds the given table name to the list of tables that are selected from
		/// within the transaction in this connection.
		///</summary>
		///<param name="name"></param>
		public void AddSelectedFromTable(TableName name) {
			Transaction.AddSelectedFromTable(name);
		}

		/// <summary>
		/// Requests the sequence generator for the next value.
		/// </summary>
		/// <param name="name"></param>
		/// <remarks>
		/// <b>Note:</b> This does <b>note</b> check that the user owning 
		/// the session has the correct privileges to perform the operation.
		/// </remarks>
		/// <returns></returns>
		public long NextSequenceValue(String name) {
			// Resolve and ambiguity test
			TableName seq_name = ResolveToTableName(name);
			return Transaction.NextSequenceValue(seq_name);
		}

		/// <summary>
		/// Returns the current sequence value for the given sequence generator.
		/// </summary>
		/// <param name="name"></param>
		/// <remarks>
		/// The value returned is the same value returned by <see cref="NextSequenceValue"/>.
		/// <para>
		/// <b>Note:</b> This does <b>note</b> check that the user owning 
		/// the session has the correct privileges to perform the operation.
		/// </para>
		/// </remarks>
		/// <returns></returns>
		/// <exception cref="StatementException">
		/// If no value was returned by <see cref="NextSequenceValue"/>.
		/// </exception>
		public long LastSequenceValue(String name) {
			// Resolve and ambiguity test
			TableName seq_name = ResolveToTableName(name);
			return Transaction.LastSequenceValue(seq_name);
		}

		/// <summary>
		/// Sets the sequence value for the given sequence generator.
		/// </summary>
		/// <param name="name"></param>
		/// <param name="value"></param>
		/// <remarks>
		/// <b>Note:</b> This does <b>note</b> check that the user owning 
		/// the session has the correct privileges to perform the operation.
		/// </remarks>
		/// <exception cref="StatementException">
		/// If the generator does not exist or it is not possible to set the 
		/// value for the generator.
		/// </exception>
		public void SetSequenceValue(String name, long value) {
			// Resolve and ambiguity test
			TableName seq_name = ResolveToTableName(name);
			Transaction.SetSequenceValue(seq_name, value);
		}

		/// <summary>
		/// Returns the next unique identifier for the given table from 
		/// the schema.
		/// </summary>
		/// <param name="name"></param>
		/// <returns></returns>
		public long NextUniqueID(TableName name) {
			return Transaction.NextUniqueID(name);
		}

		/// <summary>
		/// Returns the next unique identifier for the given table from 
		/// the current schema.
		/// </summary>
		/// <param name="table_name"></param>
		/// <returns></returns>
		public long NextUniqueID(String table_name) {
			TableName tname = TableName.Resolve(current_schema, table_name);
			return NextUniqueID(tname);
		}

		/// <summary>
		/// If the given table name is a reserved name, then we must substitute it
		/// with its correct form.
		/// </summary>
		/// <param name="table_name"></param>
		/// <returns></returns>
		static TableName SubstituteReservedTableName(TableName table_name) {
			// We do not allow tables to be created with a reserved name
			String name = table_name.Name;
			if (String.Compare(name, "OLD", true) == 0)
				return Database.OldTriggerTable;
			if (String.Compare(name, "NEW", true) == 0)
				return Database.NewTriggerTable;
			return table_name;
		}


		/// <summary>
		/// Generates an exception if the name of the table is reserved and the
		/// creation of the table should be prevented.
		/// </summary>
		/// <param name="table_name"></param>
		/// <remarks>
		/// For example, the table names <c>OLD</c> and <c>NEW</c> are reserved.
		/// </remarks>
		internal static void CheckAllowCreate(TableName table_name) {
			// We do not allow tables to be created with a reserved name
			String name = table_name.Name;
			if (String.Compare(name, "OLD", true) == 0 ||
				String.Compare(name, "NEW", true) == 0) {
				throw new StatementException("Table name '" + table_name +
											 "' is reserved.");
			}
		}

		/// <summary>
		/// Creates a new sequence generator with the given name and initializes 
		/// it with the given details.
		/// </summary>
		/// <param name="name"></param>
		/// <param name="start_value"></param>
		/// <param name="increment_by"></param>
		/// <param name="min_value"></param>
		/// <param name="max_value"></param>
		/// <param name="cache"></param>
		/// <param name="cycle"></param>
		/// <remarks>
		/// This does <b>not</b> check if the given name clashes with an 
		/// existing database object.
		/// </remarks>
		public void CreateSequenceGenerator(TableName name, long start_value, long increment_by,
			long min_value, long max_value, long cache, bool cycle) {

			// Check the name of the database object isn't reserved (OLD/NEW)
			CheckAllowCreate(name);

			Transaction.CreateSequenceGenerator(name, start_value, increment_by, min_value, max_value, cache, cycle);
		}

		/// <summary>
		/// Drops an existing sequence generator with the given name.
		/// </summary>
		/// <param name="name"></param>
		public void DropSequenceGenerator(TableName name) {
			Transaction.DropSequenceGenerator(name);
		}

		///<summary>
		/// Adds a type of trigger for the given trigger source (usually the
		/// name of the table).
		///</summary>
		///<param name="trigger_name"></param>
		///<param name="trigger_source"></param>
		///<param name="type"></param>
		/// <remarks>
		/// Adds a type of trigger to the given Table.  When the event is fired, the
		/// <see cref="CallBack.TriggerNotify"/> method is notified of the event.
		/// </remarks>
		public void CreateTrigger(String trigger_name, String trigger_source, TriggerEventType type) {
			database.TriggerManager.AddTriggerListener(this, trigger_name, type, trigger_source, this);
		}

		/// <summary>
		/// Removes a type of trigger for the given trigger source (usually the
		/// name of the table).
		/// </summary>
		/// <param name="trigger_name"></param>
		public void DeleteTrigger(String trigger_name) {
			database.TriggerManager.RemoveTriggerListener(this, trigger_name);
		}

		/// <summary>
		/// Informs the underlying transaction that a high level transaction event
		/// has occurred and should be dispatched to any listeners occordingly.
		/// </summary>
		/// <param name="evt"></param>
		public void OnTriggerEvent(TriggerEvent evt) {
			trigger_event_list.Add(evt);
		}

		/// <summary>
		/// Allocates a new large object in the blob store in the underlying conglomerate
		/// for the given type and size.
		/// </summary>
		/// <param name="type"></param>
		/// <param name="object_size"></param>
		/// <remarks>
		/// The blob data must be written through the <see cref="IRef"/>
		/// after the large object is created. Once the data has been written 
		/// <see cref="IRef.Complete"/> is called.
		/// <para>
		/// Once a large object is created and written to, it may be allocated 
		/// in one or more tables in the conglomerate.
		/// </para>
		/// </remarks>
		/// <returns></returns>
		public IRef CreateNewLargeObject(ReferenceType type, long object_size) {
			// Enable compression for string types (but not binary types).
			if (type == ReferenceType.AsciiText || 
				type == ReferenceType.UnicodeText) {
				type |= ReferenceType.Compressed;
			}
			return conglomerate.CreateNewLargeObject(type, object_size);
		}

		/// <summary>
		/// Tells the underlying conglomerate to flush the blob store.
		/// </summary>
		/// <remarks>
		/// This should be called after one or more blobs have been created and 
		/// the data for the blob(s) are set. It is an important step to perform 
		/// <b>after</b> blobs have been written.
		/// <para>
		/// If this is not called and the database closes (or crashes) before a flush
		/// occurs then the blob may not be recoverable.
		/// </para>
		/// </remarks>
		[Obsolete("Deprecated: no longer necessary", false)]
		public void FlushBlobStore() {
			conglomerate.FlushBlobStore();
		}

		/// <summary>
		/// Returns a <see cref="ITableQueryDef"/> that describes the 
		/// characteristics of a table including the name, the columns and the 
		/// query plan to produce the table.
		/// </summary>
		/// <param name="table_name"></param>
		/// <param name="aliased_as">Used to overwrite the default name of 
		/// the table object.</param>
		/// <remarks>
		/// This object can be used to resolve information about a 
		/// particular table, and to evaluate the query plan to produce 
		/// the table itself.
		/// <para>
		/// This produces <see cref="ITableQueryDef"/> objects for all table 
		/// objects in the database including data tables and views.
		/// </para>
		/// </remarks>
		/// <returns></returns>
		public ITableQueryDef GetTableQueryDef(TableName table_name, TableName aliased_as) {
			// Produce the data table def for this database object.
			DataTableDef dtf = GetDataTableDef(table_name);
			// If the table is aliased, set a new DataTableDef with the given name
			if (aliased_as != null) {
				dtf = new DataTableDef(dtf);
				dtf.TableName = aliased_as;
				dtf.SetImmutable();
			}
			DataTableDef data_table_def = dtf;
			//    final String aliased_name =
			//                     aliased_as == null ? null : aliased_as.getName();

			return new TableQueryDefImpl(this, data_table_def, table_name, aliased_as);

		}

		private class TableQueryDefImpl : ITableQueryDef {
			private readonly DatabaseConnection conn;
			private readonly DataTableDef data_table_def;
			private readonly TableName table_name;
			private readonly TableName aliased_as;

			public TableQueryDefImpl(DatabaseConnection conn, DataTableDef dataTableDef, TableName tableName, TableName aliasedAs) {
				this.conn = conn;
				data_table_def = dataTableDef;
				aliased_as = aliasedAs;
				table_name = tableName;
			}

			public DataTableDef DataTableDef {
				get { return data_table_def; }
			}

			public IQueryPlanNode QueryPlanNode {
				get { return conn.CreateObjectFetchQueryPlan(table_name, aliased_as); }
			}
		}

		/// <summary>
		/// Creates a <see cref="IQueryPlanNode"/> to fetch the given table 
		/// object from the session.
		/// </summary>
		/// <param name="table_name"></param>
		/// <param name="aliased_name"></param>
		/// <returns></returns>
		public IQueryPlanNode CreateObjectFetchQueryPlan(TableName table_name, TableName aliased_name) {
			String table_type = GetTableType(table_name);
			if (table_type.Equals("VIEW")) {
				return new QueryPlan.FetchViewNode(table_name, aliased_name);
			} else {
				return new QueryPlan.FetchTableNode(table_name, aliased_name);
			}
		}

		// ---------- Schema management and constraint methods ----------
		// Methods that handle getting/setting schema information such as;
		// * Creating/dropping/querying schema
		// * Creating/dropping/querying constraint information including;
		//     check constraints, unique constraints, primary key constraints,
		//     foreign key constraints, etc.

		/// <summary>
		/// Changes the default schema to the given schema.
		/// </summary>
		/// <param name="schema_name"></param>
		public void SetDefaultSchema(String schema_name) {
			bool ignore_case = IsInCaseInsensitiveMode;
			SchemaDef schema = ResolveSchemaCase(schema_name, ignore_case);
			if (schema == null) {
				throw new ApplicationException("Schema '" + schema_name + "' does not exist.");
			} else {
				// Set the default schema for this connection
				CurrentSchema = schema.Name;
			}
		}

		// NOTE: These methods are copied because they simply call through to the
		//   Transaction implementation of the method with the same signature.

		private void CheckExclusive() {
			if (!LockingMechanism.IsInExclusiveMode) {
				throw new ApplicationException("Assertion failed: Expected to be in exclusive mode.");
			}
		}

		/// <inheritdoc cref="Data.Transaction.CreateSchema"/>
		public void CreateSchema(String name, String type) {
			// Assert
			CheckExclusive();
			Transaction.CreateSchema(name, type);
		}

		/// <inheritdoc cref="Data.Transaction.DropSchema"/>
		public void DropSchema(String name) {
			// Assert
			CheckExclusive();
			Transaction.DropSchema(name);
		}

		/// <inheritdoc cref="Data.Transaction.SchemaExists"/>
		public bool SchemaExists(String name) {
			return Transaction.SchemaExists(name);
		}

		/// <inheritdoc cref="Data.Transaction.ResolveSchemaCase"/>
		public SchemaDef ResolveSchemaCase(String name, bool ignore_case) {
			return Transaction.ResolveSchemaCase(name, ignore_case);
		}

		/**
		 * Convenience - returns the SchemaDef object given the name of the schema.
		 * If identifiers are case insensitive, we resolve the case of the schema
		 * name also.
		 */
		public SchemaDef resolveSchemaName(String name) {
			bool ignore_case = IsInCaseInsensitiveMode;
			return ResolveSchemaCase(name, ignore_case);
		}

		/// <inheritdoc cref="Data.Transaction.GetSchemaList"/>
		public SchemaDef[] GetSchemaList() {
			return Transaction.GetSchemaList();
		}

		/// <inheritdoc cref="Data.Transaction.SetPersistentVariable"/>
		public void SetVariable(String variable, String value) {
			// Assert
			CheckExclusive();
			Transaction.SetPersistentVariable(variable, value);
		}

		/// <inheritdoc cref="Data.Transaction.GetPersistantVariable"/>
		public String GetVariable(String variable) {
			return Transaction.GetPersistantVariable(variable);
		}

		/// <inheritdoc cref="Data.Transaction.AddUniqueConstraint"/>
		public void AddUniqueConstraint(TableName table_name, String[] cols,
										short deferred, String constraint_name) {
			// Assert
			CheckExclusive();
			Transaction.AddUniqueConstraint(table_name, cols,deferred, constraint_name);
		}

		/// <inheritdoc cref="Data.Transaction.AddForeignKeyConstraint"/>
		public void AddForeignKeyConstraint(TableName table, String[] cols,
			TableName ref_table, String[] ref_cols,
			String delete_rule, String update_rule,
			short deferred, String constraint_name) {
			// Assert
			CheckExclusive();
			Transaction.AddForeignKeyConstraint(table, cols, ref_table, ref_cols,
			                                    delete_rule, update_rule,
			                                    deferred, constraint_name);
		}

		/// <inheritdoc cref="Data.Transaction.AddPrimaryKeyConstraint"/>
		public void AddPrimaryKeyConstraint(TableName table_name, String[] cols,
											short deferred, String constraint_name) {
			// Assert
			CheckExclusive();
			Transaction.AddPrimaryKeyConstraint(table_name, cols, deferred, constraint_name);
		}

		/// <inheritdoc cref="Data.Transaction.AddCheckConstraint"/>
		public void AddCheckConstraint(TableName table_name, Expression expression, short deferred, String constraint_name) {
			// Assert
			CheckExclusive();
			Transaction.AddCheckConstraint(table_name, expression, deferred, constraint_name);
		}

		/// <inheritdoc cref="Data.Transaction.DropAllConstraintsForTable"/>
		public void DropAllConstraintsForTable(TableName table_name) {
			// Assert
			CheckExclusive();
			Transaction.DropAllConstraintsForTable(table_name);
		}

		/// <inheritdoc cref="Data.Transaction.DropNamedConstraint"/>
		public int DropNamedConstraint(TableName table_name, String constraint_name) {
			// Assert
			CheckExclusive();
			return Transaction.DropNamedConstraint(table_name, constraint_name);
		}

		/// <inheritdoc cref="Data.Transaction.DropPrimaryKeyConstraintForTable"/>
		public bool DropPrimaryKeyConstraintForTable(TableName table_name, String constraint_name) {
			// Assert
			CheckExclusive();
			return Transaction.DropPrimaryKeyConstraintForTable(table_name,
																	 constraint_name);
		}

		/// <inheritdoc cref="Data.Transaction.queryTablesRelationallyLinkedTo"/>
		public TableName[] QueryTablesRelationallyLinkedTo(TableName table) {
			return Transaction.queryTablesRelationallyLinkedTo(Transaction, table);
		}

		/// <inheritdoc cref="Data.Transaction.QueryTableUniqueGroups"/>
		public Transaction.ColumnGroup[] QueryTableUniqueGroups(TableName table_name) {
			return Transaction.QueryTableUniqueGroups(Transaction, table_name);
		}

		/// <inheritdoc cref="Data.Transaction.QueryTablePrimaryKeyGroup"/>
		public Transaction.ColumnGroup QueryTablePrimaryKeyGroup(TableName table_name) {
			return Transaction.QueryTablePrimaryKeyGroup(Transaction, table_name);
		}

		/// <inheritdoc cref="Data.Transaction.QueryTableCheckExpressions"/>
		public Transaction.CheckExpression[] QueryTableCheckExpressions(TableName table_name) {
			return Transaction.QueryTableCheckExpressions(Transaction, table_name);
		}

		/// <inheritdoc cref="Data.Transaction.QueryTableForeignKeyReferences"/>
		public Transaction.ColumnGroupReference[] QueryTableForeignKeyReferences(TableName table_name) {
			return Transaction.QueryTableForeignKeyReferences(Transaction, table_name);
		}

		/// <inheritdoc cref="Data.Transaction.QueryTableImportedForeignKeyReferences"/>
		public Transaction.ColumnGroupReference[] QueryTableImportedForeignKeyReferences(TableName table_name) {
			return Transaction.QueryTableImportedForeignKeyReferences(Transaction, table_name);
		}


		// ---------- Triggered OLD/NEW table handling ----------
		// These methods are used by the ConnectionTriggerManager object to
		// temporarily create OLD and NEW tables in this connection from inside a
		// triggered action.  In some cases (before the operation) the OLD table
		// is mutable.

		/// <summary>
		/// Returns the current state of the old/new tables.
		/// </summary>
		/// <returns></returns>
		internal OldNewTableState GetOldNewTableState() {
			return current_old_new_state;
		}

		/**
		 * Sets the current state of the old/new tables.  When nesting OLD/NEW
		 * tables for nested stored procedures, the current state should be first
		 * recorded and reverted back when the nested procedure finishes.
		 */
		internal void SetOldNewTableState(OldNewTableState state) {
			current_old_new_state = state;
		}

		// ---------- Trigger methods ----------

		/// <summary>
		/// Notifies the session that an insert/delete or update operation has occurred 
		/// on some table of this <see cref="DatabaseConnection"/>.
		/// </summary>
		/// <param name="evt"></param>
		/// <remarks>
		/// This should notify the trigger connection manager of this event so that it 
		/// may perform any action that may have been set up to occur on this event.
		/// </remarks>
		internal void FireTableEvent(TableModificationEvent evt) {
			connection_trigger_manager.PerformTriggerAction(evt);
		}

		// ---------- Implemented from ITriggerListener ----------

		///<summary>
		/// Notifies when a trigger has fired for this user.
		///</summary>
		///<param name="database"></param>
		///<param name="trigger_name"></param>
		///<param name="evt"></param>
		/// <remarks>
		/// If there are no open transactions on this connection then we do a straight call 
		/// back trigger notify.  If there is a transaction open then trigger events are added
		/// to the 'trigger_event_buffer' which fires when the connection transaction
		/// is committed or rolled back.
		/// </remarks>
		///<exception cref="ApplicationException"></exception>
		public void FireTrigger(DatabaseConnection database, String trigger_name, TriggerEvent evt) {
			if (this != database) {
				throw new ApplicationException("User object mismatch.");
			}

			try {
				// Did we pass in a call back interface?
				if (call_back != null) {
					lock (trigger_event_buffer) {
						// If there is no active transaction then fire trigger immediately.
						if (transaction == null) {
							call_back.TriggerNotify(trigger_name, evt.Type,
													evt.Source, evt.Count);
						}
							// Otherwise add to buffer
						else {
							trigger_event_buffer.Add(trigger_name);
							trigger_event_buffer.Add(evt);
						}
					}
				}
			} catch (Exception e) {
				Debug.Write(DebugLevel.Error, this, "TRIGGER Exception: " + e.Message);
			}
		}

		/// <summary>
		/// Fires any triggers that are pending in the trigger buffer.
		/// </summary>
		private void FirePendingTriggerEvents () {
			int sz;
			lock (trigger_event_buffer) {
				sz = trigger_event_buffer.Count;
			}
			if (sz > 0) {
				// Post an event that fires the triggers for each listener.
				// Post the event to go off approx 3ms from now.
				database.PostEvent (3, database.CreateEvent (new FirePendingTriggerEventsImpl(this)));
			}
			
		}
		
		class FirePendingTriggerEventsImpl : IDatabaseEvent {
			public FirePendingTriggerEventsImpl (DatabaseConnection conn) {
				this.conn = conn;
			}
			
			private DatabaseConnection conn;
			
			public void Execute () {
				lock (conn.trigger_event_buffer) {
					// Fire all pending trigger events in buffer
					for (int i = 0; i < conn.trigger_event_buffer.Count; i += 2) {
						String trigger_name = (String)conn.trigger_event_buffer[i];
						TriggerEvent evt = (TriggerEvent)conn.trigger_event_buffer[i + 1];
						conn.call_back.TriggerNotify (trigger_name, evt.Type, evt.Source, evt.Count);
					}
					// Clear the buffer
					conn.trigger_event_buffer.Clear ();
				}
			}
		}


		/// <summary>
		/// Private method that disposes the current transaction.
		/// </summary>
		private void DisposeTransaction() {
			// Set the transaction to null
			transaction = null;
			// Fire any pending trigger events in the trigger buffer.
			FirePendingTriggerEvents();
			// Clear the trigger events in this object
			trigger_event_list.Clear();

			// Notify any table backed caches that this transaction has finished.
			int sz = table_backed_cache_list.Count;
			for (int i = 0; i < sz; ++i) {
				TableBackedCache cache =
									 (TableBackedCache)table_backed_cache_list[i];
				cache.OnTransactionFinished();
			}
		}

		/// <summary>
		/// Tries to commit the current transaction.
		/// </summary>
		/// <remarks>
		/// <b>Note:</b> It's guarenteed that the transaction will be closed even if a
		/// transaction exception occurs.
		/// <para>
		/// Lock is implied on this method, because the locking mechanism
		/// should be exclusive when this is called.
		/// </para>
		/// </remarks>
		/// <exception cref="TransactionException">
		/// If the transaction can not be committed because there were concurrent 
		/// changes that interfered with each other (the transaction is rolled-back) 
		/// or if the session is not allowed to close the transaction.
		/// </exception>
		public void Commit() {
			// Are we currently allowed to commit/rollback?
			if (close_transaction_disabled) {
				throw new Exception("Commit is not allowed.");
			}

			if (user != null) {
				user.RefreshLastCommandTime();
			}

			// NOTE, always connection exclusive op.
			LockingMechanism.Reset();
			tables_cache.Clear();

			if (transaction != null) {
				try {
					// Close and commit the transaction
					transaction.Commit();

					// Fire all SQL action level triggers that were generated on actions.
					database.TriggerManager.FlushTriggerEvents(trigger_event_list);
				} finally {
					// Dispose the current transaction
					DisposeTransaction();
				}
			}
		}

		/// <summary>
		/// Rolls back the current transaction operating within 
		/// the session.
		/// </summary>
		/// <remarks>
		/// <b>Note:</b> It's guarenteed that the transaction will be closed even if an
		/// exception occurs.
		/// <para>
		/// Locking is implied on this method, because the locking mechanism
		/// should be exclusive when this is called.
		/// </para>
		/// </remarks>
		/// <exception cref="TransactionException">
		/// If the session is not allowed to close the underlying transaction.
		/// </exception>
		public void Rollback() {
			// Are we currently allowed to commit/rollback?
			if (close_transaction_disabled) {
				throw new Exception("Rollback is not allowed.");
			}

			if (user != null) {
				user.RefreshLastCommandTime();
			}

			// NOTE, always connection exclusive op.
			tables_cache.Clear();

			if (transaction != null) {
				LockingMechanism.Reset();
				try {
					transaction.Rollback();
				} finally {
					// Dispose the current transaction
					DisposeTransaction();
					// Dispose the jdbc connection
					if (db_connection != null) {
						try {
							InternalDbHelper.DisposeDbConnection(db_connection);
						} catch (Exception e) {
							Debug.Write(DebugLevel.Error, this,
										  "Error disposing internal JDBC connection.");
							Debug.WriteException(DebugLevel.Error, e);
							// We don't wrap this exception
						}
						db_connection = null;
					}
				}
			}
		}

		/// <summary>
		/// Closes this database connection.
		/// </summary>
		public void Close() {
			try {
				Rollback();
			} catch (Exception e) {
				Console.Error.WriteLine(e.Message);
				Console.Error.WriteLine(e.StackTrace);
			} finally {
				if (table_backed_cache_list != null) {
					try {
						int sz = table_backed_cache_list.Count;
						for (int i = 0; i < sz; ++i) {
							TableBackedCache cache =
										   (TableBackedCache)table_backed_cache_list[i];
							cache.DetatchFrom(conglomerate);
						}
						table_backed_cache_list = null;
					} catch (Exception e) {
						Console.Error.WriteLine(e.Message);
						Console.Error.WriteLine(e.StackTrace);
					}
				}
				// Remove any trigger listeners set for this connection,
				database.TriggerManager.ClearAllDatabaseConnectionTriggers(this);
			}
		}


		// ---------- Inner classes ----------

		/// <summary>
		/// An implementation of <see cref="IProcedureConnection"/> generated from 
		/// this object.
		/// </summary>
		private class DCProcedureConnection : IProcedureConnection {
			private readonly DatabaseConnection conn;
			/// <summary>
			/// The User of this connection before this procedure was started.
			/// </summary>
			internal User previous_user;

			/// <summary>
			/// The 'close_transaction_disabled' flag when this connection was created.
			/// </summary>
			internal bool transaction_disabled_flag;

			/// <summary>
			/// The ADO.NET connection created by this object.
			/// </summary>
			private IDbConnection db_connection;

			public DCProcedureConnection(DatabaseConnection conn) {
				this.conn = conn;
			}


			public IDbConnection GetDbConnection() {
				if (db_connection == null) {
					db_connection = InternalDbHelper.CreateDbConnection(conn.User, conn);
				}
				return db_connection;
			}

			public Database Database {
				get { return conn.Database; }
			}


			internal void dispose() {
				previous_user = null;
				if (db_connection != null) {
					try {
						InternalDbHelper.DisposeDbConnection(db_connection);
					} catch (Exception e) {
						Debug.Write(DebugLevel.Error, this, "Error disposing internal connection.");
						Debug.WriteException(DebugLevel.Error, e);
						// We don't wrap this exception
					}
				}
			}

		}

		/// <summary>
		/// An internal table info object that handles OLD and NEW tables for
		/// triggered actions.
		/// </summary>
		private class OldAndNewInternalTableInfo : IInternalTableInfo {
			private readonly DatabaseConnection conn;

			public OldAndNewInternalTableInfo(DatabaseConnection conn) {
				this.conn = conn;
			}

			private bool HasOLDTable {
				get { return conn.current_old_new_state.OLD_row_index != -1; }
			}

			private bool HasNEWTable {
				get { return conn.current_old_new_state.NEW_row_data != null; }
			}

			public int TableCount {
				get {
					int count = 0;
					if (HasOLDTable) {
						++count;
					}
					if (HasNEWTable) {
						++count;
					}
					return count;
				}
			}

			public int FindTableName(TableName name) {
				if (HasOLDTable && name.Equals(Database.OldTriggerTable)) {
					return 0;
				}
				if (HasNEWTable && name.Equals(Database.NewTriggerTable)) {
					if (HasOLDTable) {
						return 1;
					} else {
						return 0;
					}
				}
				return -1;
			}

			public TableName GetTableName(int i) {
				if (HasOLDTable) {
					if (i == 0) {
						return Database.OldTriggerTable;
					}
				}
				return Database.NewTriggerTable;
			}

			public bool ContainsTableName(TableName name) {
				return FindTableName(name) != -1;
			}

			public String GetTableType(int i) {
				return "SYSTEM TABLE";
			}

			public DataTableDef GetDataTableDef(int i) {
				DataTableDef table_def = conn.GetDataTableDef(
												  conn.current_old_new_state.trigger_source);
				DataTableDef new_table_def = new DataTableDef(table_def);
				new_table_def.TableName = GetTableName(i);
				return new_table_def;
			}

			public IMutableTableDataSource CreateInternalTable(int index) {
				DataTableDef t_def = GetDataTableDef(index);

				TriggeredOldNewDataSource table =
									  new TriggeredOldNewDataSource(conn.System, t_def);

				if (HasOLDTable) {
					if (index == 0) {

						// Copy data from the table to the new table
						DataTable dtable = conn.GetTable(conn.current_old_new_state.trigger_source);
						RowData old_row_data = new RowData(table);
						int row_index = conn.current_old_new_state.OLD_row_index;
						for (int i = 0; i < t_def.ColumnCount; ++i) {
							old_row_data.SetColumnDataFromTObject(i,
														dtable.GetCellContents(i, row_index));
						}
						// All OLD tables are immutable
						table.SetImmutable(true);
						table.SetRowData(old_row_data);

						return table;
					}
				}

				table.SetImmutable(!conn.current_old_new_state.mutable_NEW);
				table.SetRowData(conn.current_old_new_state.NEW_row_data);

				return table;
			}

		}

		/// <summary>
		/// A IMutableTableDataSource implementation that is used for trigger actions
		/// to represent the data in the OLD and NEW tables.
		/// </summary>
		private sealed class TriggeredOldNewDataSource : GTDataSource {
			private readonly DataTableDef table_def;
			private RowData content;
			private bool immutable;

			public TriggeredOldNewDataSource(TransactionSystem system, DataTableDef table_def)
				: base(system) {
				this.table_def = table_def;
			}

			internal void SetImmutable(bool im) {
				this.immutable = im;
			}

			internal void SetRowData(RowData row_data) {
				this.content = row_data;
			}

			public override DataTableDef DataTableDef {
				get { return table_def; }
			}

			public override int RowCount {
				get { return 1; }
			}

			public override TObject GetCellContents(int column, int row) {
				if (row < 0 || row > 0) {
					throw new Exception("Row index out of bounds.");
				}
				return content.GetCellData(column);
			}

			public override int AddRow(RowData row_data) {
				throw new Exception("Inserting into table '" +
							  DataTableDef.TableName + "' is not permitted.");
			}

			public override void RemoveRow(int row_index) {
				throw new Exception("Deleting from table '" +
							  DataTableDef.TableName + "' is not permitted.");
			}

			public override int UpdateRow(int row_index, RowData row_data) {
				if (immutable) {
					throw new Exception("Updating table '" +
								DataTableDef.TableName + "' is not permitted.");
				}
				if (row_index < 0 || row_index > 0) {
					throw new Exception("Row index out of bounds.");
				}

				int sz = DataTableDef.ColumnCount;
				for (int i = 0; i < sz; ++i) {
					content.SetColumnDataFromTObject(i, row_data.GetCellData(i));
				}

				return 0;
			}

			public override MasterTableJournal Journal {
				get {
					// Shouldn't be used...
					throw new Exception("Invalid method used.");
				}
			}

			public override void FlushIndexChanges() {
				// Shouldn't be used...
				throw new Exception("Invalid method used.");
			}

			public override void ConstraintIntegrityCheck() {
				// Should always pass (not integrity check needed for OLD/NEW table.
			}

		}

		/// <summary>
		/// A list of DataTableDef system table definitions for tables internal to
		/// the database connection.
		/// </summary>
		private readonly static DataTableDef[] INTERNAL_DEF_LIST;

		static DatabaseConnection() {
			INTERNAL_DEF_LIST = new DataTableDef[5];
			INTERNAL_DEF_LIST[0] = GTStatisticsDataSource.DEF_DATA_TABLE_DEF;
			INTERNAL_DEF_LIST[1] = GTConnectionInfoDataSource.DEF_DATA_TABLE_DEF;
			INTERNAL_DEF_LIST[2] = GTCurrentConnectionsDataSource.DEF_DATA_TABLE_DEF;
			INTERNAL_DEF_LIST[3] = GTSQLTypeInfoDataSource.DEF_DATA_TABLE_DEF;
			INTERNAL_DEF_LIST[4] = GTPrivMapDataSource.DEF_DATA_TABLE_DEF;
		}

		/// <summary>
		/// An internal table info object that handles tables internal to a
		/// DatabaseConnection object.
		/// </summary>
		private class ConnectionInternalTableInfo : InternalTableInfo {
			private readonly DatabaseConnection conn;

			public ConnectionInternalTableInfo(DatabaseConnection conn)
				: base("SYSTEM TABLE", INTERNAL_DEF_LIST) {
				this.conn = conn;
			}

			// ---------- Implemented ----------

			public override IMutableTableDataSource CreateInternalTable(int index) {
				if (index == 0)
					return new GTStatisticsDataSource(conn).Init();
				if (index == 1)
					return new GTConnectionInfoDataSource(conn).Init();
				if (index == 2)
					return new GTCurrentConnectionsDataSource(conn).Init();
				if (index == 3)
					return new GTSQLTypeInfoDataSource(conn).Init();
				if (index == 4)
					return new GTPrivMapDataSource(conn);
				throw new Exception();
			}

		}

		/// <summary>
		/// Call back interface for events that occur within the connection instance.
		/// </summary>
		public interface CallBack {
			/// <summary>
			/// Notifies the callee that a trigger event was fired that this user
			/// is listening for.
			/// </summary>
			/// <param name="trigger_name"></param>
			/// <param name="trigger_event"></param>
			/// <param name="trigger_source"></param>
			/// <param name="fire_count"></param>
			void TriggerNotify(String trigger_name, TriggerEventType trigger_event,
							   String trigger_source, int fire_count);
		}


		/// <summary>
		/// An internal table info object that handles OLD and NEW tables for
		/// triggered actions.
		/// </summary>
		internal sealed class OldNewTableState {

			/// <summary>
			///  The name of the table that is the trigger source.
			/// </summary>
			internal TableName trigger_source;

			/// <summary>
			/// The row index of the OLD data that is being updated or deleted in the
			/// trigger source table.
			/// </summary>
			internal int OLD_row_index = -1;

			/// <summary>
			/// The RowData of the new data that is being inserted/updated in the trigger
			/// source table.
			/// </summary>
			internal RowData NEW_row_data;

			/// <summary>
			/// If true then the 'new_data' information is mutable which would be true for
			/// a BEFORE trigger.
			/// </summary>
			/// <remarks>
			/// For example, we would want to change the data in the row that caused the 
			/// trigger to fire.
			/// </remarks>
			internal bool mutable_NEW;

			/// <summary>
			/// The DataTable object that represents the OLD table, if set.
			/// </summary>
			internal DataTable OLD_data_table;

			/// <summary>
			/// The DataTable object that represents the NEW table, if set.
			/// </summary>
			internal DataTable NEW_data_table;

			internal OldNewTableState(TableName table_source, int old_d, RowData new_d, bool is_mutable) {
				trigger_source = table_source;
				OLD_row_index = old_d;
				NEW_row_data = new_d;
				mutable_NEW = is_mutable;
			}

			internal OldNewTableState() {
			}

		}

		#region Implementation of IDisposable
		/// <inheritdoc/>
		public void Dispose() {
			Close();
		}

		#endregion
	}
}