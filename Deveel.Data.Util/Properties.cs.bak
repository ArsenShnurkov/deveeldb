//
//  This file is part of DeveelDB.
//
//    DeveelDB is free software: you can redistribute it and/or modify
//    it under the terms of the GNU Lesser General Public License as 
//    published by the Free Software Foundation, either version 3 of the 
//    License, or (at your option) any later version.
//
//    DeveelDB is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU Lesser General Public License for more details.
//
//    You should have received a copy of the GNU Lesser General Public 
//    License along with DeveelDB.  If not, see <http://www.gnu.org/licenses/>.
//
//  Authors:
//    Antonello Provenzano <antonello@deveel.com>
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Deveel.Data.Util {
	public class Properties : Dictionary<Object, Object> {

		/**
		 * A property list that contains default values for any keys not
		 * found in this property list.
		 *
		 * @serial
		 */
		protected Properties defaults;

		/**
		 * Creates an empty property list with no default values.
		 */
		public Properties()
			: this(null) {
		}

		/**
		 * Creates an empty property list with the specified defaults.
		 *
		 * @param   defaults   the defaults.
		 */
		public Properties(Properties defaults) {
			this.defaults = defaults;
		}

		/**
		 * Calls the <tt>Hashtable</tt> method <code>WriteByte</code>. Provided for
		 * parallelism with the <tt>getProperty</tt> method. Enforces use of
		 * strings for property keys and values. The value returned is the
		 * result of the <tt>Hashtable</tt> call to <code>WriteByte</code>.
		 *
		 * @param key the key to be placed into this property list.
		 * @param value the value corresponding to <tt>key</tt>.
		 * @return     the previous value of the specified key in this property
		 *             list, or <code>null</code> if it did not have one.
		 * @see #getProperty
		 * @since    1.2
		 */
		public Object setProperty(String key, String value) {
			lock (this) {
				return this[key] = value;
			}
		}


		public void load(TextReader reader) {
			lock (this) {
				load0(new LineReader(reader));
			}
		}

		public void load(Stream inStream) {
			lock (this) {
				load0(new LineReader(inStream));
			}
		}

		private void load0(LineReader lr) {
			char[] convtBuf = new char[1024];
			int limit;
			int keyLen;
			int valueStart;
			char c;
			bool hasSep;
			bool precedingBackslash;

			while ((limit = lr.readLine()) >= 0) {
				c = '\0';
				keyLen = 0;
				valueStart = limit;
				hasSep = false;

				//Console.Out.WriteLine("line=<" + new String(lineBuf, 0, limit) + ">");
				precedingBackslash = false;
				while (keyLen < limit) {
					c = lr.lineBuf[keyLen];
					//need check if escaped.
					if ((c == '=' || c == ':') && !precedingBackslash) {
						valueStart = keyLen + 1;
						hasSep = true;
						break;
					} else if ((c == ' ' || c == '\t' || c == '\f') && !precedingBackslash) {
						valueStart = keyLen + 1;
						break;
					}
					if (c == '\\') {
						precedingBackslash = !precedingBackslash;
					} else {
						precedingBackslash = false;
					}
					keyLen++;
				}
				while (valueStart < limit) {
					c = lr.lineBuf[valueStart];
					if (c != ' ' && c != '\t' && c != '\f') {
						if (!hasSep && (c == '=' || c == ':')) {
							hasSep = true;
						} else {
							break;
						}
					}
					valueStart++;
				}
				String key = loadConvert(lr.lineBuf, 0, keyLen, convtBuf);
				String value = loadConvert(lr.lineBuf, valueStart, limit - valueStart, convtBuf);
				Add(key, value);
			}
		}

		/* Read in a "logical line" from an InputStream/Reader, skip all comment
		 * and blank lines and filter out those leading whitespace characters 
		 * (\u0020, \u0009 and \u000c) from the beginning of a "natural line". 
		 * Method returns the char length of the "logical line" and stores 
		 * the line in "lineBuf". 
		 */
		class LineReader {
			public LineReader(Stream inStream) {
				this.inStream = inStream;
				inByteBuf = new byte[8192];
			}

			public LineReader(TextReader reader) {
				this.reader = reader;
				inCharBuf = new char[8192];
			}

			byte[] inByteBuf;
			char[] inCharBuf;
			internal char[] lineBuf = new char[1024];
			int inLimit = 0;
			int inOff = 0;
			Stream inStream;
			TextReader reader;

			internal int readLine() {
				int len = 0;
				char c = '\0';

				bool skipWhiteSpace = true;
				bool isCommentLine = false;
				bool isNewLine = true;
				bool appendedLineBegin = false;
				bool precedingBackslash = false;
				bool skipLF = false;

				while (true) {
					if (inOff >= inLimit) {
						inLimit = (inStream == null) ? reader.Read(inCharBuf, 0, inCharBuf.Length)
										  : inStream.Read(inByteBuf, 0, inByteBuf.Length);
						inOff = 0;
						if (inLimit <= 0) {
							if (len == 0 || isCommentLine) {
								return -1;
							}
							return len;
						}
					}
					if (inStream != null) {
						//The line below is equivalent to calling a 
						//ISO8859-1 decoder.
						c = (char)(0xff & inByteBuf[inOff++]);
					} else {
						c = inCharBuf[inOff++];
					}
					if (skipLF) {
						skipLF = false;
						if (c == '\n') {
							continue;
						}
					}
					if (skipWhiteSpace) {
						if (c == ' ' || c == '\t' || c == '\f') {
							continue;
						}
						if (!appendedLineBegin && (c == '\r' || c == '\n')) {
							continue;
						}
						skipWhiteSpace = false;
						appendedLineBegin = false;
					}
					if (isNewLine) {
						isNewLine = false;
						if (c == '#' || c == '!') {
							isCommentLine = true;
							continue;
						}
					}

					if (c != '\n' && c != '\r') {
						lineBuf[len++] = c;
						if (len == lineBuf.Length) {
							int newLength = lineBuf.Length * 2;
							if (newLength < 0) {
								newLength = Int32.MaxValue;
							}
							char[] buf = new char[newLength];
							Array.Copy(lineBuf, 0, buf, 0, lineBuf.Length);
							lineBuf = buf;
						}
						//flip the preceding backslash flag
						if (c == '\\') {
							precedingBackslash = !precedingBackslash;
						} else {
							precedingBackslash = false;
						}
					} else {
						// reached EOL
						if (isCommentLine || len == 0) {
							isCommentLine = false;
							isNewLine = true;
							skipWhiteSpace = true;
							len = 0;
							continue;
						}
						if (inOff >= inLimit) {
							inLimit = (inStream == null)
									  ? reader.Read(inCharBuf, 0, inCharBuf.Length)
						  : inStream.Read(inByteBuf, 0, inByteBuf.Length);
							inOff = 0;
							if (inLimit <= 0) {
								return len;
							}
						}
						if (precedingBackslash) {
							len -= 1;
							//skip the leading whitespace characters in following line
							skipWhiteSpace = true;
							appendedLineBegin = true;
							precedingBackslash = false;
							if (c == '\r') {
								skipLF = true;
							}
						} else {
							return len;
						}
					}
				}
			}
		}

		/*
		 * Converts encoded &#92;uxxxx to unicode chars
		 * and changes special saved chars to their original forms
		 */
		private String loadConvert(char[] input, int off, int len, char[] convtBuf) {
        if (convtBuf.Length < len) {
            int newLen = len * 2;
            if (newLen < 0) {
	        newLen = Int32.MaxValue;
	    } 
	    convtBuf = new char[newLen];
        }
        char aChar;
        char[] output = convtBuf; 
        int outLen = 0;
        int end = off + len;

        while (off < end) {
            aChar = input[off++];
            if (aChar == '\\') {
                aChar = input[off++];   
                if(aChar == 'u') {
                    // Read the xxxx
                    int value=0;
		    for (int i=0; i<4; i++) {
		        aChar = input[off++];  
		        switch (aChar) {
		          case '0': case '1': case '2': case '3': case '4':
		          case '5': case '6': case '7': case '8': case '9':
		             value = (value << 4) + aChar - '0';
			     break;
			  case 'a': case 'b': case 'c':
                          case 'd': case 'e': case 'f':
			     value = (value << 4) + 10 + aChar - 'a';
			     break;
			  case 'A': case 'B': case 'C':
                          case 'D': case 'E': case 'F':
			     value = (value << 4) + 10 + aChar - 'A';
			     break;
			  default:
                              throw new ArgumentException(
                                           "Malformed \\uxxxx encoding.");
                        }
                     }
                    output[outLen++] = (char)value;
                } else {
                    if (aChar == 't') aChar = '\t'; 
                    else if (aChar == 'r') aChar = '\r';
                    else if (aChar == 'n') aChar = '\n';
                    else if (aChar == 'f') aChar = '\f'; 
                    output[outLen++] = aChar;
                }
            } else {
	        output[outLen++] = (char)aChar;
            }
        }
        return new string(output, 0, outLen);
    }

		/*
		 * Converts unicodes to encoded &#92;uxxxx and escapes
		 * special characters with a preceding slash
		 */
		private String saveConvert(String theString,
					   bool escapeSpace,
					   bool escapeUnicode) {
			int len = theString.Length;
			int bufLen = len * 2;
			if (bufLen < 0) {
				bufLen = Int32.MaxValue;
			}
			StringBuilder outBuffer = new StringBuilder(bufLen);

			for (int x = 0; x < len; x++) {
				char aChar = theString[x];
				// Handle common case first, selecting largest block that
				// avoids the specials below
				if ((aChar > 61) && (aChar < 127)) {
					if (aChar == '\\') {
						outBuffer.Append('\\'); outBuffer.Append('\\');
						continue;
					}
					outBuffer.Append(aChar);
					continue;
				}
				switch (aChar) {
					case ' ':
						if (x == 0 || escapeSpace)
							outBuffer.Append('\\');
						outBuffer.Append(' ');
						break;
					case '\t': outBuffer.Append('\\'); outBuffer.Append('t');
						break;
					case '\n': outBuffer.Append('\\'); outBuffer.Append('n');
						break;
					case '\r': outBuffer.Append('\\'); outBuffer.Append('r');
						break;
					case '\f': outBuffer.Append('\\'); outBuffer.Append('f');
						break;
					case '=': // Fall through
					case ':': // Fall through
					case '#': // Fall through
					case '!':
						outBuffer.Append('\\'); outBuffer.Append(aChar);
						break;
					default:
						if (((aChar < 0x0020) || (aChar > 0x007e)) & escapeUnicode) {
							outBuffer.Append('\\');
							outBuffer.Append('u');
							outBuffer.Append(toHex((aChar >> 12) & 0xF));
							outBuffer.Append(toHex((aChar >> 8) & 0xF));
							outBuffer.Append(toHex((aChar >> 4) & 0xF));
							outBuffer.Append(toHex(aChar & 0xF));
						} else {
							outBuffer.Append(aChar);
						}
						break;
				}
			}
			return outBuffer.ToString();
		}

		private static void writeComments(TextWriter bw, String comments) {
			bw.Write("#");
			int len = comments.Length;
			int current = 0;
			int last = 0;
			char[] uu = new char[6];
			uu[0] = '\\';
			uu[1] = 'u';
			while (current < len) {
				char c = comments[current];
				if (c > '\u00ff' || c == '\n' || c == '\r') {
					if (last != current)
						bw.Write(comments.Substring(last, current - last));
					if (c > '\u00ff') {
						uu[2] = toHex((c >> 12) & 0xf);
						uu[3] = toHex((c >> 8) & 0xf);
						uu[4] = toHex((c >> 4) & 0xf);
						uu[5] = toHex(c & 0xf);
						bw.Write(new String(uu));
					} else {
						bw.WriteLine();
						if (c == '\r' &&
				current != len - 1 &&
				comments[current + 1] == '\n') {
							current++;
						}
						if (current == len - 1 ||
							(comments[current + 1] != '#' &&
				comments[current + 1] != '!'))
							bw.Write("#");
					}
					last = current + 1;
				}
				current++;
			}
			if (last != current)
				bw.Write(comments.Substring(last, current - last));
			bw.WriteLine();
		}

		public void store(TextWriter writer, String comments) {
			store0(writer, comments, false);
		}

		public void store(Stream output, String comments) {
			store0(new StreamWriter(output, Encoding.UTF8), comments, true);
		}

		private void store0(TextWriter bw, String comments, bool escUnicode) {
			if (comments != null) {
				writeComments(bw, comments);
			}
			bw.Write("#" + DateTime.Now);
			bw.WriteLine();
			lock (this) {
				foreach (KeyValuePair<object, object> pair in this) {
					string key = (string)pair.Key;
					string val = (string)pair.Value;
					key = saveConvert(key, true, escUnicode);
					/* No need to escape embedded and trailing spaces for value, hence
			 * pass false to flag.
			 */
					val = saveConvert(val, false, escUnicode);
					bw.Write(key + "=" + val);
					bw.WriteLine();
				}
			}
			bw.Flush();
		}

		/*
		TODO: XML...
		public void loadFromXML(Stream input) {
			Lock (this) {
				if (input == null)
					throw new ArgumentNullException();
				XMLUtils.load(this, input);
				input.Close();
			}
		}

		public void storeToXML(Stream os, String comment) {
			Lock (this) {
				if (os == null)
					throw new ArgumentNullException("os");
				storeToXML(os, comment, "UTF-8");
			}
		}

		public void storeToXML(Stream os, String comment,
										   String encoding) {
			Lock (this) {
				if (os == null)
					throw new ArgumentNullException();
				XMLUtils.save(this, os, comment, encoding);
			}
		}
		*/

		public String getProperty(String key) {
			Object oval;
			if (!TryGetValue(key, out oval)) oval = null;
			String sval = (oval is String) ? (String)oval : null;
			return ((sval == null) && (defaults != null)) ? defaults.getProperty(key) : sval;
		}

		public String getProperty(String key, String defaultValue) {
			String val = getProperty(key);
			return (val == null) ? defaultValue : val;
		}

		public ICollection propertyNames() {
			Hashtable h = new Hashtable();
			enumerate(h);
			return h.Keys;
		}

		public ICollection<String> stringPropertyNames() {
			Dictionary<String, String> h = new Dictionary<string, string>();
			enumerateStringProperties(h);
			return h.Keys;
		}

		private void enumerate(IDictionary h) {
			lock (this) {
				if (defaults != null) {
					defaults.enumerate(h);
				}
				foreach (KeyValuePair<object, object> pair in this) {
					h.Add(pair.Key, pair.Value);
				}
			}
		}

		private void enumerateStringProperties(IDictionary<String, String> h) {
			lock (this) {
				if (defaults != null) {
					defaults.enumerateStringProperties(h);
				}
				foreach (KeyValuePair<object, object> pair in this) {
					if (pair.Key is String && pair.Value is String) {
						h.Add((String)pair.Key, (String)pair.Value);
					}
				}
			}
		}

		private static char toHex(int nibble) {
			return hexDigit[(nibble & 0xF)];
		}

		/** A table of hex digits */
		private static readonly char[] hexDigit = {
	'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'
    };
	}
}